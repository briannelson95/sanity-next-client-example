import { getDraftId, isDraftId } from '../../util';
import { checkoutPair } from './document-pair/checkoutPair';
import { consistencyStatus } from './document-pair/consistencyStatus';
import { documentEvents } from './document-pair/documentEvents';
import { editOperations } from './document-pair/editOperations';
import { editState } from './document-pair/editState';
import { getOperationEvents } from './document-pair/operationEvents';
import { validation } from './document-pair/validation';
import { listenQuery } from './listenQuery';
import { resolveTypeForDocument } from './resolveTypeForDocument';
import { getInitialValueStream } from './initialValue';

function getIdPairFromPublished(publishedId) {
  if (isDraftId(publishedId)) {
    throw new Error('editOpsOf does not expect a draft id.');
  }

  return {
    publishedId,
    draftId: getDraftId(publishedId)
  };
}

export function createDocumentStore(_ref) {
  let {
    client,
    documentPreviewStore,
    historyStore,
    initialValueTemplates,
    schema
  } = _ref;
  const versionedClient = client.withConfig({
    apiVersion: '2021-12-01'
  });
  const ctx = {
    client,
    documentPreviewStore,
    historyStore,
    schema
  };
  const caches = {
    pair: {
      editOperations: new Map()
    }
  };
  const operationEvents = getOperationEvents(ctx);
  return {
    // Public API
    checkoutPair(idPair) {
      return checkoutPair(versionedClient, idPair);
    },

    initialValue(opts) {
      return getInitialValueStream(schema, initialValueTemplates, documentPreviewStore, opts);
    },

    listenQuery(query, params, options) {
      return listenQuery(versionedClient, query, params, options);
    },

    resolveTypeForDocument(id, specifiedType) {
      return resolveTypeForDocument(versionedClient, id, specifiedType);
    },

    pair: {
      consistencyStatus(publishedId, type) {
        return consistencyStatus(ctx.client, getIdPairFromPublished(publishedId), type);
      },

      documentEvents(publishedId, type) {
        return documentEvents(ctx.client, getIdPairFromPublished(publishedId), type);
      },

      editOperations(publishedId, type) {
        const cache = caches.pair.editOperations;
        const key = "".concat(publishedId, ":").concat(type);

        if (!cache.has(key)) {
          cache.set(key, editOperations(ctx, getIdPairFromPublished(publishedId), type));
        }

        return cache.get(key);
      },

      editState(publishedId, type) {
        return editState(ctx, getIdPairFromPublished(publishedId), type);
      },

      operationEvents(publishedId, type) {
        return operationEvents(getIdPairFromPublished(publishedId), type);
      },

      validation(publishedId, type) {
        return validation(ctx, getIdPairFromPublished(publishedId), type);
      }

    }
  };
}