import { useMemo } from 'react';
import { timer, fromEvent, EMPTY, of, forkJoin } from 'rxjs';
import { map, startWith, distinctUntilChanged, switchMap, shareReplay, catchError } from 'rxjs/operators';
import { useDocumentStore, useCrossProjectTokenStore } from '../../../datastores';
import { useClient } from '../../../hooks';
import { createHookFromObservableFactory, getPublishedId, getDraftId } from '../../../util';

// this is used in place of `instanceof` so the matching can be more robust and
// won't have any issues with dual packages etc
// https://nodejs.org/api/packages.html#dual-package-hazard
function isClientError(e) {
  if (typeof e !== 'object') return false;
  if (!e) return false;
  return 'statusCode' in e && 'response' in e;
}

const POLL_INTERVAL = 5000; // only fetches when the document is visible

let visiblePoll$;

const getVisiblePoll$ = () => {
  if (!visiblePoll$) {
    visiblePoll$ = fromEvent(document, 'visibilitychange').pipe( // add empty emission to have this fire on creation
    startWith(null), map(() => document.visibilityState === 'visible'), distinctUntilChanged(), switchMap(visible => visible ? // using timer instead of interval since timer will emit on creation
    timer(0, POLL_INTERVAL) : EMPTY), shareReplay({
      refCount: true,
      bufferSize: 1
    }));
  }

  return visiblePoll$;
};

function getDocumentExistence(documentId, _ref) {
  let {
    versionedClient
  } = _ref;
  const draftId = getDraftId(documentId);
  const publishedId = getPublishedId(documentId);
  const requestOptions = {
    uri: versionedClient.getDataUrl('doc', "".concat(draftId, ",").concat(publishedId)),
    json: true,
    query: {
      excludeContent: 'true'
    },
    tag: 'use-referring-documents.document-existence'
  };
  return versionedClient.observable.request(requestOptions).pipe(map(_ref2 => {
    let {
      omitted
    } = _ref2;
    const nonExistant = omitted.filter(doc => doc.reason === 'existence');

    if (nonExistant.length === 2) {
      // None of the documents exist
      return undefined;
    }

    if (nonExistant.length === 0) {
      // Both exist, so use the published one
      return publishedId;
    } // If the draft does not exist, use the published ID, and vice versa


    return nonExistant.some(doc => doc.id === draftId) ? publishedId : draftId;
  }));
}
/**
 * fetches the cross-dataset references using the client observable.request
 * method (for that requests can be automatically cancelled)
 */


function fetchCrossDatasetReferences(documentId, context) {
  const {
    crossProjectTokenStore,
    versionedClient
  } = context;
  return getVisiblePoll$().pipe(switchMap(() => forkJoin({
    checkDocumentId: getDocumentExistence(documentId, context),
    crossProjectTokens: crossProjectTokenStore.fetchAllCrossProjectTokens()
  })), switchMap(_ref3 => {
    let {
      checkDocumentId,
      crossProjectTokens
    } = _ref3;

    if (!checkDocumentId) {
      return of({
        totalCount: 0,
        references: []
      });
    }

    const currentDataset = versionedClient.config().dataset;
    const headers = crossProjectTokens.length > 0 ? {
      'sanity-project-tokens': crossProjectTokens.map(t => "".concat(t.projectId, "=").concat(t.token)).join(',')
    } : {};
    return versionedClient.observable.request({
      url: "/data/references/".concat(currentDataset, "/documents/").concat(checkDocumentId, "/to?excludeInternalReferences=true&excludePaths=true"),
      headers,
      tag: 'use-referring-documents.external'
    }).pipe(catchError(e => {
      // it's possible that referencing document doesn't exist yet so the
      // API will return a 404. In those cases, we want to catch and return
      // a response with no references
      if (isClientError(e) && e.statusCode === 404) {
        return of({
          totalCount: 0,
          references: []
        });
      }

      throw e;
    }));
  }));
}

const useInternalReferences = createHookFromObservableFactory((documentId, context) => {
  const {
    documentStore
  } = context;
  const referencesClause = '*[references($documentId)][0...100]{_id,_type}';
  const totalClause = 'count(*[references($documentId)])';
  const fetchQuery = "{\"references\":".concat(referencesClause, ",\"totalCount\":").concat(totalClause, "}");
  const listenQuery = '*[references($documentId)]';
  return documentStore.listenQuery({
    fetch: fetchQuery,
    listen: listenQuery
  }, {
    documentId
  }, {
    tag: 'use-referring-documents',
    transitions: ['appear', 'disappear'],
    throttleTime: 5000
  });
});
const useCrossDatasetReferences = createHookFromObservableFactory((documentId, context, versionedClient) => {
  const {
    crossProjectTokenStore
  } = context;
  return getVisiblePoll$().pipe(switchMap(() => fetchCrossDatasetReferences(documentId, {
    versionedClient,
    crossProjectTokenStore
  })));
});
export function useReferringDocuments(documentId) {
  const client = useClient();
  const versionedClient = useMemo(() => client.withConfig({
    apiVersion: '2022-03-07'
  }), [client]);
  const documentStore = useDocumentStore();
  const crossProjectTokenStore = useCrossProjectTokenStore();
  const publishedId = getPublishedId(documentId);
  const [internalReferences, isInternalReferencesLoading] = useInternalReferences(publishedId, {
    documentStore
  });
  const [crossDatasetReferences, isCrossDatasetReferencesLoading] = useCrossDatasetReferences(publishedId, {
    crossProjectTokenStore
  }, versionedClient);
  const projectIds = useMemo(() => {
    return Array.from(new Set(crossDatasetReferences === null || crossDatasetReferences === void 0 ? void 0 : crossDatasetReferences.references.map(crossDatasetReference => crossDatasetReference.projectId).filter(Boolean))).sort();
  }, [crossDatasetReferences === null || crossDatasetReferences === void 0 ? void 0 : crossDatasetReferences.references]);
  return {
    totalCount: ((internalReferences === null || internalReferences === void 0 ? void 0 : internalReferences.totalCount) || 0) + ((crossDatasetReferences === null || crossDatasetReferences === void 0 ? void 0 : crossDatasetReferences.totalCount) || 0),
    projectIds,
    internalReferences,
    crossDatasetReferences,
    isLoading: isInternalReferencesLoading || isCrossDatasetReferencesLoading
  };
}