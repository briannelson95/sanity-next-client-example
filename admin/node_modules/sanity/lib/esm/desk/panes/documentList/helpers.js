import * as PathUtils from '@sanity/util/paths';
import { isIndexSegment, isKeySegment, isReferenceSchemaType } from '@sanity/types';
import { getPublishedId, collate } from '../../../util';
export function getDocumentKey(value, index) {
  return value._id ? getPublishedId(value._id) : "item-".concat(index);
}
export function removePublishedWithDrafts(documents) {
  return collate(documents).map(entry => {
    const doc = entry.draft || entry.published;
    return { ...doc,
      hasPublished: !!entry.published,
      hasDraft: !!entry.draft
    };
  });
}
const RE_TYPE_NAME_IN_FILTER = /\b_type\s*==\s*(['"].*?['"]|\$.*?(?:\s|$))|\B(['"].*?['"]|\$.*?(?:\s|$))\s*==\s*_type\b/;
export function getTypeNameFromSingleTypeFilter(filter) {
  let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const matches = filter.match(RE_TYPE_NAME_IN_FILTER);

  if (!matches) {
    return null;
  }

  const match = (matches[1] || matches[2]).trim().replace(/^["']|["']$/g, '');

  if (match[0] === '$') {
    const k = match.slice(1);
    const v = params[k];
    return typeof v === 'string' ? v : null;
  }

  return match;
}
export function isSimpleTypeFilter(filter) {
  return /^_type\s*==\s*['"$]\w+['"]?\s*$/.test(filter.trim());
}
export function toOrderClause(orderBy) {
  return orderBy.map(ordering => [wrapFieldWithFn(ordering), (ordering.direction || '').toLowerCase()].map(str => str.trim()).filter(Boolean).join(' ')).join(',');
}

function wrapFieldWithFn(ordering) {
  return ordering.mapWith ? "".concat(ordering.mapWith, "(").concat(ordering.field, ")") : ordering.field;
}

export function applyOrderingFunctions(order, schemaType) {
  const orderBy = order.by.map(by => {
    // Skip those that already have a mapper
    if (by.mapWith) {
      return by;
    }

    const fieldType = tryResolveSchemaTypeForPath(schemaType, by.field);

    if (!fieldType) {
      return by;
    } // Note: order matters here, since the jsonType of a date field is `string`,
    // but we want to apply `datetime()`, not `lower()`


    if (fieldExtendsType(fieldType, 'datetime')) {
      return { ...by,
        mapWith: 'dateTime'
      };
    }

    if (fieldType.jsonType === 'string') {
      return { ...by,
        mapWith: 'lower'
      };
    }

    return by;
  });
  return orderBy.every((item, index) => item === order.by[index]) ? order : { ...order,
    by: orderBy
  };
}

function tryResolveSchemaTypeForPath(baseType, path) {
  const pathSegments = PathUtils.fromString(path);
  let current = baseType;

  for (const segment of pathSegments) {
    if (!current) {
      return undefined;
    }

    if (typeof segment === 'string') {
      current = getFieldTypeByName(current, segment);
      continue;
    }

    const isArrayAccessor = isKeySegment(segment) || isIndexSegment(segment);

    if (!isArrayAccessor || current.jsonType !== 'array') {
      return undefined;
    }

    const [memberType, otherType] = current.of || [];

    if (otherType || !memberType) {
      // Can't figure out the type without knowing the value
      return undefined;
    }

    if (!isReferenceSchemaType(memberType)) {
      current = memberType;
      continue;
    }

    const [refType, otherRefType] = memberType.to || [];

    if (otherRefType || !refType) {
      // Can't figure out the type without knowing the value
      return undefined;
    }

    current = refType;
  }

  return current;
}

function getFieldTypeByName(type, fieldName) {
  if (!('fields' in type)) {
    return undefined;
  }

  const fieldType = type.fields.find(field => field.name === fieldName);
  return fieldType ? fieldType.type : undefined;
}

export function fieldExtendsType(field, ofType) {
  let current = field.type;

  while (current) {
    if (current.name === ofType) {
      return true;
    }

    if (!current.type && current.jsonType === ofType) {
      return true;
    }

    current = current.type;
  }

  return false;
}