import _omit from "lodash/omit";
import React, { memo, useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { useToast } from '@sanity/ui';
import { fromString as pathFromString } from '@sanity/util/paths';
import isHotkey from 'is-hotkey';
import { useMemoObservable } from 'react-rx';
import { useHistoryStore, useInitialValue, usePresenceStore } from '../../../datastores';
import { useClient, useConnectionState, useDocumentOperation, useEditState, useSchema, useTemplates, useValidationStatus } from '../../../hooks';
import { isDev } from '../../../environment';
import { useSource } from '../../../studio';
import { getPublishedId, useUnique } from '../../../util';
import { usePaneRouter } from '../../components';
import { toMutationPatches } from '../../../form';
import { useFormState } from '../../../form/store/useFormState';
import { setAtPath } from '../../../form/store/stateTreeHelper';
import { getExpandOperations } from '../../../form/store/utils/getExpandOperations';
import { useDeskTool } from '../../useDeskTool';
import { DocumentPaneContext } from './DocumentPaneContext';
import { getMenuItems } from './menuItems';
import { usePreviewUrl } from './usePreviewUrl';
import { getInitialValueTemplateOpts } from './getInitialValueTemplateOpts';
const emptyObject = {};
/**
 * @internal
 */
// eslint-disable-next-line complexity, max-statements

export const DocumentPaneProvider = /*#__PURE__*/memo(props => {
  const {
    children,
    index,
    pane,
    paneKey
  } = props;
  const client = useClient();
  const schema = useSchema();
  const templates = useTemplates();
  const {
    actions: documentActions,
    badges: documentBadges,
    unstable_languageFilter: languageFilterResolver
  } = useSource().document;
  const historyStore = useHistoryStore();
  const presenceStore = usePresenceStore();
  const paneRouter = usePaneRouter();
  const {
    features
  } = useDeskTool();
  const {
    push: pushToast
  } = useToast();
  const {
    options,
    menuItemGroups,
    title = null,
    views: viewsProp = []
  } = pane;
  const paneOptions = useUnique(options);
  const documentIdRaw = paneOptions.id;
  const documentId = getPublishedId(documentIdRaw);
  const documentType = options.type;
  const paneParams = useUnique(paneRouter.params);
  const panePayload = useUnique(paneRouter.payload);
  const {
    templateName,
    templateParams
  } = useMemo(() => getInitialValueTemplateOpts(templates, {
    documentType,
    templateName: paneOptions.template,
    templateParams: paneOptions.templateParameters,
    panePayload,
    urlTemplate: paneParams === null || paneParams === void 0 ? void 0 : paneParams.template
  }), [documentType, paneOptions, paneParams, panePayload, templates]);
  const initialValueRaw = useInitialValue({
    documentId,
    documentType,
    templateName,
    templateParams
  });
  const initialValue = useUnique(initialValueRaw);
  const {
    patch
  } = useDocumentOperation(documentId, documentType);
  const editState = useEditState(documentId, documentType);
  const {
    validation: validationRaw
  } = useValidationStatus(documentId, documentType);
  const connectionState = useConnectionState(documentId, documentType);
  const schemaType = schema.get(documentType);
  const value = (editState === null || editState === void 0 ? void 0 : editState.draft) || (editState === null || editState === void 0 ? void 0 : editState.published) || initialValue.value; // Resolve document actions

  const actions = useMemo(() => documentActions({
    schemaType: documentType,
    documentId
  }), [documentActions, documentId, documentType]); // Resolve document badges

  const badges = useMemo(() => documentBadges({
    schemaType: documentType,
    documentId
  }), [documentBadges, documentId, documentType]); // Resolve document language filter

  const languageFilter = useMemo(() => languageFilterResolver({
    schemaType: documentType,
    documentId
  }), [documentId, documentType, languageFilterResolver]);
  const validation = useUnique(validationRaw);
  const views = useUnique(viewsProp);
  const params = paneRouter.params || emptyObject;
  const [focusPath, setFocusPath] = useState(() => params.path ? pathFromString(params.path) : []);
  const activeViewId = params.view || views[0] && views[0].id || null;
  const timeline = useMemo(() => historyStore.getTimeline({
    publishedId: documentId,
    enableTrace: isDev
  }), [documentId, historyStore]);
  const [timelineMode, setTimelineMode] = useState('closed'); // NOTE: this emits sync so can never be null
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion

  const {
    historyController
  } = useMemoObservable(() => historyStore.getTimelineController({
    client,
    documentId,
    documentType,
    timeline
  }), [client, documentId, documentType, timeline]); // @todo: this will now happen on each render, but should be refactored so it happens only when
  // the `rev`, `since` or `historyController` values change.

  historyController.setRange(params.since || null, params.rev || null);
  const changesOpen = historyController.changesPanelActive(); // TODO: this may cause a lot of churn. May be a good idea to prevent these
  // requests unless the menu is open somehow

  const previewUrl = usePreviewUrl(value);
  const [presence, setPresence] = useState([]);
  useEffect(() => {
    const subscription = presenceStore.documentPresence(documentId).subscribe(nextPresence => {
      setPresence(nextPresence);
    });
    return () => {
      subscription.unsubscribe();
    };
  }, [documentId, presenceStore]);
  const hasValue = Boolean(value);
  const menuItems = useMemo(() => getMenuItems({
    features,
    hasValue,
    changesOpen,
    previewUrl
  }), [features, hasValue, changesOpen, previewUrl]);
  const inspectOpen = params.inspect === 'on';
  const compareValue = changesOpen ? historyController.sinceAttributes() : (editState === null || editState === void 0 ? void 0 : editState.published) || null;
  const ready = connectionState === 'connected' && editState.ready;
  const viewOlderVersion = historyController.onOlderRevision();
  const displayed = useMemo(() => viewOlderVersion ? historyController.displayed() : value, // eslint-disable-next-line react-hooks/exhaustive-deps
  [historyController, params.rev, params.since, value, viewOlderVersion]);
  const setTimelineRange = useCallback((newSince, newRev) => {
    paneRouter.setParams({ ...paneRouter.params,
      since: newSince,
      rev: newRev || undefined
    });
  }, [paneRouter]);
  const handleFocus = useCallback(nextFocusPath => {
    setFocusPath(nextFocusPath);
    presenceStore.setLocation([{
      type: 'document',
      documentId,
      path: nextFocusPath,
      lastActiveAt: new Date().toISOString()
    }]);
  }, [documentId, presenceStore, setFocusPath]);
  const handleBlur = useCallback(blurredPath => {
    setFocusPath([]); // note: we're deliberately not syncing presence here since it would make the user avatar disappear when a
    // user clicks outside a field without focusing another one
  }, [setFocusPath]);
  const patchRef = useRef(() => {
    throw new Error('Nope');
  });

  patchRef.current = event => {
    patch.execute(toMutationPatches(event.patches), initialValue.value);
  };

  const handleChange = useCallback(event => patchRef.current(event), []);
  const handleHistoryClose = useCallback(() => {
    paneRouter.setParams({ ...params,
      since: undefined
    });
  }, [paneRouter, params]);
  const handleHistoryOpen = useCallback(() => {
    paneRouter.setParams({ ...params,
      since: '@lastPublished'
    });
  }, [paneRouter, params]);
  const handlePaneClose = useCallback(() => paneRouter.closeCurrent(), [paneRouter]);
  const handlePaneSplit = useCallback(() => paneRouter.duplicateCurrent(), [paneRouter]);
  const toggleInspect = useCallback(function () {
    let toggle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !inspectOpen;

    if (toggle) {
      paneRouter.setParams({ ...params,
        inspect: 'on'
      });
    } else {
      paneRouter.setParams(_omit(params, 'inspect'));
    }
  }, [inspectOpen, paneRouter, params]);
  const handleMenuAction = useCallback(item => {
    if (item.action === 'production-preview' && previewUrl) {
      window.open(previewUrl);
      return true;
    }

    if (item.action === 'inspect') {
      toggleInspect(true);
      return true;
    }

    if (item.action === 'reviewChanges') {
      handleHistoryOpen();
      return true;
    }

    return false;
  }, [handleHistoryOpen, previewUrl, toggleInspect]);
  const handleKeyUp = useCallback(event => {
    for (const item of menuItems) {
      if (item.shortcut) {
        if (isHotkey(item.shortcut, event)) {
          event.preventDefault();
          event.stopPropagation();
          handleMenuAction(item);
          return;
        }
      }
    }
  }, [handleMenuAction, menuItems]);
  const handleInspectClose = useCallback(() => toggleInspect(false), [toggleInspect]);
  const [openPath, onSetOpenPath] = useState([]);
  const [fieldGroupState, onSetFieldGroupState] = useState();
  const [collapsedPaths, onSetCollapsedPath] = useState();
  const [collapsedFieldSets, onSetCollapsedFieldSets] = useState();
  const handleOnSetCollapsedPath = useCallback((path, collapsed) => {
    onSetCollapsedPath(prevState => setAtPath(prevState, path, collapsed));
  }, []);
  const handleOnSetCollapsedFieldSet = useCallback((path, collapsed) => {
    onSetCollapsedFieldSets(prevState => setAtPath(prevState, path, collapsed));
  }, []);
  const handleSetActiveFieldGroup = useCallback((path, groupName) => onSetFieldGroupState(prevState => setAtPath(prevState, path, groupName)), []);
  const formState = useFormState(schemaType, {
    value,
    comparisonValue: compareValue,
    focusPath,
    openPath,
    collapsedPaths,
    presence,
    validation,
    collapsedFieldSets: collapsedFieldSets,
    fieldGroupState
  });
  const formStateRef = useRef(formState);
  formStateRef.current = formState;
  const handleOpenPath = useCallback(path => {
    const ops = getExpandOperations(formStateRef.current, path);
    ops.forEach(op => {
      if (op.type === 'expandPath') {
        onSetCollapsedPath(prevState => setAtPath(prevState, op.path, false));
      }

      if (op.type === 'expandFieldSet') {
        onSetCollapsedFieldSets(prevState => setAtPath(prevState, op.path, false));
      }

      if (op.type === 'setSelectedGroup') {
        onSetFieldGroupState(prevState => setAtPath(prevState, op.path, op.groupName));
      }
    });
    onSetOpenPath(path);
  }, [formStateRef]);
  const documentPane = {
    actions,
    activeViewId,
    badges,
    changesOpen,
    collapsedFieldSets,
    collapsedPaths,
    compareValue,
    connectionState,
    displayed,
    documentId,
    documentIdRaw,
    documentType,
    editState,
    focusPath,
    menuItems,
    onBlur: handleBlur,
    onChange: handleChange,
    onFocus: handleFocus,
    onPathOpen: handleOpenPath,
    onHistoryClose: handleHistoryClose,
    onHistoryOpen: handleHistoryOpen,
    onInspectClose: handleInspectClose,
    onKeyUp: handleKeyUp,
    onMenuAction: handleMenuAction,
    onPaneClose: handlePaneClose,
    onPaneSplit: handlePaneSplit,
    onSetActiveFieldGroup: handleSetActiveFieldGroup,
    onSetCollapsedPath: handleOnSetCollapsedPath,
    onSetCollapsedFieldSet: handleOnSetCollapsedFieldSet,
    historyController,
    index,
    inspectOpen,
    validation,
    menuItemGroups: menuItemGroups || [],
    paneKey,
    previewUrl,
    ready,
    schemaType: schemaType,
    setTimelineMode,
    setTimelineRange,
    timeline,
    timelineMode,
    title,
    value,
    views,
    formState,
    unstable_languageFilter: languageFilter
  };
  useEffect(() => {
    if (connectionState === 'reconnecting') {
      pushToast({
        id: 'sanity/desk/reconnecting',
        status: 'warning',
        title: /*#__PURE__*/React.createElement(React.Fragment, null, "Connection lost. Reconnecting\u2026")
      });
    }
  }, [connectionState, pushToast]); // Reset `focusPath` when `documentId` or `params.path` changes

  useEffect(() => {
    // Reset focus path
    setFocusPath(params.path ? pathFromString(params.path) : []);
  }, [documentId, params.path]);
  return /*#__PURE__*/React.createElement(DocumentPaneContext.Provider, {
    value: documentPane
  }, children);
});
DocumentPaneProvider.displayName = 'DocumentPaneProvider';