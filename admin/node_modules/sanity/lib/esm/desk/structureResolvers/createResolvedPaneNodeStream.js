import _isEqual from "lodash/isEqual";
import { generateHelpUrl } from '@sanity/generate-help-url';
import { NEVER, of as observableOf, concat } from 'rxjs';
import { switchMap, map, scan, distinctUntilChanged, pairwise, startWith } from 'rxjs/operators';
import { assignId } from './assignId';
import { createPaneResolver } from './createPaneResolver';
import { memoBind } from './memoBind';
import { PaneResolutionError } from './PaneResolutionError';
/**
 * the fallback editor child that is implicitly inserted into the structure tree
 * if the id starts with `__edit__`
 */

const fallbackEditorChild = (nodeId, context) => {
  const id = nodeId.replace(/^__edit__/, '');
  const {
    params,
    payload,
    structureContext: {
      resolveDocumentNode
    }
  } = context;
  const {
    type,
    template
  } = params;

  if (!type) {
    throw new Error("Document type for document with ID ".concat(id, " was not provided in the router params."));
  }

  let defaultDocumentBuilder = resolveDocumentNode({
    schemaType: type,
    documentId: id
  });
  defaultDocumentBuilder = defaultDocumentBuilder.id('editor').title('Editor');

  if (template) {
    defaultDocumentBuilder = defaultDocumentBuilder.initialValueTemplate(template, payload);
  }

  return defaultDocumentBuilder.serialize();
};
/**
 * takes in a `RouterPaneSiblingContext` and returns a normalized string
 * representation that can be used for comparisons
 */


function hashContext(context) {
  var _context$serializeOpt, _context$serializeOpt2;

  return "contextHash(".concat(JSON.stringify({
    id: context.id,
    parentId: parent && assignId(parent),
    path: context.path,
    index: context.index,
    splitIndex: context.splitIndex,
    serializeOptionsIndex: (_context$serializeOpt = context.serializeOptions) === null || _context$serializeOpt === void 0 ? void 0 : _context$serializeOpt.index,
    serializeOptionsPath: (_context$serializeOpt2 = context.serializeOptions) === null || _context$serializeOpt2 === void 0 ? void 0 : _context$serializeOpt2.path
  }), ")");
}
/**
 * takes in `ResolvedPaneMeta` and returns a normalized string representation
 * that can be used for comparisons
 */


const hashResolvedPaneMeta = meta => {
  const normalized = {
    type: meta.type,
    id: meta.routerPaneSibling.id,
    params: meta.routerPaneSibling.params || {},
    payload: meta.routerPaneSibling.payload || null,
    flatIndex: meta.flatIndex,
    groupIndex: meta.groupIndex,
    siblingIndex: meta.siblingIndex,
    path: meta.path,
    paneNode: meta.type === 'resolvedMeta' ? assignId(meta.paneNode) : null
  };
  return "metaHash(".concat(JSON.stringify(normalized), ")");
};
/**
 * Represents one flattened "router pane", including the source group and
 * sibling indexes.
 *
 * @see RouterPanes
 */


/**
 * A recursive pane resolving function. Starts at one unresolved pane node and
 * continues until there is no more flattened router panes that can be used as
 * input to the unresolved panes.
 */
function resolvePaneTree(_ref) {
  let {
    unresolvedPane,
    flattenedRouterPanes,
    parent,
    path,
    resolvePane,
    structureContext
  } = _ref;
  const [current, ...rest] = flattenedRouterPanes;
  const next = rest[0];
  const context = {
    id: current.routerPaneSibling.id,
    splitIndex: current.siblingIndex,
    parent,
    path: [...path, current.routerPaneSibling.id],
    index: current.flatIndex,
    params: current.routerPaneSibling.params || {},
    payload: current.routerPaneSibling.payload,
    structureContext
  };

  try {
    return resolvePane(unresolvedPane, context, current.flatIndex).pipe( // this switch map receives a resolved pane
    switchMap(paneNode => {
      // we can create a `resolvedMeta` type using it
      const resolvedPaneMeta = {
        type: 'resolvedMeta',
        ...current,
        paneNode: paneNode,
        path: context.path
      }; // for the other unresolved panes, we can create "loading panes"

      const loadingPanes = rest.map((i, restIndex) => {
        const loadingPanePath = [...context.path, ...rest.slice(restIndex).map((_, currentIndex) => "[".concat(i.flatIndex + currentIndex, "]"))];
        const loadingPane = {
          type: 'loading',
          path: loadingPanePath,
          paneNode: null,
          ...i
        };
        return loadingPane;
      });

      if (!rest.length) {
        return observableOf([resolvedPaneMeta]);
      }

      let nextStream;

      if ( // the fallback editor case
      next !== null && next !== void 0 && next.routerPaneSibling.id.startsWith('__edit__')) {
        nextStream = resolvePaneTree({
          unresolvedPane: fallbackEditorChild,
          flattenedRouterPanes: rest,
          parent,
          path: context.path,
          resolvePane,
          structureContext
        });
      } else if (current.groupIndex === (next === null || next === void 0 ? void 0 : next.groupIndex)) {
        // if the next flattened router pane has the same group index as the
        // current flattened router pane, then the next flattened router pane
        // belongs to the same group (i.e. it is a split pane)
        nextStream = resolvePaneTree({
          unresolvedPane,
          flattenedRouterPanes: rest,
          parent,
          path,
          resolvePane,
          structureContext
        });
      } else {
        // normal children resolving
        nextStream = resolvePaneTree({
          unresolvedPane: typeof paneNode.child === 'function' ? memoBind(paneNode, 'child') : paneNode.child,
          flattenedRouterPanes: rest,
          parent: paneNode,
          path: context.path,
          resolvePane,
          structureContext
        });
      }

      return concat( // we emit the loading panes first in a concat (this emits immediately)
      observableOf([resolvedPaneMeta, ...loadingPanes]), // then whenever the next stream is done, the results will be combined.
      nextStream.pipe(map(nextResolvedPanes => [resolvedPaneMeta, ...nextResolvedPanes])));
    }));
  } catch (e) {
    if (e instanceof PaneResolutionError) {
      if (e.context) {
        console.warn("Pane resolution error at index ".concat(e.context.index).concat(e.context.splitIndex > 0 ? " for split pane index ".concat(e.context.splitIndex) : '', ": ").concat(e.message).concat(e.helpId ? " - see ".concat(generateHelpUrl(e.helpId)) : ''), e);
      }

      if (e.helpId === 'structure-item-returned-no-child') {
        // returning an observable of an empty array will remove loading panes
        // note: this one intentionally does not throw
        return observableOf([]);
      }
    }

    throw e;
  }
}
/**
 * Takes in a stream of `RouterPanes` and an unresolved root pane and returns
 * a stream of `ResolvedPaneMeta`
 */


export function createResolvedPaneNodeStream(_ref2) {
  let {
    routerPanesStream,
    rootPaneNode,
    initialCacheState = {
      cacheKeysByFlatIndex: [],
      flattenedRouterPanes: [],
      resolvedPaneCache: new Map(),
      resolvePane: () => NEVER
    },
    structureContext
  } = _ref2;
  const resolvedPanes$ = routerPanesStream.pipe( // add in implicit "root" router pane
  map(rawRouterPanes => [[{
    id: 'root'
  }], ...rawRouterPanes]), // create flattened router panes
  map(routerPanes => {
    const flattenedRouterPanes = routerPanes.flatMap((routerPaneGroup, groupIndex) => routerPaneGroup.map((routerPaneSibling, siblingIndex) => ({
      routerPaneSibling,
      groupIndex,
      siblingIndex
    }))) // add in the flat index
    .map((i, index) => ({ ...i,
      flatIndex: index
    }));
    return flattenedRouterPanes;
  }), // calculate a "diffIndex" used for clearing the memo cache
  startWith([]), pairwise(), map(_ref3 => {
    let [prev, curr] = _ref3;

    for (let i = 0; i < curr.length; i++) {
      const prevValue = prev[i];
      const currValue = curr[i];

      if (!_isEqual(prevValue, currValue)) {
        return {
          flattenedRouterPanes: curr,
          diffIndex: i
        };
      }
    }

    return {
      flattenedRouterPanes: curr,
      diffIndex: curr.length
    };
  }), // create the memoized `resolvePane` function and manage the memo cache
  scan((acc, next) => {
    const {
      cacheKeysByFlatIndex,
      resolvedPaneCache
    } = acc;
    const {
      flattenedRouterPanes,
      diffIndex
    } = next; // use the `cacheKeysByFlatIndex` like a dictionary to find cache keys to
    // and cache keys to delete

    const beforeDiffIndex = cacheKeysByFlatIndex.slice(0, diffIndex + 1);
    const afterDiffIndex = cacheKeysByFlatIndex.slice(diffIndex + 1);
    const keysToKeep = new Set(beforeDiffIndex.flatMap(keySet => Array.from(keySet)));
    const keysToDelete = afterDiffIndex.flatMap(keySet => Array.from(keySet)).filter(key => !keysToKeep.has(key));

    for (const key of keysToDelete) {
      resolvedPaneCache.delete(key);
    } // create a memoizing pane resolver middleware that utilizes the cache
    // maintained above. this keeps the cache from growing indefinitely


    const memoize = nextFn => (unresolvedPane, context, flatIndex) => {
      const key = unresolvedPane && "".concat(assignId(unresolvedPane), "-").concat(hashContext(context));
      const cachedResolvedPane = key && resolvedPaneCache.get(key);
      if (cachedResolvedPane) return cachedResolvedPane;
      const result = nextFn(unresolvedPane, context, flatIndex);
      if (!key) return result;
      const cacheKeySet = cacheKeysByFlatIndex[flatIndex] || new Set();
      cacheKeySet.add(key);
      cacheKeysByFlatIndex[flatIndex] = cacheKeySet;
      resolvedPaneCache.set(key, result);
      return result;
    };

    return {
      flattenedRouterPanes,
      cacheKeysByFlatIndex,
      resolvedPaneCache,
      resolvePane: createPaneResolver(memoize)
    };
  }, initialCacheState), // run the memoized, recursive resolving
  switchMap(_ref4 => {
    let {
      flattenedRouterPanes,
      resolvePane
    } = _ref4;
    return resolvePaneTree({
      unresolvedPane: rootPaneNode,
      flattenedRouterPanes,
      parent: null,
      path: [],
      resolvePane,
      structureContext
    });
  })); // after we've created a stream of `ResolvedPaneMeta[]`, we need to clean up
  // the results to remove unwanted loading panes and prevent unnecessary
  // emissions

  return resolvedPanes$.pipe( // this diffs the previous emission with the current one. if there is a new
  // loading pane at the same position where a previous pane already had a
  // resolved value (looking at the IDs to compare), then return the previous
  // pane instead of the loading pane
  scan((prev, next) => next.map((nextPane, index) => {
    const prevPane = prev[index];
    if (!prevPane) return nextPane;
    if (nextPane.type !== 'loading') return nextPane;

    if (prevPane.routerPaneSibling.id === nextPane.routerPaneSibling.id) {
      return prevPane;
    }

    return nextPane;
  }), []), // this prevents duplicate emissions
  distinctUntilChanged((prev, next) => {
    if (prev.length !== next.length) return false;

    for (let i = 0; i < next.length; i++) {
      const prevValue = prev[i];
      const nextValue = next[i];

      if (hashResolvedPaneMeta(prevValue) !== hashResolvedPaneMeta(nextValue)) {
        return false;
      }
    }

    return true;
  }));
}