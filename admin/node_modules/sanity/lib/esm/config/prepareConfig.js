import _startCase from "lodash/startCase";
import { map, shareReplay } from 'rxjs/operators';
import { studioTheme } from '@sanity/ui';
import { fromUrl } from '@sanity/bifur-client';
import { createElement, isValidElement } from 'react';
import { isValidElementType } from 'react-is';
import { createSchema } from '../schema';
import { createAuthStore } from '../datastores';
import { isNonNullable } from '../util';
import { defaultFileAssetSources, defaultImageAssetSources } from '../form/defaults';
import { validateWorkspaces } from '../studio/workspaces/validateWorkspaces';
import { _documentLanguageFilterReducer, documentActionsReducer, documentBadgesReducer, fileAssetSourceResolver, imageAssetSourceResolver, initialDocumentActions, initialDocumentBadges, initialLanguageFilter, newDocumentOptionsResolver, resolveProductionUrlReducer, schemaTemplatesReducer, schemaTypesReducer, toolsReducer } from './configPropertyReducers';
import { resolveConfigProperty } from './resolveConfigProperty';
import { ConfigResolutionError } from './ConfigResolutionError';
import { SchemaError } from './SchemaError';
import { createDefaultIcon } from './createDefaultIcon';
import { _createRenderField } from './form/_renderField';
import { _createRenderInput } from './form/_renderInput';
import { _createRenderItem } from './form/_renderItem';
import { _createRenderPreview } from './form/_renderPreview';

function normalizeLogo(logo, title) {
  let subtitle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  if (isValidElementType(logo)) return /*#__PURE__*/createElement(logo);
  if ( /*#__PURE__*/isValidElement(logo)) return logo;
  return createDefaultIcon(title, subtitle);
}
/**
 * Takes in a config (created from the `createConfig` function) and returns
 * an array of `WorkspaceSummary`. Note: this only partially resolves a config.
 *
 * For usage usage inside of the Studio, it's preferred to pull the pre-resolved
 * workspaces and sources via `useWorkspace` or `useSource`. For usage outside
 * of the Studio or for testing, use `resolveConfig`.
 */


export function prepareConfig(config) {
  const workspaceOptions = Array.isArray(config) ? config : [config];

  try {
    validateWorkspaces({
      workspaces: workspaceOptions
    });
  } catch (e) {
    throw new ConfigResolutionError({
      name: '',
      type: 'workspace',
      causes: [e.message]
    });
  }

  const workspaces = workspaceOptions.map(_ref => {
    let {
      unstable_sources: nestedSources = [],
      ...rootSource
    } = _ref;
    const sources = [rootSource, ...nestedSources];
    const resolvedSources = sources.map(source => {
      const projectId = source.projectId;
      const dataset = source.dataset;
      const auth = source.auth || createAuthStore({
        dataset,
        projectId
      });
      let schemaTypes;

      try {
        schemaTypes = resolveConfigProperty({
          propertyName: 'schema.types',
          config: source,
          context: {
            projectId,
            dataset
          },
          initialValue: [],
          reducer: schemaTypesReducer
        });
      } catch (e) {
        throw new ConfigResolutionError({
          name: source.name,
          type: 'source',
          causes: [e]
        });
      }

      const schema = createSchema({
        name: source.name,
        types: schemaTypes
      });
      const schemaValidationProblemGroups = schema._validation;
      const schemaErrors = schemaValidationProblemGroups === null || schemaValidationProblemGroups === void 0 ? void 0 : schemaValidationProblemGroups.filter(msg => msg.problems.some(p => p.severity === 'error'));

      if (schemaValidationProblemGroups && schemaErrors !== null && schemaErrors !== void 0 && schemaErrors.length) {
        // TODO: consider using the `ConfigResolutionError`
        throw new SchemaError(schema);
      }

      const source$ = auth.state.pipe(map(_ref2 => {
        let {
          client,
          authenticated,
          currentUser
        } = _ref2;
        return resolveSource({
          config: source,
          client,
          currentUser,
          schema,
          authenticated,
          auth
        });
      }), shareReplay(1));
      return Object.assign(source$, {
        name: source.name,
        projectId: source.projectId,
        dataset: source.dataset,
        title: source.title || _startCase(source.name),
        auth,
        schema
      });
    });

    const title = rootSource.title || _startCase(rootSource.name);

    const workspaceSummary = {
      type: 'workspace-summary',
      auth: resolvedSources[0].auth,
      basePath: rootSource.basePath || '/',
      dataset: rootSource.dataset,
      schema: resolvedSources[0].schema,
      icon: normalizeLogo(rootSource.icon, title, "".concat(rootSource.projectId, " ").concat(rootSource.dataset)),
      name: rootSource.name || 'default',
      projectId: rootSource.projectId,
      theme: rootSource.theme || studioTheme,
      title,
      subtitle: rootSource.subtitle,
      __internal: {
        sources: resolvedSources
      }
    };
    return workspaceSummary;
  });
  return {
    type: 'prepared-config',
    workspaces
  };
}

function getBifurClient(client, auth) {
  const bifurVersionedClient = client.withConfig({
    apiVersion: '2022-06-30'
  });
  const dataset = bifurVersionedClient.config().dataset;
  const url = bifurVersionedClient.getUrl("/socket/".concat(dataset)).replace(/^http/, 'ws');
  return fromUrl(url, auth.token ? {
    token$: auth.token
  } : {});
}

function resolveSource(_ref3) {
  var _config$form, _config$form$file, _config$form2, _config$form2$file;

  let {
    config,
    client,
    currentUser,
    schema,
    authenticated,
    auth
  } = _ref3;
  const {
    dataset,
    projectId
  } = config;
  const bifur = getBifurClient(client, auth);
  const errors = [];
  const context = {
    client,
    currentUser,
    dataset,
    projectId,
    schema
  };
  let templates;

  try {
    templates = resolveConfigProperty({
      config,
      context,
      propertyName: 'schema.templates',
      reducer: schemaTemplatesReducer,
      initialValue: schema.getTypeNames().filter(typeName => !/^sanity\./.test(typeName)).map(typeName => schema.get(typeName)).filter(isNonNullable).filter(schemaType => {
        var _schemaType$type;

        return ((_schemaType$type = schemaType.type) === null || _schemaType$type === void 0 ? void 0 : _schemaType$type.name) === 'document';
      }).map(schemaType => {
        const template = {
          id: schemaType.name,
          schemaType: schemaType.name,
          title: schemaType.title || schemaType.name,
          icon: schemaType.icon,
          value: schemaType.initialValue || {
            _type: schemaType.name
          }
        };
        return template;
      })
    }); // TODO: validate templates
    // TODO: validate that each one has a unique template ID
  } catch (e) {
    errors.push(e);
  }

  let tools;

  try {
    tools = resolveConfigProperty({
      config,
      context,
      initialValue: [],
      propertyName: 'tools',
      reducer: toolsReducer
    });
  } catch (e) {
    errors.push(e);
  }

  const initialTemplatesResponses = templates // filter out the ones with parameters to fill
  .filter(template => {
    var _template$parameters;

    return !((_template$parameters = template.parameters) !== null && _template$parameters !== void 0 && _template$parameters.length);
  }).map(template => ({
    templateId: template.id,
    description: template.description,
    icon: template.icon,
    title: template.title
  }));
  const templateMap = templates.reduce((acc, template) => {
    acc.set(template.id, template);
    return acc;
  }, new Map()); // TODO: extract this function

  const resolveNewDocumentOptions = creationContext => {
    const {
      schemaType: schemaTypeName
    } = creationContext;
    const templateResponses = resolveConfigProperty({
      config,
      context: { ...context,
        creationContext
      },
      initialValue: initialTemplatesResponses,
      propertyName: 'document.resolveNewDocumentOptions',
      reducer: newDocumentOptionsResolver
    });
    const templateErrors = []; // TODO: validate template responses
    // ensure there is a matching template per each one

    if (templateErrors.length) {
      throw new ConfigResolutionError({
        name: config.name,
        // TODO: figure out this name
        type: 'source',
        causes: templateErrors
      });
    }

    return templateResponses // take the template responses and transform them into the formal
    // `InitialValueTemplateItem`
    .map((response, index) => {
      const template = templateMap.get(response.templateId);

      if (!template) {
        throw new Error("Could not find template with ID `".concat(response.templateId, "`"));
      }

      const schemaType = schema.get(template.schemaType);

      if (!schemaType) {
        throw new Error("Could not find matching schema type `".concat(template.schemaType, "` for template `").concat(template.id, "`"));
      }

      const title = response.title || template.title; // Don't show the type name as subtitle if it's the same as the template name

      const defaultSubtitle = (schemaType === null || schemaType === void 0 ? void 0 : schemaType.title) === title ? undefined : schemaType === null || schemaType === void 0 ? void 0 : schemaType.title;
      return {
        id: "".concat(response.templateId, "-").concat(index),
        templateId: response.templateId,
        type: 'initialValueTemplateItem',
        title,
        subtitle: response.subtitle || defaultSubtitle,
        description: response.description || template.description,
        icon: response.icon || template.icon || (schemaType === null || schemaType === void 0 ? void 0 : schemaType.icon),
        initialDocumentId: response.initialDocumentId,
        parameters: response.parameters,
        schemaType: template.schemaType
      };
    }).filter(item => {
      var _templateMap$get;

      // if we are in a creationContext where there is no schema type,
      // then keep everything
      if (!schemaTypeName) return true; // else only keep the `schemaType`s that match the creationContext

      return schemaTypeName === ((_templateMap$get = templateMap.get(item.templateId)) === null || _templateMap$get === void 0 ? void 0 : _templateMap$get.schemaType);
    });
  };

  let staticInitialValueTemplateItems;

  try {
    staticInitialValueTemplateItems = resolveNewDocumentOptions({
      type: 'global'
    });
  } catch (e) {
    errors.push(e);
  }

  if (errors.length) {
    throw new ConfigResolutionError({
      name: config.name,
      type: 'source',
      causes: errors
    });
  }

  const source = {
    type: 'source',
    name: config.name,
    title: config.title || _startCase(config.name),
    schema,
    client,
    dataset,
    projectId,
    tools,
    currentUser,
    authenticated,
    templates,
    auth,
    document: {
      actions: partialContext => resolveConfigProperty({
        config,
        context: { ...context,
          ...partialContext
        },
        initialValue: initialDocumentActions,
        propertyName: 'document.actions',
        reducer: documentActionsReducer
      }),
      badges: partialContext => resolveConfigProperty({
        config,
        context: { ...context,
          ...partialContext
        },
        initialValue: initialDocumentBadges,
        propertyName: 'document.badges',
        reducer: documentBadgesReducer
      }),
      resolveProductionUrl: partialContext => resolveConfigProperty({
        config,
        context: { ...context,
          ...partialContext
        },
        initialValue: undefined,
        propertyName: 'resolveProductionUrl',
        asyncReducer: resolveProductionUrlReducer
      }),
      resolveNewDocumentOptions,
      unstable_languageFilter: partialContext => resolveConfigProperty({
        config,
        context: { ...context,
          ...partialContext
        },
        initialValue: initialLanguageFilter,
        propertyName: 'document.unstable_languageFilter',
        reducer: _documentLanguageFilterReducer
      })
    },
    form: {
      renderField: _createRenderField(config),
      renderInput: _createRenderInput(config),
      renderItem: _createRenderItem(config),
      renderPreview: _createRenderPreview(config),
      file: {
        assetSources: resolveConfigProperty({
          config,
          context,
          initialValue: defaultFileAssetSources,
          propertyName: 'formBuilder.file.assetSources',
          reducer: fileAssetSourceResolver
        }),
        directUploads: // TODO: consider refactoring this to `noDirectUploads` or similar
        // default value for this is `true`
        ((_config$form = config.form) === null || _config$form === void 0 ? void 0 : (_config$form$file = _config$form.file) === null || _config$form$file === void 0 ? void 0 : _config$form$file.directUploads) === undefined ? true : config.form.file.directUploads
      },
      image: {
        assetSources: resolveConfigProperty({
          config,
          context,
          initialValue: defaultImageAssetSources,
          propertyName: 'formBuilder.image.assetSources',
          reducer: imageAssetSourceResolver
        }),
        directUploads: // TODO: consider refactoring this to `noDirectUploads` or similar
        // default value for this is `true`
        ((_config$form2 = config.form) === null || _config$form2 === void 0 ? void 0 : (_config$form2$file = _config$form2.file) === null || _config$form2$file === void 0 ? void 0 : _config$form2$file.directUploads) === undefined ? true : config.form.file.directUploads
      }
    },
    __internal: {
      bifur,
      staticInitialValueTemplateItems
    }
  };
  return source;
}