import React, { useCallback, useMemo, useRef } from 'react';
import { PatchEvent } from '../../patch';
import { useDidUpdate } from '../../hooks/useDidUpdate';
import { useFormCallbacks } from '../../studio/contexts/FormCallbacks';
/**
 * Responsible for creating inputProps and fieldProps to pass to ´renderInput´ and ´renderField´ for a primitive field/input
 * @param props - Component props
 */

export function PrimitiveField(props) {
  const {
    member,
    renderInput,
    renderField
  } = props;
  const focusRef = useRef();
  const {
    onPathBlur,
    onPathFocus,
    onChange
  } = useFormCallbacks();
  useDidUpdate(member.field.focused, (hadFocus, hasFocus) => {
    if (!hadFocus && hasFocus) {
      var _focusRef$current;

      (_focusRef$current = focusRef.current) === null || _focusRef$current === void 0 ? void 0 : _focusRef$current.focus();
    }
  });
  const handleBlur = useCallback(event => {
    onPathBlur(member.field.path);
  }, [member.field.path, onPathBlur]);
  const handleFocus = useCallback(event => {
    onPathFocus(member.field.path);
  }, [member.field.path, onPathFocus]);
  const handleChange = useCallback(event => {
    onChange(PatchEvent.from(event).prefixAll(member.name));
  }, [onChange, member.name]);
  const validationError = useMemo(() => member.field.validation.filter(item => item.level === 'error').map(item => item.message).join('\n'), [member.field.validation]) || undefined;
  const inputProps = useMemo(() => {
    return {
      onBlur: handleBlur,
      value: member.field.value,
      readOnly: member.field.readOnly,
      schemaType: member.field.schemaType,
      changed: member.field.changed,
      focusRef: focusRef,
      id: member.field.id,
      onFocus: handleFocus,
      path: member.field.path,
      focused: member.field.focused,
      level: member.field.level,
      onChange: handleChange,
      validation: member.field.validation,
      presence: member.field.presence,
      validationError
    };
  }, [handleBlur, member.field.value, member.field.readOnly, member.field.schemaType, member.field.id, member.field.path, member.field.focused, member.field.level, member.field.validation, member.field.presence, member.field.changed, handleFocus, handleChange, validationError]);
  const renderedInput = useMemo(() => renderInput(inputProps), [inputProps, renderInput]);
  const fieldProps = useMemo(() => {
    return {
      name: member.name,
      index: member.index,
      level: member.field.level,
      value: member.field.value,
      schemaType: member.field.schemaType,
      title: member.field.schemaType.title,
      description: member.field.schemaType.description,
      inputId: member.field.id,
      path: member.field.path,
      validation: member.field.validation,
      presence: member.field.presence,
      children: renderedInput,
      changed: member.field.changed
    };
  }, [member.name, member.index, member.field.level, member.field.value, member.field.schemaType, member.field.id, member.field.path, member.field.validation, member.field.presence, member.field.changed, renderedInput]);
  return /*#__PURE__*/React.createElement(React.Fragment, null, renderField(fieldProps));
}