function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

/* eslint-disable camelcase */
import { act, waitForElementToBeRemoved, within } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import React from 'react';
import { of } from 'rxjs';
import { renderCrossDatasetReferenceInput } from '../../../../../test/form';
import { CrossDatasetReferenceInput } from '../CrossDatasetReferenceInput';
const AVAILABLE = {
  available: true,
  reason: 'READABLE'
};
describe('render states', () => {
  test('it renders the autocomplete when no value is given', async () => {
    const getReferenceInfo = _ref => {
      let {
        _id: id,
        _type: type
      } = _ref;
      return of({
        id,
        type,
        availability: AVAILABLE,
        preview: {
          published: {
            title: "Product ".concat(id)
          }
        }
      });
    };

    const {
      result
    } = await renderCrossDatasetReferenceInput({
      fieldDefinition: {
        name: 'productReference',
        type: 'crossDatasetReference',
        dataset: 'products',
        projectId: 'abcxyz',
        to: [{
          type: 'product',
          __experimental_search: [{
            path: 'title'
          }],
          preview: {}
        }]
      },
      getReferenceInfo,
      render: inputProps => {
        return /*#__PURE__*/React.createElement(CrossDatasetReferenceInput, inputProps);
      }
    });
    expect(result.queryByTestId('autocomplete')).toBeInTheDocument();
  });
  test('it renders the autocomplete when it has a value but focus is on the _ref', async () => {
    const getReferenceInfo = jest.fn().mockReturnValue(of({
      _id: 'foo',
      type: 'product',
      availability: AVAILABLE,
      preview: {
        published: {
          title: "Foo"
        }
      }
    }));
    const value = {
      _type: 'productReference',
      _ref: 'foo',
      _dataset: 'foo',
      _projectId: 'foo'
    };
    const {
      result
    } = await renderCrossDatasetReferenceInput({
      fieldDefinition: {
        name: 'productReference',
        type: 'crossDatasetReference',
        dataset: 'products',
        projectId: 'abcxyz',
        to: [{
          type: 'product',
          preview: {},
          __experimental_search: [{
            path: 'title'
          }]
        }]
      },
      getReferenceInfo,
      render: inputProps => {
        return /*#__PURE__*/React.createElement(CrossDatasetReferenceInput, _extends({}, inputProps, {
          focusPath: ['_ref'],
          value: value
        }));
      }
    });
    expect(result.getByTestId('autocomplete')).toBeInTheDocument();
  });
  test.skip('a warning is displayed if the reference value is strong while the schema says it should be weak', async () => {
    const getReferenceInfo = jest.fn().mockReturnValue(of({
      _id: 'foo',
      type: 'product',
      availability: AVAILABLE,
      preview: {
        published: {
          title: "Foo"
        }
      }
    }));
    const value = {
      _type: 'reference',
      _ref: 'someActor',
      _dataset: 'otherDataset',
      _projectId: 'otherProject'
    };
    const {
      result
    } = await renderCrossDatasetReferenceInput({
      fieldDefinition: {
        name: 'productReference',
        type: 'crossDatasetReference',
        dataset: 'products',
        projectId: 'abcxyz',
        weak: true,
        to: [{
          type: 'product',
          __experimental_search: [{
            path: 'title'
          }],
          preview: {}
        }]
      },
      getReferenceInfo,
      render: inputProps => {
        return /*#__PURE__*/React.createElement(CrossDatasetReferenceInput, _extends({}, inputProps, {
          focusPath: ['_ref'],
          value: value
        }));
      }
    });
    expect(result.getByTestId('alert-reference-strength-mismatch')).toBeInTheDocument();
  });
});
describe('user interaction happy paths', () => {
  test.skip('an input without a value support searching for references and emits patches when a reference is chosen', async () => {
    const handleSearch = jest.fn().mockReturnValue(of([{
      id: 'one',
      type: 'product',
      published: {
        _id: 'one',
        _type: 'product'
      }
    }, {
      id: 'two',
      type: 'product',
      published: {
        _id: 'two',
        _type: 'product'
      }
    }]));

    const getReferenceInfo = _ref2 => {
      let {
        _id: id,
        _type: type
      } = _ref2;
      return of({
        id,
        type,
        availability: AVAILABLE,
        preview: {
          published: {
            title: "Product ".concat(id)
          }
        }
      });
    };

    const {
      onChange,
      result
    } = await renderCrossDatasetReferenceInput({
      getReferenceInfo,
      onSearch: handleSearch,
      fieldDefinition: {
        name: 'productReference',
        type: 'crossDatasetReference',
        dataset: 'products',
        projectId: 'abcxyz',
        to: [{
          type: 'product',
          __experimental_search: [{
            path: 'title'
          }],
          preview: {}
        }]
      },
      render: inputProps => /*#__PURE__*/React.createElement(CrossDatasetReferenceInput, inputProps)
    });
    const autocomplete = await result.findByTestId('autocomplete');
    act(() => userEvent.type(autocomplete, 'foo'));
    const popover = await result.findByTestId('autocomplete-popover');
    const previews = within(popover).getAllByTestId('preview');
    expect(previews.length).toBe(2);
    expect(previews[0]).toHaveTextContent('Product one');
    expect(previews[1]).toHaveTextContent('Product two'); // Click "Product two"

    userEvent.click(within(popover).getAllByRole('button')[1]); // Note: this asserts the necessity of awaiting after click. Currently, the onChange event is
    // emitted asynchronously after an item is selected due to behavior in Sanity UI's autocomplete
    // (https://github.com/sanity-io/design/blob/b956686c2c663c4f21910f7d3d0be0a27663f5f4/packages/%40sanity/ui/src/components/autocomplete/autocompleteOption.tsx#L16-L20)
    // if this tests suddenly fails this expectation, it can be removed along with the waiting

    expect(onChange).toHaveBeenCalledTimes(0);
    await waitForElementToBeRemoved(() => result.getByTestId('autocomplete-popover')); //----

    expect(onChange).toHaveBeenCalledTimes(1);
    expect(onChange.mock.calls[0]).toEqual([{
      patches: [{
        path: [],
        type: 'set',
        value: {
          _dataset: 'products',
          _projectId: 'abcxyz',
          _ref: 'two',
          _type: 'productReference'
        }
      }]
    }]);
  }); // todo: look into why these fails

  test.skip('an input with an existing value support replacing the value, and emits patches when a new reference is chosen', async () => {
    const handleSearch = jest.fn().mockReturnValue(of([{
      id: 'one',
      type: 'product',
      published: {
        _id: 'one',
        _type: 'product'
      }
    }, {
      id: 'two',
      type: 'product',
      published: {
        _id: 'two',
        _type: 'product'
      }
    }]));

    const getReferenceInfo = _ref3 => {
      let {
        _id: id
      } = _ref3;
      return of({
        id,
        type: 'product',
        availability: AVAILABLE,
        preview: {
          published: {
            title: "Product ".concat(id)
          }
        }
      });
    };

    const value = {
      _type: 'productReference',
      _ref: 'some-product',
      _dataset: 'products',
      _projectId: 'abcxyz'
    };
    const {
      onChange,
      onPathFocus,
      rerender,
      result
    } = await renderCrossDatasetReferenceInput({
      getReferenceInfo,
      onSearch: handleSearch,
      fieldDefinition: {
        name: 'productReference',
        type: 'crossDatasetReference',
        dataset: 'products',
        projectId: 'abcxyz',
        to: [{
          type: 'product',
          __experimental_search: [{
            path: 'title'
          }],
          preview: {}
        }]
      },
      render: inputProps => /*#__PURE__*/React.createElement(CrossDatasetReferenceInput, _extends({}, inputProps, {
        value: value
      }))
    });
    const preview = result.getByTestId('preview');
    expect(preview).toHaveTextContent('Product some-product');
    const menuButton = result.getByTestId('menu-button');
    menuButton.click();
    const replaceMenuItem = result.getByTestId('menu-item-replace');
    replaceMenuItem.click();
    expect(onPathFocus).toHaveBeenCalledTimes(1);
    expect(onPathFocus).toHaveBeenCalledWith(['_ref']);
    rerender(inputProps => /*#__PURE__*/React.createElement(CrossDatasetReferenceInput, _extends({}, inputProps, {
      focusPath: ['_ref']
    }))); // rerender({
    //   focusPath: ['_ref'],
    // })

    const autocomplete = result.getByTestId('autocomplete');
    userEvent.type(autocomplete, 'foo');
    const popover = result.getByTestId('autocomplete-popover');
    const previews = within(popover).getAllByTestId('preview');
    expect(previews.length).toBe(2);
    expect(previews[0]).toHaveTextContent('Product one');
    expect(previews[1]).toHaveTextContent('Product two');
    userEvent.click(within(popover).getAllByRole('button')[1]); // Note: this asserts the necessity of awaiting after click. Currently, the onChange event is emitted asynchronously after an item is selected due to behavior in Sanity UI's autocomplete
    // (https://github.com/sanity-io/design/blob/b956686c2c663c4f21910f7d3d0be0a27663f5f4/packages/%40sanity/ui/src/components/autocomplete/autocompleteOption.tsx#L16-L20)
    // if this tests suddenly fails this expectation, it can be removed along with the waiting

    expect(onChange).toHaveBeenCalledTimes(0); // await wait(1)

    await waitForElementToBeRemoved(() => result.getByTestId('autocomplete-popover')); //----

    expect(onChange).toHaveBeenCalledTimes(1);
    expect(onChange.mock.calls[0]).toEqual([{
      patches: [{
        path: [],
        type: 'set',
        value: {
          _dataset: 'products',
          _projectId: 'abcxyz',
          _ref: 'two',
          _type: 'productReference'
        }
      }]
    }]);
  });
  test('an input with an existing value support clearing the value', async () => {
    const getReferenceInfo = _ref4 => {
      let {
        _id: id
      } = _ref4;
      return of({
        id,
        type: 'product',
        availability: AVAILABLE,
        preview: {
          published: {
            title: "Product ".concat(id)
          }
        }
      });
    };

    const value = {
      _type: 'productReference',
      _ref: 'some-product',
      _dataset: 'products',
      _projectId: 'abcxyz'
    };
    const {
      onChange,
      result
    } = await renderCrossDatasetReferenceInput({
      getReferenceInfo,
      fieldDefinition: {
        name: 'productReference',
        type: 'crossDatasetReference',
        dataset: 'products',
        projectId: 'abcxyz',
        to: [{
          type: 'product',
          __experimental_search: [{
            path: 'title'
          }],
          preview: {}
        }]
      },
      render: inputProps => /*#__PURE__*/React.createElement(CrossDatasetReferenceInput, _extends({}, inputProps, {
        value: value
      }))
    });
    const preview = result.getByTestId('preview');
    expect(preview).toHaveTextContent('Product some-product');
    const menuButton = result.getByTestId('menu-button');
    menuButton.click();
    const replaceMenuItem = result.getByTestId('menu-item-clear');
    replaceMenuItem.click();
    expect(onChange).toHaveBeenCalledTimes(1);
    expect(onChange.mock.calls[0]).toEqual([{
      path: [],
      type: 'unset'
    }]);
  });
});