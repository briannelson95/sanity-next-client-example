import { useCallback, useMemo } from 'react';
import { catchError, concatMap, map, startWith } from 'rxjs/operators';
import { concat, of, Subject } from 'rxjs';
import { useObservable } from 'react-rx';
import { usePrevious } from '../../hooks/usePrevious';

const noop = () => undefined;

const INITIAL_LOADING_STATE = {
  isLoading: true,
  result: undefined,
  error: undefined,
  retry: noop
};
const EMPTY_STATE = {
  isLoading: false,
  result: undefined,
  error: undefined,
  retry: noop
};
export function useReferenceInfo(id, getReferenceInfo) {
  // NOTE: this is a small message queue to handle retries
  const msgSubject = useMemo(() => new Subject(), []);
  const msg$ = useMemo(() => msgSubject.asObservable(), [msgSubject]);
  const retry = useCallback(() => {
    msgSubject.next({
      type: 'retry'
    });
  }, [msgSubject]);
  const stream$ = useMemo(() => concat(of(null), msg$).pipe(map(() => id), concatMap(refId => refId ? getReferenceInfo(refId).pipe(map(result => {
    return {
      isLoading: false,
      result,
      error: undefined,
      retry
    };
  }), startWith(INITIAL_LOADING_STATE), catchError(err => {
    console.error(err);
    return of({
      isLoading: false,
      result: undefined,
      error: err,
      retry
    });
  })) : of(EMPTY_STATE))), [getReferenceInfo, id, retry, msg$]);
  const referenceInfo = useObservable(stream$, INITIAL_LOADING_STATE); // const referenceInfo = useMemoObservable(
  //   () => stream$,
  //   [retryAttempt, getReferenceInfo, id, retry],
  //   INITIAL_LOADING_STATE
  // )
  // workaround for a "bug" with useMemoObservable that doesn't
  // return the initial value upon resubscription

  const previousId = usePrevious(id, id);

  if (previousId !== id) {
    return INITIAL_LOADING_STATE;
  }

  return referenceInfo;
}