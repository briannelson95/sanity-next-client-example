var _templateObject;

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

import { PortableTextEditor, usePortableTextEditor } from '@sanity/portable-text-editor';
import React, { useCallback, useMemo } from 'react';
import styled from 'styled-components';
import { createInsertCallback, createSetCallback, createUnsetCallback } from './callbacks';
const Root = styled.div(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n  display: flex;\n  pointer-events: 'all';\n"]))); // function isClassComponent(component: React.ComponentType) {
//   return typeof component === 'function' && !!component.prototype?.isReactComponent
// }
// function isFunctionComponent(component: React.ComponentType) {
//   return typeof component === 'function' && String(component).includes('return React.createElement')
// }

export function BlockActions(props) {
  const editor = usePortableTextEditor();
  const {
    block,
    onChange,
    renderBlockActions
  } = props;
  const decoratorValues = useMemo(() => PortableTextEditor.getPortableTextFeatures(editor).decorators.map(d => d.value), [editor]);
  const blockActions = useMemo(() => {
    if (renderBlockActions) {
      const blockActionProps = {
        block,
        value: PortableTextEditor.getValue(editor),
        set: createSetCallback({
          allowedDecorators: decoratorValues,
          block,
          onChange
        }),
        unset: createUnsetCallback({
          block,
          onChange
        }),
        insert: createInsertCallback({
          allowedDecorators: decoratorValues,
          block,
          onChange
        })
      }; // // Support returning a class component for renderBlockActions (to keep backward compatability as it was possible before)
      // if (isClassComponent(renderBlockActions) || isFunctionComponent(renderBlockActions)) {
      //   const RenderComponent = renderBlockActions
      //   return <RenderComponent {...blockActionProps} />
      // }

      return renderBlockActions(blockActionProps);
    }

    return undefined;
  }, [renderBlockActions, block, editor, onChange, decoratorValues]); // Take focus away from the editor so dealing with block actions doesn't interfere with the editor focus

  const handleClick = useCallback(() => {
    PortableTextEditor.blur(editor);
  }, [editor]); // Don't render anything if the renderBlockActions function returns null.
  // Note that if renderBlockComponent is a React class, this will never be the case.

  if (!blockActions) return null;
  return /*#__PURE__*/React.createElement(Root, {
    contentEditable: false,
    onKeyDown: handleClick,
    onMouseDown: handleClick
  }, blockActions);
}