"use strict";

var _assert = _interopRequireDefault(require("assert"));

var _matchWorkspace = require("../matchWorkspace");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

describe('matchWorkspace', () => {
  it('returns a match if the incoming `pathname` matches a workspace `basePath`', () => {
    const foo = {
      name: 'foo',
      basePath: '/common/foo'
    };
    const bar = {
      name: 'bar',
      basePath: '/common/bar'
    };
    const baz = {
      name: 'baz',
      basePath: '/common/baz'
    };
    const result = (0, _matchWorkspace.matchWorkspace)({
      workspaces: [foo, bar, baz],
      pathname: '/common/bar'
    });
    (0, _assert.default)(result.type === 'match');
    expect(result.workspace).toBe(bar);
  });
  it('results in a redirect to the first workspace if the incoming pathname is exactly `/`', () => {
    const commonBasePath = "/x/common";
    const foo = {
      name: 'foo',
      basePath: "".concat(commonBasePath, "/foo")
    };
    const bar = {
      name: 'bar',
      basePath: "".concat(commonBasePath, "/bar")
    };
    const resultOne = (0, _matchWorkspace.matchWorkspace)({
      workspaces: [foo, bar],
      pathname: '/'
    });
    (0, _assert.default)(resultOne.type === 'redirect');
    expect(resultOne.pathname).toBe(foo.basePath); // the first workspace in the array
  });
  it('results in a redirect to the first workspace if the incoming `pathname` partially matches the common base path', () => {
    const commonBasePath = "/x/common";
    const foo = {
      name: 'foo',
      basePath: "".concat(commonBasePath, "/foo")
    };
    const bar = {
      name: 'bar',
      basePath: "".concat(commonBasePath, "/bar")
    };
    const baz = {
      name: 'baz',
      basePath: "".concat(commonBasePath, "/baz")
    };
    const resultOne = (0, _matchWorkspace.matchWorkspace)({
      workspaces: [foo, bar, baz],
      // this partially matches the common base path so it'll result in a redirect
      pathname: '/x'
    });
    (0, _assert.default)(resultOne.type === 'redirect');
    expect(resultOne.pathname).toBe(foo.basePath); // the first workspace in the array
    // try it again but with more of the common base path

    const resultTwo = (0, _matchWorkspace.matchWorkspace)({
      workspaces: [foo, bar, baz],
      pathname: '/x/common'
    });
    (0, _assert.default)(resultTwo.type === 'redirect');
    expect(resultTwo.pathname).toBe(foo.basePath);
  });
  it('results in not-found match if the incoming `pathname` is only a substring of the workspace (edge case)', () => {
    const foo = {
      name: 'foo',
      basePath: '/common/foo'
    };
    const bar = {
      name: 'bar',
      basePath: '/common/bar'
    };
    const baz = {
      name: 'baz',
      basePath: '/common/baz'
    };
    const result = (0, _matchWorkspace.matchWorkspace)({
      workspaces: [foo, bar, baz],
      // this should not match anything
      pathname: '/common/ba'
    });
    expect(result.type).toBe('not-found');
  });
});