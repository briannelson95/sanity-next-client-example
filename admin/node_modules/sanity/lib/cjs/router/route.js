"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.route = void 0;

var _parseRoute = require("./parseRoute");

var _resolveStateFromPath = require("./resolveStateFromPath");

var _resolvePathFromState = require("./resolvePathFromState");

var _jsonParamsEncoding = require("./utils/jsonParamsEncoding");

var _paramsEncoding = require("./utils/paramsEncoding");

function normalizeChildren(children) {
  if (Array.isArray(children) || typeof children === 'function') {
    return children;
  }

  return children ? [children] : [];
}

function isRoute(val) {
  return val && '_isRoute' in val;
}

function normalizeArgs(path, childrenOrOpts, children) {
  if (typeof path === 'object') {
    return path;
  }

  if (Array.isArray(childrenOrOpts) || typeof childrenOrOpts === 'function' || isRoute(childrenOrOpts)) {
    return {
      path,
      children: normalizeChildren(childrenOrOpts)
    };
  }

  if (children) {
    return {
      path,
      ...childrenOrOpts,
      children: normalizeChildren(children)
    };
  }

  return {
    path,
    ...childrenOrOpts
  };
}
/**
 * @public
 */


const route = {
  create: createRoute,
  scope: routeScope,
  intents: routeIntents
};
exports.route = route;

function createRoute(routeOrOpts, childrenOrOpts, children) {
  return createNode(normalizeArgs(routeOrOpts, childrenOrOpts, children));
}

function routeScope(scopeName) {
  for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    rest[_key - 1] = arguments[_key];
  }

  const options = normalizeArgs(...rest);
  return createNode({ ...options,
    scope: scopeName
  });
}

function normalize() {
  for (var _len2 = arguments.length, paths = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    paths[_key2] = arguments[_key2];
  }

  return paths.reduce((acc, path) => acc.concat(path.split('/')), []).filter(Boolean);
}

function routeIntents(base) {
  const basePath = normalize(base).join('/');
  return route.create("".concat(basePath, "/:intent"), [route.create(':params', {
    transform: {
      params: {
        toState: _paramsEncoding.decodeParams,
        toPath: _paramsEncoding.encodeParams
      }
    }
  }, [route.create(':payload', {
    transform: {
      payload: {
        toState: _jsonParamsEncoding.decodeJsonParams,
        toPath: _jsonParamsEncoding.encodeJsonParams
      }
    }
  })])]);
}

const EMPTY_STATE = {};

function isRoot(pathname) {
  // it is the root if every segment is an empty string
  return pathname.split('/').every(segment => !segment);
}

function createNode(options) {
  const {
    path,
    scope,
    transform,
    children
  } = options;

  if (!path) {
    throw new TypeError('Missing path');
  }

  const parsedRoute = (0, _parseRoute.parseRoute)(path);
  return {
    _isRoute: true,
    // todo: make a Router class instead
    scope,
    route: parsedRoute,
    children: children || [],
    transform,

    encode(state) {
      return (0, _resolvePathFromState.resolvePathFromState)(this, state);
    },

    decode(_path) {
      return (0, _resolveStateFromPath.resolveStateFromPath)(this, _path);
    },

    isRoot: isRoot,

    isNotFound(pathname) {
      return this.decode(pathname) === null;
    },

    getBasePath() {
      return this.encode(EMPTY_STATE);
    },

    getRedirectBase(pathname) {
      if (isRoot(pathname)) {
        const basePath = this.getBasePath(); // Check if basepath is something different than given

        if (pathname !== basePath) {
          return basePath;
        }
      }

      return null;
    }

  };
}