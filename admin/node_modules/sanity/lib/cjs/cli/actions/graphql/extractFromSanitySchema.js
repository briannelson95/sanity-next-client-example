"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractFromSanitySchema = extractFromSanitySchema;

var _startCase2 = _interopRequireDefault(require("lodash/startCase"));

var _uniqBy2 = _interopRequireDefault(require("lodash/uniqBy"));

var _generateHelpUrl = require("@sanity/generate-help-url");

var _schema = _interopRequireDefault(require("@sanity/schema"));

var _oneline = _interopRequireDefault(require("oneline"));

var helpUrls = _interopRequireWildcard(require("./helpUrls"));

var _SchemaError = require("./SchemaError");

var _templateObject, _templateObject2;

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

const skipTypes = ['document', 'reference', 'crossDatasetReference'];
const allowedJsonTypes = ['object', 'array'];
const disallowedCustomizedMembers = ['object', 'array', 'image', 'file', 'block'];
const disabledBlockFields = ['markDefs'];
const scalars = ['string', 'number', 'boolean'];

function getBaseType(baseSchema, typeName) {
  var _baseSchema$_original;

  return _schema.default.compile({
    types: (((_baseSchema$_original = baseSchema._original) === null || _baseSchema$_original === void 0 ? void 0 : _baseSchema$_original.types) || []).concat([{
      name: "__placeholder__",
      type: typeName,
      options: {
        hotspot: true
      }
    }])
  }).get('__placeholder__');
}

function getTypeName(str) {
  const name = (0, _startCase2.default)(str).replace(/\s+/g, '');
  return name === 'Number' ? 'Float' : name;
}

function isBaseType(type) {
  return type.name !== type.jsonType && allowedJsonTypes.includes(type.jsonType) && !skipTypes.includes(type.name) && !isReference(type) && !isCrossDatasetReference(type);
}

function isBlockType(typeDef) {
  if (typeDef.name === 'block') {
    return true;
  }

  if (typeDef.type) {
    return isBlockType(typeDef.type);
  }

  return false;
}

function hasBlockParent(typeDef) {
  if (typeDef.type && typeDef.type.name === 'block' && !typeDef.type.type) {
    return true;
  }

  return Boolean(typeDef.type && hasBlockParent(typeDef.type));
}

function isArrayOfBlocks(typeDef) {
  const type = typeDef.type || typeDef;

  if (!('jsonType' in type) || type.jsonType !== 'array') {
    return false;
  }

  return (type.of || []).some(hasBlockParent);
}

function isType(typeDef, typeName) {
  let type = typeDef;

  while (type) {
    if (type.name === typeName || type.type && type.type.name === typeName) {
      return true;
    }

    type = type.type;
  }

  return false;
}

function isReference(typeDef) {
  return isType(typeDef, 'reference');
}

function isCrossDatasetReference(typeDef) {
  return isType(typeDef, 'crossDatasetReference');
}

function extractFromSanitySchema(sanitySchema) {
  var _sanitySchema$_origin;

  let extractOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const {
    nonNullDocumentFields
  } = extractOptions;
  const unionRecursionGuards = [];

  const hasErrors = sanitySchema._validation && sanitySchema._validation.some(group => group.problems.some(problem => problem.severity === 'error'));

  if (hasErrors && Array.isArray(sanitySchema._validation)) {
    throw new _SchemaError.SchemaError(sanitySchema._validation);
  }

  const sanityTypes = ((_sanitySchema$_origin = sanitySchema._original) === null || _sanitySchema$_origin === void 0 ? void 0 : _sanitySchema$_origin.types) || [];
  const typeNames = sanitySchema.getTypeNames();
  const unionTypes = [];
  const types = typeNames.map(name => sanitySchema.get(name)).filter(schemaType => Boolean(schemaType)).filter(isBaseType).map(type => convertType(type));
  const withUnions = [...types, ...unionTypes];
  return {
    types: withUnions,
    interfaces: [getDocumentInterfaceDefinition()]
  };

  function isTopLevelType(typeName) {
    return typeNames.includes(typeName);
  }

  function mapFieldType(field) {
    if (!field.type) {
      throw new Error('Field has no type!');
    }

    const jsonType = 'jsonType' in field ? field.jsonType : '';
    const isScalar = scalars.includes(jsonType);

    if (isScalar && jsonType === 'number') {
      return hasValidationFlag(field, 'integer') ? 'Int' : 'Float';
    } else if (isScalar) {
      return getTypeName(jsonType);
    }

    const type = field.type.type || field.type; // In the case of nested scalars, recurse (markdown -> longText -> text -> string)

    if (type.type) {
      return mapFieldType(type);
    }

    switch (type.name) {
      case 'number':
        return hasValidationFlag(field, 'integer') ? 'Int' : 'Float';

      default:
        return getTypeName(type.name);
    }
  }

  function isArrayType(type) {
    return Boolean('jsonType' in type && type.jsonType === 'array' || type.type && type.type.jsonType === 'array');
  }

  function _convertType(type, parent, options) {
    let name;

    if (type.type) {
      name = type.type.name;
    } else if ('jsonType' in type) {
      name = type.jsonType;
    }

    if (isReference(type)) {
      return getReferenceDefinition(type, parent);
    }

    if (isArrayType(type)) {
      return getArrayDefinition(type, parent, options);
    }

    if (name === 'document') {
      return getDocumentDefinition(type);
    }

    if (name === 'block' || name === 'object') {
      return getObjectDefinition(type, parent);
    }

    if (hasFields(type)) {
      return getObjectDefinition(type, parent);
    }

    return {
      type: mapFieldType(type),
      description: getDescription(type)
    };
  }

  function convertType(type, parent) {
    let props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    const mapped = _convertType(type, parent || '', {
      isField: Boolean(props.fieldName)
    });

    const gqlName = props.fieldName || mapped.name;
    const originalName = type.name;
    const original = gqlName === originalName ? {} : {
      originalName: originalName
    };
    return { ...props,
      ...mapped,
      ...original
    };
  }

  function isField(def) {
    return !('jsonType' in def) || !def.jsonType;
  } // eslint-disable-next-line complexity


  function getObjectDefinition(def, parent) {
    const isInline = isField(def);
    const isDocument = def.type ? def.type.name === 'document' : false;
    const actualType = isInline ? def.type : def;

    if (typeNeedsHoisting(actualType)) {
      throw createLiftTypeError(def.name, parent || '', actualType.name);
    }

    if (isInline && parent && def.type.name === 'object') {
      throw createLiftTypeError(def.name, parent);
    }

    if (parent && def.type && isTopLevelType(def.type.name)) {
      return {
        type: getTypeName(def.type.name)
      };
    }

    const name = "".concat(parent || '').concat(getTypeName(def.name));
    const fields = collectFields(def);
    const firstUnprefixed = Math.max(0, fields.findIndex(field => field.name[0] !== '_'));
    const keyField = createStringField('_key');
    fields.splice(firstUnprefixed, 0, keyField);

    if (!isDocument) {
      fields.splice(firstUnprefixed + 1, 0, createStringField('_type'));
    }

    const objectIsBlock = isBlockType(def);
    const objectFields = objectIsBlock ? fields.filter(field => !disabledBlockFields.includes(field.name)) : fields;
    return {
      kind: 'Type',
      name,
      type: 'Object',
      description: getDescription(def),
      fields: objectFields.map(field => isArrayOfBlocks(field) ? buildRawField(field, name) : convertType(field, name, {
        fieldName: field.name
      }))
    };
  }

  function buildRawField(field, parentName) {
    return { ...convertType(field, parentName, {
        fieldName: "".concat(field.name, "Raw")
      }),
      type: 'JSON',
      isRawAlias: true
    };
  }

  function createStringField(name) {
    return {
      name,
      type: {
        jsonType: 'string',
        name: 'string',
        type: {
          name: 'string',
          type: undefined,
          jsonType: 'string'
        }
      }
    };
  }

  function collectFields(def) {
    const fields = gatherAllFields(def);

    if (fields.length > 0) {
      return fields;
    }

    const extended = getBaseType(sanitySchema, def.name);
    return gatherAllFields(extended);
  }

  function getReferenceDefinition(def, parent) {
    const base = {
      description: getDescription(def),
      isReference: true
    };
    const candidates = arrayify(gatherAllReferenceCandidates(def));

    if (candidates.length === 0) {
      throw new Error('No candidates for reference');
    }

    return candidates.length === 1 ? {
      type: getTypeName(candidates[0].type.name),
      ...base
    } : { ...getUnionDefinition(candidates, def, {
        grandParent: parent
      }),
      ...base
    };
  }

  function getArrayDefinition(def, parent) {
    var _def$type;

    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const base = {
      description: getDescription(def),
      kind: 'List'
    };
    const name = !options.isField && def.name ? {
      name: getTypeName(def.name)
    } : {};
    const candidates = (_def$type = def.type) !== null && _def$type !== void 0 && _def$type.type && 'of' in def.type ? arrayify(def.type.of) : def.of;
    return candidates.length === 1 ? {
      children: getArrayChildDefinition(candidates[0], def),
      ...base,
      ...name
    } : {
      children: getUnionDefinition(candidates, def, {
        grandParent: parent
      }),
      ...base,
      ...name
    };
  }

  function getArrayChildDefinition(child, arrayDef) {
    if (typeNeedsHoisting(child)) {
      // Seems to be inline? Should be hoisted?
      throw createLiftTypeError(child.name, arrayDef.name);
    }

    if (isReference(child)) {
      return getReferenceDefinition(child, arrayDef.name);
    } // In the case of nested scalars, recurse (markdown -> longText -> text -> string)


    if (scalars.includes(child.jsonType) && !scalars.includes(child.name)) {
      return {
        type: mapFieldType(child)
      };
    }

    return {
      type: getTypeName(child.name)
    };
  }

  function typeNeedsHoisting(type) {
    if (type.name === 'object') {
      return true;
    }

    if (type.jsonType === 'object' && !isTopLevelType(type.name)) {
      return true;
    }

    if (type.isCustomized && !isTopLevelType(type.name)) {
      return true;
    }

    if (type.isCustomized && disallowedCustomizedMembers.includes(type.name)) {
      return true;
    }

    return false;
  }

  function getUnionDefinition(candidates, parent) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    if (candidates.length < 2) {
      throw new Error('Not enough candidates for a union type');
    } // #1482: When creating union definition do not get caught in recursion loop
    // for types that reference themselves


    const guardPathName = "".concat(typeof parent === 'object' ? parent.name : parent);

    if (unionRecursionGuards.includes(guardPathName)) {
      return {};
    }

    try {
      unionRecursionGuards.push(guardPathName);
      candidates.forEach((def, i) => {
        if (typeNeedsHoisting(def)) {
          throw createLiftTypeArrayError(i, parent.name, def.type ? def.type.name : def.name, options.grandParent);
        }
      });
      const converted = candidates.map(def => convertType(def));

      const getName = def => typeof def.type === 'string' ? def.type : def.type.name; // We might end up with union types being returned - these needs to be flattened
      // so that an ImageOr(PersonOrPet) becomes ImageOrPersonOrPet


      const flattened = converted.reduce((acc, candidate) => {
        const union = unionTypes.find(item => item.name === candidate.type);
        return union ? acc.concat(union.types.map(type => ({
          type,
          isReference: candidate.isReference
        }))) : acc.concat(candidate);
      }, []);
      const allCandidatesAreDocuments = flattened.every(def => {
        const typeDef = sanityTypes.find(type => type.name === getName(def));
        return typeDef && typeDef.type === 'document';
      });
      const interfaces = allCandidatesAreDocuments ? ['Document'] : undefined;
      const refs = flattened.filter(type => type.isReference).map(ref => ref.type);
      const inlineObjs = flattened.filter(type => !type.isReference).map(type => type.name || ''); // Here we remove duplicates, as they might appear twice due to in-line usage of types as well as references

      const allTypeNames = flattened.map(type => {
        return type.isReference ? type.type : type.name;
      });
      const possibleTypes = [...new Set(allTypeNames)].sort();

      if (possibleTypes.length < 2) {
        throw new Error("Not enough types for a union type. Parent: ".concat(parent.name));
      }

      const name = possibleTypes.join('Or');

      if (!unionTypes.some(item => item.name === name)) {
        unionTypes.push({
          kind: 'Union',
          name,
          types: possibleTypes,
          interfaces
        });
      }

      const references = refs.length > 0 ? refs : undefined;
      const inlineObjects = inlineObjs.length > 0 ? inlineObjs : undefined;
      return isReference(parent) ? {
        type: name,
        references
      } : {
        type: name,
        references,
        inlineObjects
      };
    } finally {
      const parentIndex = unionRecursionGuards.indexOf(guardPathName);

      if (parentIndex !== -1) {
        unionRecursionGuards.splice(parentIndex, 1);
      }
    }
  }

  function getDocumentDefinition(def) {
    const objectDef = getObjectDefinition(def);
    const fields = getDocumentInterfaceFields().concat(objectDef.fields);
    return { ...objectDef,
      fields,
      interfaces: ['Document']
    };
  }

  function getDocumentInterfaceDefinition() {
    return {
      kind: 'Interface',
      name: 'Document',
      description: 'A Sanity document',
      fields: getDocumentInterfaceFields()
    };
  }

  function getDocumentInterfaceFields() {
    const isNullable = typeof nonNullDocumentFields === 'boolean' ? !nonNullDocumentFields : true;
    return [{
      fieldName: '_id',
      type: 'ID',
      isNullable,
      description: 'Document ID'
    }, {
      fieldName: '_type',
      type: 'String',
      isNullable,
      description: 'Document type'
    }, {
      fieldName: '_createdAt',
      type: 'Datetime',
      isNullable,
      description: 'Date the document was created'
    }, {
      fieldName: '_updatedAt',
      type: 'Datetime',
      isNullable,
      description: 'Date the document was last modified'
    }, {
      fieldName: '_rev',
      type: 'String',
      isNullable,
      description: 'Current document revision'
    }];
  }

  function arrayify(thing) {
    if (Array.isArray(thing)) {
      return thing;
    }

    return thing === null || typeof thing === 'undefined' ? [] : [thing];
  }

  function hasValidationFlag(field, flag) {
    return 'validation' in field && Array.isArray(field.validation) && field.validation.some(rule => rule && '_rules' in rule && rule._rules.some(item => item.flag === flag));
  }

  function getDescription(type) {
    const description = type.type && type.type.description;
    return typeof description === 'string' ? description : undefined;
  }

  function gatherAllReferenceCandidates(type) {
    const allFields = gatherReferenceCandidates(type);
    return (0, _uniqBy2.default)(allFields, 'name');
  }

  function gatherReferenceCandidates(type) {
    const refTo = 'to' in type ? type.to : [];
    return 'type' in type && type.type ? [...gatherReferenceCandidates(type.type), ...refTo] : refTo;
  }

  function gatherAllFields(type) {
    const allFields = gatherFields(type);
    return (0, _uniqBy2.default)(allFields, 'name');
  }

  function gatherFields(type) {
    if ('fields' in type) {
      return type.type ? gatherFields(type.type).concat(type.fields) : type.fields;
    }

    return [];
  }

  function hasFieldsLikeShape(type) {
    return typeof type === 'object' && type !== null && 'fields' in type;
  }

  function hasArrayOfFields(type) {
    return hasFieldsLikeShape(type) && Array.isArray(type.fields);
  }

  function hasFields(type) {
    if (hasArrayOfFields(type)) {
      return gatherAllFields(type).length > 0;
    }

    return 'type' in type && type.type ? hasFields(type.type) : false;
  }
}

function createLiftTypeArrayError(index, parent) {
  let inlineType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'object';
  let grandParent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
  const helpUrl = (0, _generateHelpUrl.generateHelpUrl)(helpUrls.SCHEMA_LIFT_ANONYMOUS_OBJECT_TYPE);
  const context = [grandParent, parent].filter(Boolean).join('/');
  return new HelpfulError((0, _oneline.default)(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n    Encountered anonymous inline ", " at index ", " for type/field ", ".\n    To use this type with GraphQL you will need to create a top-level schema type for it.\n    See ", ""])), inlineType, index, context, helpUrl), helpUrl);
}

function createLiftTypeError(typeName, parent) {
  let inlineType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'object';
  const helpUrl = (0, _generateHelpUrl.generateHelpUrl)(helpUrls.SCHEMA_LIFT_ANONYMOUS_OBJECT_TYPE);
  return new HelpfulError((0, _oneline.default)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["\n    Encountered anonymous inline ", " \"", "\" for field/type \"", "\".\n    To use this field with GraphQL you will need to create a top-level schema type for it.\n    See ", ""])), inlineType, typeName, parent, helpUrl), helpUrl);
}

class HelpfulError extends Error {
  constructor(message, helpUrl) {
    super(message);

    _defineProperty(this, "helpUrl", void 0);

    this.helpUrl = helpUrl;
  }

}