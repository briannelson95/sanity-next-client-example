/* eslint-disable no-undef, import/no-unresolved */
import React from 'react';
import { get } from 'lodash';
import { ImageIcon, SearchIcon } from '@sanity/icons';
import { Box, Button, Card, Menu, MenuButton, MenuItem, } from '@sanity/ui';
import { WithReferencedAsset } from '../../../utils/WithReferencedAsset';
import { FileTarget } from '../common/styles';
import { UploadProgress } from '../common/UploadProgress';
import { handleSelectAssetFromSource } from '../common/assetSource';
import { ActionsMenu } from '../common/ActionsMenu';
import { PlaceholderText } from '../common/PlaceholderText';
import { UploadPlaceholder } from '../common/UploadPlaceholder';
import { UploadWarning } from '../common/UploadWarning';
import { ImperativeToast } from '../../../../components/transitional';
import { PatchEvent, setIfMissing, unset } from '../../../patch';
import { MemberField, MemberFieldError, MemberFieldSet } from '../../../members';
import { ChangeIndicator } from '../../../../components/changeIndicators';
import { CardOverlay, FlexContainer } from './styles';
import { FileDetails } from './FileDetails';
import { FileSkeleton } from './FileSkeleton';
import { isFileSource } from '@sanity/asset-utils';
import { InvalidFileWarning } from './InvalidFileWarning';
function passThrough({ children }) {
    return children;
}
const ASSET_FIELD_PATH = ['asset'];
export class FileInput extends React.PureComponent {
    constructor(props) {
        super(props);
        this._focusRef = null;
        this.uploadSubscription = null;
        this.state = {
            isUploading: false,
            selectedAssetSource: null,
            hoveringFiles: [],
            isStale: false,
            isMenuOpen: false,
        };
        this.toast = null;
        this.handleRemoveButtonClick = () => {
            const { path, value } = this.props;
            const parentPathSegment = path.slice(-1)[0];
            // String path segment mean an object path, while a number or a
            // keyed segment means we're a direct child of an array
            const isArrayElement = typeof parentPathSegment !== 'string';
            // When removing the file, _type and _key are "meta"-properties and
            // are not significant unless other properties are present. Thus, we
            // want to remove the entire "container" object if these are the only
            // properties present, BUT only if we're not an array element, as
            // removing the array element will close the selection dialog. Instead,
            // when closing the dialog, the array logic will check for an "empty"
            // value and remove it for us
            const allKeys = Object.keys(value || {});
            const remainingKeys = allKeys.filter((key) => !['_type', '_key', '_upload', 'asset'].includes(key));
            const isEmpty = remainingKeys.length === 0;
            const removeKeys = ['asset']
                .concat(allKeys.filter((key) => ['_upload'].includes(key)))
                .map((key) => unset([key]));
            this.props.onChange(PatchEvent.from(isEmpty && !isArrayElement ? unset() : removeKeys));
        };
        this.handleCancelUpload = () => {
            this.cancelUpload();
        };
        this.handleClearUploadState = () => {
            this.setState({ isStale: false });
            this.clearUploadStatus();
        };
        this.handleStaleUpload = () => {
            this.setState({ isStale: true });
        };
        this.handleClearField = () => {
            this.props.onChange(unset(['asset']));
        };
        this.handleSelectFiles = (files) => {
            const { directUploads, readOnly } = this.props;
            const { hoveringFiles } = this.state;
            if (directUploads && !readOnly) {
                this.uploadFirstAccepted(files);
            }
            else if (hoveringFiles.length > 0) {
                this.handleFilesOut();
            }
        };
        this.handleSelectFileFromAssetSource = (source) => {
            this.setState({ selectedAssetSource: source });
        };
        this.handleAssetSourceClosed = () => {
            this.setState({ selectedAssetSource: null });
        };
        this.uploadWith = (uploader, file, assetDocumentProps = {}) => {
            const { schemaType, onChange, client } = this.props;
            const { source } = assetDocumentProps;
            const options = {
                metadata: get(schemaType, 'options.metadata'),
                storeOriginalFilename: get(schemaType, 'options.storeOriginalFilename'),
                source,
            };
            this.cancelUpload();
            this.setState({ isUploading: true });
            onChange(PatchEvent.from([setIfMissing({ _type: schemaType.name })]));
            this.uploadSubscription = uploader.upload(client, file, schemaType, options).subscribe({
                next: (uploadEvent) => {
                    if (uploadEvent.patches) {
                        onChange(PatchEvent.from(uploadEvent.patches));
                    }
                },
                error: (err) => {
                    // eslint-disable-next-line no-console
                    console.error(err);
                    this.toast?.push({
                        status: 'error',
                        description: 'The upload could not be completed at this time.',
                        title: 'Upload failed',
                    });
                    this.clearUploadStatus();
                },
                complete: () => {
                    this.setState({ isUploading: false });
                },
            });
        };
        this.handleSelectAssetFromSource = (assetFromSource) => {
            const { onChange, schemaType, resolveUploader } = this.props;
            handleSelectAssetFromSource({
                assetFromSource,
                onChange,
                type: schemaType,
                resolveUploader,
                uploadWith: this.uploadWith,
            });
            this.setState({ selectedAssetSource: null });
        };
        this.handleFileTargetFocus = (event) => {
            // We want to handle focus when the file target element *itself* receives
            // focus, not when an interactive child element receives focus. Since React has decided
            // to let focus bubble, so this workaround is needed
            // Background: https://github.com/facebook/react/issues/6410#issuecomment-671915381
            if (event.currentTarget === event.target && event.currentTarget === this._focusRef) {
                this.props.onFocusPath(['asset']);
            }
        };
        this.handleFilesOver = (fileInfo) => {
            this.setState({
                hoveringFiles: fileInfo,
            });
        };
        this.handleFilesOut = () => {
            this.setState({
                hoveringFiles: [],
            });
        };
        this.setFocusElement = (ref) => {
            this._focusRef = ref;
        };
        this.handleUpload = ({ file, uploader }) => {
            this.uploadWith(uploader, file);
        };
        this.setToast = (toast) => {
            this.toast = toast;
        };
        this._assetFieldPath = props.path.concat(ASSET_FIELD_PATH);
    }
    clearUploadStatus() {
        // todo: this is kind of hackish
        if (this.props.value?._upload) {
            this.props.onChange(PatchEvent.from([unset(['_upload'])]));
        }
    }
    cancelUpload() {
        if (this.uploadSubscription) {
            this.uploadSubscription.unsubscribe();
            this.clearUploadStatus();
        }
    }
    uploadFirstAccepted(files) {
        const { schemaType } = this.props;
        const match = files
            .map((file) => ({ file, uploader: this.props.resolveUploader?.(schemaType, file) }))
            .find((result) => result.uploader);
        if (match) {
            this.uploadWith(match.uploader, match.file);
        }
        this.setState({ isMenuOpen: false });
    }
    renderUploadState(uploadState) {
        const { isUploading } = this.state;
        return (React.createElement(UploadProgress, { uploadState: uploadState, onCancel: isUploading ? this.handleCancelUpload : undefined, onStale: this.handleStaleUpload }));
    }
    renderAssetSource() {
        const { selectedAssetSource } = this.state;
        const { value, observeAsset } = this.props;
        if (!selectedAssetSource) {
            return null;
        }
        const Component = selectedAssetSource.component;
        if (value && value.asset) {
            return (React.createElement(WithReferencedAsset, { observeAsset: observeAsset, reference: value.asset, waitPlaceholder: React.createElement(FileSkeleton, null) }, (fileAsset) => (React.createElement(Component, { selectedAssets: [fileAsset], selectionType: "single", assetType: "file", dialogHeaderTitle: "Select file", onClose: this.handleAssetSourceClosed, onSelect: this.handleSelectAssetFromSource }))));
        }
        return (React.createElement(Component, { selectedAssets: [], selectionType: "single", assetType: "file", dialogHeaderTitle: "Select file", onClose: this.handleAssetSourceClosed, onSelect: this.handleSelectAssetFromSource }));
    }
    hasFileTargetFocus() {
        return this.props.focusPath?.[0] === 'asset';
    }
    renderAsset() {
        const { value, onFocus, onBlur, changed, readOnly } = this.props;
        const { hoveringFiles, isStale } = this.state;
        const hasValueOrUpload = Boolean(value?._upload || value?.asset);
        if (value && typeof value.asset !== 'undefined' && !value?._upload && !isFileSource(value)) {
            return () => React.createElement(InvalidFileWarning, { onClearValue: this.handleClearField });
        }
        // todo: convert this to a functional component and use this with useCallback
        //  it currently has to return a new function on every render in order to pick up state from this component
        return (inputProps) => (React.createElement(React.Fragment, null,
            isStale && (React.createElement(Box, { marginBottom: 2 },
                React.createElement(UploadWarning, { onClearStale: this.handleClearUploadState }))),
            React.createElement(ChangeIndicator, { path: this._assetFieldPath, hasFocus: !!inputProps.focused, isChanged: changed },
                !value?._upload && (React.createElement(FileTarget, { tabIndex: 0, disabled: Boolean(readOnly), ref: this.setFocusElement, onFiles: this.handleSelectFiles, onFilesOver: this.handleFilesOver, onFilesOut: this.handleFilesOut, onFocus: onFocus, onBlur: onBlur, tone: this.getFileTone(), "$border": hasValueOrUpload || hoveringFiles.length > 0, style: { padding: 1 }, sizing: "border", radius: 2 },
                    React.createElement("div", { style: { position: 'relative' } },
                        !value?.asset && this.renderUploadPlaceholder(),
                        value?.asset && hoveringFiles.length > 0
                            ? this.renderAssetMenu(this.getFileTone())
                            : null,
                        !value?._upload && value?.asset && this.renderPreview()))),
                value?._upload && this.renderUploadState(value._upload))));
    }
    renderPreview() {
        const { value, readOnly, assetSources, schemaType, directUploads, observeAsset } = this.props;
        const { isMenuOpen } = this.state;
        const asset = value?.asset;
        if (!asset) {
            return null;
        }
        const accept = get(schemaType, 'options.accept', '');
        let browseMenuItem = assetSources && assetSources?.length === 0 ? null : (React.createElement(MenuItem, { icon: SearchIcon, text: "Browse", onClick: () => {
                this.setState({ isMenuOpen: false });
                this.handleSelectFileFromAssetSource(assetSources[0]);
            }, disabled: readOnly, "data-testid": "file-input-browse-button" }));
        if (assetSources.length > 1) {
            browseMenuItem = assetSources.map((assetSource) => {
                return (React.createElement(MenuItem, { key: assetSource.name, text: assetSource.title, onClick: () => {
                        this.setState({ isMenuOpen: false });
                        this.handleSelectFileFromAssetSource(assetSource);
                    }, icon: assetSource.icon || ImageIcon, disabled: readOnly, "data-testid": `file-input-browse-button-${assetSource.name}` }));
            });
        }
        return (React.createElement(WithReferencedAsset, { reference: asset, observeAsset: observeAsset, waitPlaceholder: React.createElement(FileSkeleton, null) }, ({ originalFilename, extension, url, size }) => {
            const filename = originalFilename || `download.${extension}`;
            let copyUrl;
            let downloadUrl;
            if (isFileSource(value)) {
                downloadUrl = `${url}?dl`;
                copyUrl = url;
            }
            return (React.createElement(FileDetails, { size: size, originalFilename: filename, muted: !readOnly, onMenuOpen: (isOpen) => this.setState({ isMenuOpen: isOpen }), isMenuOpen: isMenuOpen },
                React.createElement(ActionsMenu, { onUpload: this.handleSelectFiles, browse: browseMenuItem, onReset: this.handleRemoveButtonClick, downloadUrl: downloadUrl, copyUrl: copyUrl, readOnly: readOnly, accept: accept, directUploads: directUploads })));
        }));
    }
    renderAssetMenu(tone) {
        const { schemaType, readOnly, directUploads, resolveUploader } = this.props;
        const { hoveringFiles } = this.state;
        const acceptedFiles = hoveringFiles.filter((file) => resolveUploader?.(schemaType, file));
        const rejectedFilesCount = hoveringFiles.length - acceptedFiles.length;
        return (React.createElement(CardOverlay, { tone: tone },
            React.createElement(FlexContainer, { align: "center", justify: "center", gap: 2, flex: 1 },
                React.createElement(PlaceholderText, { readOnly: readOnly, hoveringFiles: hoveringFiles, acceptedFiles: acceptedFiles, rejectedFilesCount: rejectedFilesCount, directUploads: directUploads, type: "file" }))));
    }
    renderBrowser() {
        const { assetSources, readOnly, directUploads, id } = this.props;
        if (assetSources.length === 0)
            return null;
        if (assetSources.length > 1 && !readOnly && directUploads) {
            return (React.createElement(MenuButton, { id: `${id}_assetFileButton`, button: React.createElement(Button, { mode: "ghost", text: "Select", "data-testid": "file-input-multi-browse-button", icon: SearchIcon }), "data-testid": "input-select-button", menu: React.createElement(Menu, null, assetSources.map((assetSource) => {
                    return (React.createElement(MenuItem, { key: assetSource.name, text: assetSource.title, onClick: () => {
                            this.setState({ isMenuOpen: false });
                            this.handleSelectFileFromAssetSource(assetSource);
                        }, icon: assetSource.icon || ImageIcon, disabled: readOnly, "data-testid": `file-input-browse-button-${assetSource.name}` }));
                })) }));
        }
        return (React.createElement(Button, { fontSize: 2, text: "Browse", icon: SearchIcon, mode: "ghost", onClick: () => {
                this.setState({ isMenuOpen: false });
                this.handleSelectFileFromAssetSource(assetSources[0]);
            }, "data-testid": "file-input-browse-button", disabled: readOnly }));
    }
    renderUploadPlaceholder() {
        const { readOnly, schemaType, directUploads, resolveUploader } = this.props;
        const { hoveringFiles } = this.state;
        const acceptedFiles = hoveringFiles.filter((file) => resolveUploader?.(schemaType, file));
        const rejectedFilesCount = hoveringFiles.length - acceptedFiles.length;
        const accept = get(schemaType, 'options.accept', '');
        return (React.createElement("div", { style: { padding: 1 } },
            React.createElement(Card, { tone: readOnly ? 'transparent' : 'inherit', border: true, padding: 3, style: hoveringFiles.length === 0
                    ? { borderStyle: 'dashed' }
                    : { borderStyle: 'dashed', borderColor: 'transparent' } },
                React.createElement(UploadPlaceholder, { browse: this.renderBrowser(), onUpload: this.handleSelectFiles, readOnly: readOnly, hoveringFiles: hoveringFiles, acceptedFiles: acceptedFiles, rejectedFilesCount: rejectedFilesCount, type: "file", accept: accept, directUploads: directUploads }))));
    }
    focus() {
        if (this._focusRef) {
            this._focusRef.focus();
        }
    }
    getFileTone() {
        const { directUploads, schemaType, value, readOnly, resolveUploader } = this.props;
        const { hoveringFiles } = this.state;
        const acceptedFiles = hoveringFiles.filter((file) => resolveUploader?.(schemaType, file));
        const rejectedFilesCount = hoveringFiles.length - acceptedFiles.length;
        if (hoveringFiles.length > 0) {
            if (rejectedFilesCount > 0 || !directUploads) {
                return 'critical';
            }
        }
        if (!value?._upload && !readOnly && hoveringFiles.length > 0) {
            return 'primary';
        }
        return value?._upload && value?.asset && readOnly ? 'transparent' : 'default';
    }
    render() {
        const { members, renderItem, renderInput, renderField, renderPreview } = this.props;
        const { selectedAssetSource } = this.state;
        return (React.createElement(React.Fragment, null,
            React.createElement(ImperativeToast, { ref: this.setToast }),
            members.map((member) => {
                if (member.kind === 'field' && (member.name === 'crop' || member.name === 'hotspot')) {
                    // we're rendering these separately
                    return null;
                }
                if (member.kind === 'field') {
                    return (React.createElement(MemberField, { key: member.key, member: member, renderInput: member.name === 'asset' ? this.renderAsset() : renderInput, renderField: member.name === 'asset' ? passThrough : renderField, renderItem: renderItem, renderPreview: renderPreview }));
                }
                if (member.kind === 'fieldSet') {
                    return (React.createElement(MemberFieldSet, { key: member.key, member: member, renderInput: renderInput, renderField: renderField, renderItem: renderItem, renderPreview: renderPreview }));
                }
                if (member.kind === 'error') {
                    return React.createElement(MemberFieldError, { member: member });
                }
                //@ts-expect-error all possible cases should be covered
                return React.createElement(React.Fragment, null,
                    "Unknown member kind: $",
                    member.kind);
            }),
            selectedAssetSource && this.renderAssetSource()));
    }
}
//# sourceMappingURL=FileInput.js.map