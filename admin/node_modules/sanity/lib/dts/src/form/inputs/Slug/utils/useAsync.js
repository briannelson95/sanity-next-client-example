import React from 'react';
/**
 * Takes an async function and returns a [AsyncState<value>, callback] pair.
 * Whenever the callback is invoked, a new AsyncState is returned.
 * If the returned callback is called again before the previous callback has settled, the resolution of the previous one will be ignored, thus preventing race conditions.
 * @param fn an async function that returns a value
 * @param dependencies list of dependencies that will return a new [value, callback] pair
 */
export function useAsync(fn, dependencies) {
    const [state, setState] = React.useState(null);
    const lastId = React.useRef(0);
    const wrappedCallback = React.useCallback((arg) => {
        const asyncId = ++lastId.current;
        setState({ status: 'pending' });
        Promise.resolve()
            .then(() => fn(arg))
            .then((res) => {
            if (asyncId === lastId.current) {
                setState({ status: 'complete', result: res });
            }
        }, (err) => {
            if (asyncId === lastId.current) {
                setState({ status: 'error', error: err });
            }
        });
    }, [fn, ...dependencies]);
    return [state, wrappedCallback];
}
//# sourceMappingURL=useAsync.js.map