import React, { useState, useMemo, useCallback } from 'react';
import { PortableTextEditor, usePortableTextEditor, } from '@sanity/portable-text-editor';
import { BoundaryElementProvider, Portal, PortalProvider, Text, useBoundaryElement, usePortal, } from '@sanity/ui';
import { ChangeIndicator } from '../../../components/changeIndicators';
import { ActivateOnFocus } from '../../components/ActivateOnFocus/ActivateOnFocus';
import { EMPTY_ARRAY } from '../../utils/empty';
import { FormInput } from '../../FormInput';
import { BlockObject } from './object/BlockObject';
import { InlineObject } from './object/InlineObject';
import { Annotation, TextBlock } from './text';
import { Editor } from './Editor';
import { ExpandedLayer, Root } from './Compositor.styles';
import { useHotkeys } from './hooks/useHotKeys';
import { ObjectEditModal } from './object/renderers/ObjectEditModal';
import { useScrollToOpenedMember } from './hooks/useScrollToOpenedMember';
import { usePortableTextMemberItems } from './hooks/usePortableTextMembers';
import { _isBlockType } from './_helpers';
function isTouchDevice() {
    return ((typeof window !== 'undefined' && 'ontouchstart' in window) ||
        (typeof navigator !== 'undefined' && navigator.maxTouchPoints > 0));
}
const activateVerb = isTouchDevice() ? 'Tap' : 'Click';
const ACTIVATE_ON_FOCUS_MESSAGE = React.createElement(Text, { weight: "semibold" },
    activateVerb,
    " to activate");
export function Compositor(props) {
    const { changed, focusPath = EMPTY_ARRAY, focused, hasFocus, hotkeys, isActive, isFullscreen, onChange, onCopy, onActivate, onOpenItem, onCloseItem, onPaste, onToggleFullscreen, path, renderBlockActions, renderCustomMarkers, value, readOnly, renderPreview, } = props;
    const editor = usePortableTextEditor();
    const [wrapperElement, setWrapperElement] = useState(null);
    const [scrollElement, setScrollElement] = useState(null);
    const portableTextMemberItems = usePortableTextMemberItems();
    const { element: boundaryElement } = useBoundaryElement();
    // Scroll to the DOM element of the "opened" portable text member when relevant.
    useScrollToOpenedMember({
        hasFocus,
        editorRootPath: path,
        scrollElement,
        onCloseItem,
    });
    const handleToggleFullscreen = useCallback(() => {
        onToggleFullscreen();
    }, [onToggleFullscreen]);
    const hotkeysWithFullscreenToggle = useMemo(() => ({
        ...hotkeys,
        custom: {
            'mod+enter': onToggleFullscreen,
            ...(hotkeys?.custom || {}),
        },
    }), [hotkeys, onToggleFullscreen]);
    const editorHotkeys = useHotkeys(hotkeysWithFullscreenToggle);
    const ptFeatures = useMemo(() => PortableTextEditor.getPortableTextFeatures(editor), [editor]);
    const hasContent = !!value;
    const initialSelection = useMemo(() => focusPath.length > 0
        ? {
            anchor: { path: focusPath, offset: 0 },
            focus: { path: focusPath, offset: 0 },
        }
        : null, 
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [] // Only initial
    );
    const renderBlock = useCallback((block, blockType, attributes, defaultRender) => {
        const isTextBlock = block._type === ptFeatures.types.block.name;
        if (isTextBlock) {
            return (React.createElement(TextBlock, { attributes: attributes, block: block, isFullscreen: isFullscreen, onChange: onChange, readOnly: readOnly, renderBlockActions: hasContent ? renderBlockActions : undefined, renderCustomMarkers: hasContent ? renderCustomMarkers : undefined }, defaultRender(block)));
        }
        return (React.createElement(BlockObject, { attributes: attributes, block: block, isFullscreen: isFullscreen, onChange: onChange, onOpenItem: onOpenItem, readOnly: readOnly, renderBlockActions: hasContent ? renderBlockActions : undefined, renderCustomMarkers: hasContent ? renderCustomMarkers : undefined, renderPreview: renderPreview, type: blockType }));
    }, [
        hasContent,
        isFullscreen,
        onChange,
        onOpenItem,
        ptFeatures.types.block.name,
        readOnly,
        renderBlockActions,
        renderCustomMarkers,
        renderPreview,
    ]);
    const renderChild = useCallback((child, childType, attributes, defaultRender) => {
        const isSpan = child._type === ptFeatures.types.span.name;
        if (isSpan) {
            return defaultRender(child);
        }
        return (React.createElement(InlineObject, { attributes: attributes, onOpenItem: onOpenItem, readOnly: readOnly, renderCustomMarkers: renderCustomMarkers, scrollElement: scrollElement, type: childType, value: child, renderPreview: renderPreview }));
    }, [
        onOpenItem,
        ptFeatures.types.span.name,
        readOnly,
        renderCustomMarkers,
        renderPreview,
        scrollElement,
    ]);
    const renderAnnotation = useCallback((annotation, annotationType, attributes, defaultRender) => {
        return (React.createElement(Annotation, { attributes: attributes, onOpenItem: onOpenItem, readOnly: readOnly, renderCustomMarkers: renderCustomMarkers, scrollElement: scrollElement, value: annotation, type: annotationType }, defaultRender()));
    }, [onOpenItem, readOnly, renderCustomMarkers, scrollElement]);
    const [portalElement, setPortalElement] = useState(null);
    const openMemberItems = useMemo(() => portableTextMemberItems.filter((m) => m.member.open && !_isBlockType(m.node.schemaType)), [portableTextMemberItems]);
    const editorNode = useMemo(() => (React.createElement(Editor, { hotkeys: editorHotkeys, initialSelection: initialSelection, isFullscreen: isFullscreen, onOpenItem: onOpenItem, onCopy: onCopy, onPaste: onPaste, onToggleFullscreen: handleToggleFullscreen, path: path, readOnly: readOnly, renderAnnotation: renderAnnotation, renderBlock: renderBlock, renderChild: renderChild, setPortalElement: setPortalElement, scrollElement: scrollElement, setScrollElement: setScrollElement })), 
    // Keep only stable ones here!
    [
        editorHotkeys,
        handleToggleFullscreen,
        initialSelection,
        isFullscreen,
        onCopy,
        onOpenItem,
        onPaste,
        path,
        readOnly,
        renderAnnotation,
        renderBlock,
        renderChild,
        scrollElement,
    ]);
    const boundaryElm = isFullscreen ? scrollElement : boundaryElement;
    const children = useMemo(() => boundaryElm && (React.createElement(React.Fragment, null,
        editorNode,
        React.createElement(BoundaryElementProvider, { element: boundaryElm }, openMemberItems.map((dMemberItem) => {
            return (React.createElement(ObjectEditModal, { kind: dMemberItem.kind, key: dMemberItem.member.key, memberItem: dMemberItem, onClose: onCloseItem, scrollElement: boundaryElm },
                React.createElement(FormInput, { absolutePath: dMemberItem.node.path, ...props })));
        })))), [boundaryElm, editorNode, openMemberItems, onCloseItem, props]);
    const portal = usePortal();
    const portalElements = useMemo(() => ({
        collapsed: wrapperElement,
        default: portal.element,
        editor: portalElement,
        expanded: portal.element,
    }), [portal.element, portalElement, wrapperElement]);
    const editorLayer = useMemo(() => (React.createElement(Portal, { __unstable_name: isFullscreen ? 'expanded' : 'collapsed' },
        React.createElement(ExpandedLayer, { "data-fullscreen": isFullscreen ? '' : undefined }, children))), [children, isFullscreen]);
    return (React.createElement(PortalProvider, { __unstable_elements: portalElements },
        React.createElement(ActivateOnFocus, { message: ACTIVATE_ON_FOCUS_MESSAGE, onActivate: onActivate, isOverlayActive: !isActive },
            React.createElement(ChangeIndicator, { disabled: isFullscreen, hasFocus: Boolean(focused), isChanged: changed, path: path },
                React.createElement(Root, { "data-focused": hasFocus ? '' : undefined, "data-read-only": readOnly ? '' : undefined },
                    React.createElement("div", { "data-wrapper": "", ref: setWrapperElement }, editorLayer),
                    React.createElement("div", { "data-border": "" }))))));
}
//# sourceMappingURL=Compositor.js.map