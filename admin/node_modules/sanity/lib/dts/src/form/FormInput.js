import React, { memo, useCallback, useMemo } from 'react';
import { isEqual, startsWith, trimLeft } from '@sanity/util/paths';
import { isKeySegment } from '@sanity/types';
import { isArrayInputProps, isObjectInputProps } from './utils/asserters';
import { MemberField, MemberItem, MemberItemError } from './members';
const pass = ({ children }) => children;
function hasAbsolutePath(a) {
    return 'absolutePath' in a;
}
export const FormInput = memo(function FormInput(props) {
    const absolutePath = useMemo(() => {
        return hasAbsolutePath(props) ? props.absolutePath : props.path.concat(props.relativePath);
    }, [props]);
    return (React.createElement(FormInputInner, { ...props, absolutePath: absolutePath, destinationRenderField: props.renderField, destinationRenderInput: props.renderInput, destinationRenderItem: props.renderItem, destinationRenderPreview: props.renderPreview }));
});
/**
 * An input that takes input props for object or array and renders an input for a given sub-path
 */
const FormInputInner = memo(function FormInputInner(props) {
    const { absolutePath, destinationRenderInput, destinationRenderItem, destinationRenderField, destinationRenderPreview, } = props;
    const renderInput = useCallback((inputProps) => {
        const isDestinationReached = isEqual(inputProps.path, absolutePath) || startsWith(absolutePath, inputProps.path);
        if (isDestinationReached) {
            // we have reached the destination node and can now render with the passed renderInput
            return destinationRenderInput(inputProps);
        }
        if (!isObjectInputProps(inputProps) && !isArrayInputProps(inputProps)) {
            throw new Error(`Expected either object input props or array input props for: ${JSON.stringify(inputProps.path)}`);
        }
        // we have not yet reached the destination path, so we'll continue recurse until we get there
        return (React.createElement(FormInputInner, { ...inputProps, absolutePath: absolutePath, destinationRenderInput: destinationRenderInput, destinationRenderItem: destinationRenderItem, destinationRenderField: destinationRenderField, destinationRenderPreview: destinationRenderPreview }));
    }, [
        absolutePath,
        destinationRenderField,
        destinationRenderInput,
        destinationRenderItem,
        destinationRenderPreview,
    ]);
    const renderField = useCallback((fieldProps) => {
        // we want to render the field around the input if either of these are true:
        // 1. we have reached the destination path and the `includeField`-prop is passed as true
        // 2. we are currently at a node somewhere below/inside the destination path
        const shouldRenderField = startsWith(absolutePath, fieldProps.path) &&
            (props.includeField || !isEqual(absolutePath, fieldProps.path));
        return shouldRenderField ? destinationRenderField(fieldProps) : pass(fieldProps);
    }, [absolutePath, destinationRenderField, props.includeField]);
    if (isArrayInputProps(props)) {
        const childPath = trimLeft(props.path, absolutePath);
        const itemMember = props.members.find((member) => member.kind == 'item' && isKeySegment(childPath[0]) && member.key === childPath[0]._key);
        if (!itemMember) {
            const relativePath = trimLeft(props.path, absolutePath);
            const key = relativePath[0]._key;
            return (React.createElement("div", null,
                "No array item with _key ",
                React.createElement("code", null,
                    "\"",
                    key,
                    "\""),
                " found at path ",
                JSON.stringify(props.path)));
        }
        if (itemMember.kind === 'error') {
            return React.createElement(MemberItemError, { member: itemMember });
        }
        return (React.createElement(MemberItem, { member: itemMember, renderInput: renderInput, renderField: renderField, renderItem: pass, renderPreview: destinationRenderPreview }));
    }
    if (isObjectInputProps(props)) {
        const childPath = trimLeft(props.path, absolutePath);
        const fieldMember = props.members.find((member) => member.kind == 'field' && childPath[0] === member.name);
        if (!fieldMember) {
            const fieldName = childPath[0];
            return (React.createElement("div", null,
                "Field ",
                JSON.stringify(fieldName),
                " not found among members \u2013 please verify that it's both defined in the schema and that it has not been conditionally hidden."));
        }
        return (React.createElement(MemberField, { member: fieldMember, renderInput: renderInput, renderField: renderField, renderItem: pass, renderPreview: destinationRenderPreview }));
    }
    throw new Error('FormInput can only be used with arrays or objects');
});
//# sourceMappingURL=FormInput.js.map