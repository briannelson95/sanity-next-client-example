import { isRecord } from '../../util/isRecord';
import { getOrderedTools } from './util/getOrderedTools';
function resolveUrlStateWithDefaultTool(tools, state) {
    const orderedTools = getOrderedTools(tools);
    const defaultTool = orderedTools[0];
    if (!state || state.tool || !defaultTool) {
        return state;
    }
    return Object.assign({}, state, {
        tool: defaultTool.name,
    });
}
function makeBackwardsCompatible(tools, state) {
    if (!state) {
        return state;
    }
    if (getOrderedTools(tools).find((tool) => tool.name === state.space)) {
        return { ...state, tool: state.space, space: undefined };
    }
    return state;
}
export function resolveDefaultState(tools, state) {
    const urlStateWithDefaultTool = resolveUrlStateWithDefaultTool(tools, makeBackwardsCompatible(tools, state));
    return urlStateWithDefaultTool;
}
export function resolveIntentState(tools, currentState, intentState) {
    const { intent, params, payload } = intentState;
    if (typeof intent !== 'string') {
        throw new Error('intent must be a string');
    }
    if (!isRecord(params)) {
        throw new Error('intent params must be a string');
    }
    const orderedTools = getOrderedTools(tools);
    const currentTool = currentState?.tool
        ? orderedTools.find((tool) => tool.name === currentState.tool)
        : null;
    // If current tool can handle intent and if so, give it precedence
    const matchingTool = (currentTool ? [currentTool, ...orderedTools] : orderedTools).find((tool) => tool &&
        typeof tool.canHandleIntent === 'function' &&
        tool.canHandleIntent(intent, params, currentState && currentState[tool.name]));
    if (matchingTool?.getIntentState) {
        const toolState = matchingTool.getIntentState(intent, params, currentState && currentState[matchingTool.name], payload);
        return {
            type: 'state',
            isNotFound: false,
            state: {
                ...currentState,
                tool: matchingTool.name,
                [matchingTool.name]: toolState,
            },
        };
    }
    return {
        type: 'intent',
        isNotFound: true,
        intent: { name: intent, params },
    };
}
export function decodeUrlState(rootRouter, pathname) {
    return {
        type: 'state',
        state: rootRouter.decode(pathname) || {},
        isNotFound: rootRouter.isNotFound(pathname),
    };
}
export function isNonNullable(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=helpers.js.map