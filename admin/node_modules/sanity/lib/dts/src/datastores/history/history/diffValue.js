import { wrap, diffInput } from '@sanity/diff';
import { isSameAnnotation } from './utils';
class ArrayContentWrapper {
    constructor(content, value, annotation, extractor) {
        this.type = 'array';
        this.elements = [];
        this.content = content;
        this.value = value;
        this.annotation = annotation;
        this.extractor = extractor;
        this.length = content.elements.length;
    }
    at(idx) {
        if (idx >= this.length)
            throw new Error('out of bounds');
        const input = this.elements[idx];
        if (input) {
            return input;
        }
        return (this.elements[idx] = wrapValue(this.content.elements[idx], this.value[idx], this.extractor));
    }
    annotationAt(idx) {
        const meta = this.content.metas[idx];
        return this.extractor.fromMeta(meta);
    }
}
class ObjectContentWrapper {
    constructor(content, value, annotation, extractor) {
        this.type = 'object';
        this.fields = {};
        this.content = content;
        this.value = value;
        this.annotation = annotation;
        this.extractor = extractor;
        this.keys = Object.keys(content.fields);
    }
    get(key) {
        const input = this.fields[key];
        if (input) {
            return input;
        }
        const value = this.content.fields[key];
        if (!value)
            return undefined;
        return (this.fields[key] = wrapValue(value, this.value[key], this.extractor));
    }
}
class StringContentWrapper {
    constructor(content, value, annotation, extractor) {
        this.type = 'string';
        this.content = content;
        this.value = value;
        this.annotation = annotation;
        this.extractor = extractor;
    }
    sliceAnnotation(start, end) {
        const result = [];
        let idx = 0;
        function push(text, annotation) {
            if (result.length > 0) {
                const lst = result[result.length - 1];
                if (isSameAnnotation(lst.annotation, annotation)) {
                    lst.text += text;
                    return;
                }
            }
            result.push({ text, annotation });
        }
        for (const part of this.content.parts) {
            const length = part.value.length;
            const subStart = Math.max(0, start - idx);
            if (subStart < length) {
                // The start of the slice is inside this part somewhere.
                // Figure out where the end is:
                const subEnd = Math.min(length, end - idx);
                // If the end of the slice is before this part, then we're guaranteed
                // that there are no more parts.
                if (subEnd <= 0)
                    break;
                push(part.value.slice(subStart, subEnd), this.extractor.fromValue(part));
            }
            idx += length;
        }
        return result;
    }
}
function wrapValue(value, raw, extractor) {
    const annotation = extractor.fromValue(value);
    if (value.content) {
        switch (value.content.type) {
            case 'array':
                return new ArrayContentWrapper(value.content, raw, annotation, extractor);
            case 'object':
                return new ObjectContentWrapper(value.content, raw, annotation, extractor);
            case 'string':
                return new StringContentWrapper(value.content, raw, annotation, extractor);
            default:
            // do nothing
        }
    }
    return wrap(raw, annotation);
}
function extractAnnotationForFromInput(timeline, firstChunk, meta) {
    if (meta) {
        // The next transaction is where it disappeared:
        return annotationForTransactionIndex(timeline, meta.transactionIndex + 1, meta.chunk.index);
    }
    else if (firstChunk) {
        return annotationForTransactionIndex(timeline, firstChunk.start, firstChunk.index);
    }
    return null;
}
function extractAnnotationForToInput(timeline, meta) {
    if (meta) {
        return annotationForTransactionIndex(timeline, meta.transactionIndex, meta.chunk.index);
    }
    return null;
}
function annotationForTransactionIndex(timeline, idx, chunkIdx) {
    const tx = timeline.transactionByIndex(idx);
    if (!tx)
        return null;
    const chunk = timeline.chunkByTransactionIndex(idx, chunkIdx);
    if (!chunk)
        return null;
    return {
        chunk,
        timestamp: tx.timestamp,
        author: tx.author,
    };
}
// eslint-disable-next-line max-params
export function diffValue(timeline, firstChunk, from, fromRaw, to, toRaw) {
    const fromInput = wrapValue(from, fromRaw, {
        fromValue(value) {
            return extractAnnotationForFromInput(timeline, firstChunk, value.endMeta);
        },
        fromMeta(meta) {
            return extractAnnotationForFromInput(timeline, firstChunk, meta);
        },
    });
    const toInput = wrapValue(to, toRaw, {
        fromValue(value) {
            return extractAnnotationForToInput(timeline, value.startMeta);
        },
        fromMeta(meta) {
            return extractAnnotationForToInput(timeline, meta);
        },
    });
    return diffInput(fromInput, toInput);
}
//# sourceMappingURL=diffValue.js.map