import { cloneDeep, get, memoize, uniqBy } from 'lodash';
import { isKeyedObject, isReference, isBlock, isBlockSchemaType, isSpanSchemaType, isTypedObject } from '@sanity/types';
import formatDate from 'date-fns/format';

// Follows the same pattern as Rule and RuleClass. @see Rule
const ValidationError = class ValidationError {
    message;
    paths;
    children;
    operation;
    constructor(message, options = {}) {
        this.message = message;
        this.paths = options.paths || [];
        this.children = options.children;
        this.operation = options.operation;
    }
    cloneWithMessage(msg) {
        return new ValidationError(msg, {
            paths: this.paths,
            children: this.children,
            operation: this.operation,
        });
    }
};

/* eslint-disable no-useless-escape */
var escapeRegex = (string) => {
    // Escape ^$.*+-?=!:|\/()[]{},
    return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, '\\$&');
};

function pathToString(path = []) {
    return path.reduce((target, segment, i) => {
        const segmentType = typeof segment;
        if (segmentType === 'number') {
            return `${target}[${segment}]`;
        }
        if (segmentType === 'string') {
            const separator = i === 0 ? '' : '.';
            return `${target}${separator}${segment}`;
        }
        if (isKeyedObject(segment)) {
            return `${target}[_key=="${segment._key}"]`;
        }
        throw new Error(`Unsupported path segment "${segment}"`);
    }, '');
}

function isNonNullable$1(t) {
    return t !== null || t !== undefined;
}
function convertToValidationMarker(validatorResult, level, context) {
    if (!context) {
        throw new Error('missing context');
    }
    if (validatorResult === true)
        return [];
    if (Array.isArray(validatorResult)) {
        return validatorResult
            .flatMap((child) => convertToValidationMarker(child, level, context))
            .filter(isNonNullable$1);
    }
    if (typeof validatorResult === 'string') {
        return convertToValidationMarker(new ValidationError(validatorResult), level, context);
    }
    if (!(validatorResult instanceof ValidationError)) {
        // in order to accept the `ValidationErrorLike`, it at least needs to have
        // a `message` in the object
        if (typeof validatorResult?.message !== 'string') {
            throw new Error(`${pathToString(context.path)}: Validator must return 'true' if valid or an error message as a string on errors`);
        }
        // this is the occurs when an object is returned that wasn't created with the
        // `ValidationErrorClass`. in this case, we want to convert it to a class
        return convertToValidationMarker(new ValidationError(validatorResult.message, validatorResult), level, context);
    }
    const results = [];
    // the validator result does not include any item-level relative paths,
    // then just return the top-level path with the validation result
    if (!validatorResult.paths?.length) {
        return [
            {
                level: level || 'error',
                item: validatorResult,
                path: context.path || [],
            },
        ];
    }
    // if the validator result did include item-level relative paths, then for
    // each item-level relative path, create a validation marker that concatenates
    // the relative path with the path from the validation context
    return results.concat(validatorResult.paths.map((path) => ({
        path: (context.path || []).concat(path),
        level: level || 'error',
        item: validatorResult,
    })));
}

// this file was adapted from a previous dependency `type-of-is`
// https://github.com/stephenhandley/type-of-is/blob/7138a7e79f5af7c286bf8123f60843a91aaebf38/index.js
const _toString = {}.toString;
const builtIns = [Object, Function, Array, String, Boolean, Number, Date, RegExp, Error];
function isBuiltIn(_constructor) {
    for (let i = 0; i < builtIns.length; i++) {
        if (builtIns[i] === _constructor)
            return true;
    }
    return false;
}
function typeString(obj) {
    // [object Blah] -> Blah
    const stringType = _toString.call(obj).slice(8, -1);
    if (obj === null || obj === undefined)
        return stringType.toLowerCase();
    // eslint-disable-next-line @typescript-eslint/ban-types
    const constructorType = obj.constructor;
    if (constructorType && !isBuiltIn(constructorType))
        return constructorType.name;
    return stringType;
}

/**
 * Modified version of fast-deep-equal (https://github.com/epoberezkin/fast-deep-equal)
 * MIT-licensed, copyright (c) 2017 Evgeny Poberezkin
 **/
// NOTE: when converting to typescript, some of the checks were inlined (vs
// having them in a variable) because the type predicate type narrowing only
// works when type predicate is called inline in the condition that starts the
// control flow branch.
// see here: https://www.typescriptlang.org/docs/handbook/2/narrowing.html
function deepEquals(a, b) {
    if (a === b) {
        return true;
    }
    if (Array.isArray(a) && Array.isArray(b)) {
        if (a.length != b.length)
            return false;
        for (let i = 0; i < a.length; i++) {
            if (!deepEquals(a[i], b[i])) {
                return false;
            }
        }
        return true;
    }
    if (Array.isArray(a) != Array.isArray(b)) {
        return false;
    }
    if (a && b && typeof a === 'object' && typeof b === 'object') {
        const keys = Object.keys(a);
        if (keys.length !== Object.keys(b).length) {
            return false;
        }
        if (a instanceof Date && b instanceof Date) {
            return a.getTime() === b.getTime();
        }
        if (a instanceof Date != b instanceof Date) {
            return false;
        }
        if (a instanceof RegExp && b instanceof RegExp) {
            return a.toString() == b.toString();
        }
        if (a instanceof RegExp != b instanceof RegExp) {
            return false;
        }
        for (let i = 0; i < keys.length; i++) {
            if (keys[i] === '_key') {
                continue;
            }
            if (!Object.prototype.hasOwnProperty.call(b, keys[i])) {
                return false;
            }
        }
        for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            if (key === '_key') {
                continue;
            }
            if (!deepEquals(a[key], b[key])) {
                return false;
            }
        }
        return true;
    }
    return false;
}

const SLOW_VALIDATOR_TIMEOUT = 5000;
const formatValidationErrors = (options) => {
    let message;
    if (options.message) {
        message = options.message;
    }
    else if (options.results.length === 1) {
        message = options.results[0]?.item.message;
    }
    else {
        message = `[${options.results
            .map((err) => err.item.message)
            .join(` - ${options.operation} - `)}]`;
    }
    return new ValidationError(message, {
        children: options.results.length > 1 ? options.results : undefined,
        operation: options.operation,
    });
};
const genericValidators = {
    type: (expected, value, message) => {
        const actualType = typeString(value);
        if (actualType !== expected && actualType !== 'undefined') {
            return message || `Expected type "${expected}", got "${actualType}"`;
        }
        return true;
    },
    presence: (expected, value, message) => {
        if (value === undefined && expected === 'required') {
            return message || 'Value is required';
        }
        return true;
    },
    all: async (children, value, message, context) => {
        const resolved = await Promise.all(children.map((child) => child.validate(value, context)));
        const results = resolved.flat();
        if (!results.length)
            return true;
        return formatValidationErrors({
            message,
            results,
            operation: 'AND',
        });
    },
    either: async (children, value, message, context) => {
        const resolved = await Promise.all(children.map((child) => child.validate(value, context)));
        const results = resolved.flat();
        // Read: There is at least one rule that matched
        if (results.length < children.length)
            return true;
        return formatValidationErrors({
            message,
            results,
            operation: 'OR',
        });
    },
    valid: (allowedValues, actual, message) => {
        const valueType = typeof actual;
        if (valueType === 'undefined') {
            return true;
        }
        const value = (valueType === 'number' || valueType === 'string') && `${actual}`;
        const strValue = value && value.length > 30 ? `${value.slice(0, 30)}…` : value;
        const defaultMessage = value
            ? `Value "${strValue}" did not match any allowed values`
            : 'Value did not match any allowed values';
        return allowedValues.some((expected) => deepEquals(expected, actual))
            ? true
            : message || defaultMessage;
    },
    custom: async (fn, value, message, context) => {
        const slowTimer = setTimeout(() => {
            // eslint-disable-next-line no-console
            console.warn(`Custom validator at ${pathToString(context.path)} has taken more than ${SLOW_VALIDATOR_TIMEOUT}ms to respond`);
        }, SLOW_VALIDATOR_TIMEOUT);
        let result;
        try {
            result = await fn(value, context);
        }
        finally {
            clearTimeout(slowTimer);
        }
        if (typeof result === 'string')
            return message || result;
        return result;
    },
};

const booleanValidators = {
    ...genericValidators,
    presence: (flag, value, message) => {
        if (flag === 'required' && typeof value !== 'boolean') {
            return message || 'Required';
        }
        return true;
    },
};

const precisionRx = /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/;
const numberValidators = {
    ...genericValidators,
    integer: (_unused, value, message) => {
        if (!Number.isInteger(value)) {
            return message || 'Must be an integer';
        }
        return true;
    },
    precision: (limit, value, message) => {
        if (value === undefined)
            return true;
        const places = value.toString().match(precisionRx);
        const decimals = Math.max((places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0), 0);
        if (decimals > limit) {
            return message || `Max precision is ${limit}`;
        }
        return true;
    },
    min: (minNum, value, message) => {
        if (value >= minNum) {
            return true;
        }
        return message || `Must be greater than or equal ${minNum}`;
    },
    max: (maxNum, value, message) => {
        if (value <= maxNum) {
            return true;
        }
        return message || `Must be less than or equal ${maxNum}`;
    },
    greaterThan: (num, value, message) => {
        if (value > num) {
            return true;
        }
        return message || `Must be greater than ${num}`;
    },
    lessThan: (maxNum, value, message) => {
        if (value < maxNum) {
            return true;
        }
        return message || `Must be less than ${maxNum}`;
    },
};

const DUMMY_ORIGIN = 'http://sanity';
const emailRegex = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
const isRelativeUrl = (url) => /^\.*\//.test(url);
const stringValidators = {
    ...genericValidators,
    min: (minLength, value, message) => {
        if (!value || value.length >= minLength) {
            return true;
        }
        return message || `Must be at least ${minLength} characters long`;
    },
    max: (maxLength, value, message) => {
        if (!value || value.length <= maxLength) {
            return true;
        }
        return message || `Must be at most ${maxLength} characters long`;
    },
    length: (wantedLength, value, message) => {
        const strValue = value || '';
        if (strValue.length === wantedLength) {
            return true;
        }
        return message || `Must be exactly ${wantedLength} characters long`;
    },
    uri: (constraints, value, message) => {
        const strValue = value || '';
        const { options } = constraints;
        const { allowCredentials, relativeOnly } = options;
        const allowRelative = options.allowRelative || relativeOnly;
        let url;
        try {
            // WARNING: Safari checks for a given `base` param by looking at the length of arguments passed
            // to new URL(str, base), and will fail if invoked with new URL(strValue, undefined)
            url = allowRelative ? new URL(strValue, DUMMY_ORIGIN) : new URL(strValue);
        }
        catch (err) {
            return message || 'Not a valid URL';
        }
        if (relativeOnly && url.origin !== DUMMY_ORIGIN) {
            return message || 'Only relative URLs are allowed';
        }
        if (!allowRelative && url.origin === DUMMY_ORIGIN && isRelativeUrl(strValue)) {
            return message || 'Relative URLs are not allowed';
        }
        if (!allowCredentials && (url.username || url.password)) {
            return message || `Username/password not allowed`;
        }
        const urlScheme = url.protocol.replace(/:$/, '');
        const matchesAllowedScheme = options.scheme.some((scheme) => scheme.test(urlScheme));
        if (!matchesAllowedScheme) {
            return message || 'Does not match allowed protocols/schemes';
        }
        return true;
    },
    stringCasing: (casing, value, message) => {
        const strValue = value || '';
        if (casing === 'uppercase' && strValue !== strValue.toLocaleUpperCase()) {
            return message || `Must be all uppercase letters`;
        }
        if (casing === 'lowercase' && strValue !== strValue.toLocaleLowerCase()) {
            return message || `Must be all lowercase letters`;
        }
        return true;
    },
    presence: (flag, value, message) => {
        if (flag === 'required' && !value) {
            return message || 'Required';
        }
        return true;
    },
    regex: (options, value, message) => {
        const { pattern, name, invert } = options;
        const regName = name || `"${pattern.toString()}"`;
        const strValue = value || '';
        const matches = pattern.test(strValue);
        if ((!invert && !matches) || (invert && matches)) {
            const defaultMessage = invert
                ? `Should not match ${regName}-pattern`
                : `Does not match ${regName}-pattern`;
            return message || defaultMessage;
        }
        return true;
    },
    email: (_unused, value, message) => {
        const strValue = `${value || ''}`.trim();
        if (!strValue || emailRegex.test(strValue)) {
            return true;
        }
        return message || 'Must be a valid email address';
    },
};

const arrayValidators = {
    ...genericValidators,
    min: (minLength, value, message) => {
        if (!value || value.length >= minLength) {
            return true;
        }
        return message || `Must have at least ${minLength} items`;
    },
    max: (maxLength, value, message) => {
        if (!value || value.length <= maxLength) {
            return true;
        }
        return message || `Must have at most ${maxLength} items`;
    },
    length: (wantedLength, value, message) => {
        if (!value || value.length === wantedLength) {
            return true;
        }
        return message || `Must have exactly ${wantedLength} items`;
    },
    presence: (flag, value, message) => {
        if (flag === 'required' && !value) {
            return message || 'Required';
        }
        return true;
    },
    valid: (allowedValues, values, message) => {
        const valueType = typeof values;
        if (valueType === 'undefined') {
            return true;
        }
        const paths = [];
        for (let i = 0; i < values.length; i++) {
            const value = values[i];
            if (allowedValues.some((expected) => deepEquals(expected, value))) {
                continue;
            }
            const pathSegment = value && value._key ? { _key: value._key } : i;
            paths.push([pathSegment]);
        }
        return paths.length === 0
            ? true
            : new ValidationError(message || 'Value did not match any allowed values', { paths });
    },
    unique: (_unused, value, message) => {
        const dupeIndices = [];
        if (!value) {
            return true;
        }
        for (let x = 0; x < value.length; x++) {
            for (let y = x + 1; y < value.length; y++) {
                const itemA = value[x];
                const itemB = value[y];
                if (!deepEquals(itemA, itemB)) {
                    continue;
                }
                if (dupeIndices.indexOf(x) === -1) {
                    dupeIndices.push(x);
                }
                if (dupeIndices.indexOf(y) === -1) {
                    dupeIndices.push(y);
                }
            }
        }
        const paths = dupeIndices.map((idx) => {
            const item = value[idx];
            const pathSegment = item && item._key ? { _key: item._key } : idx;
            return [pathSegment];
        });
        return dupeIndices.length > 0
            ? new ValidationError(message || `Can't be a duplicate`, { paths })
            : true;
    },
};

const metaKeys = ['_key', '_type', '_weak'];
const objectValidators = {
    ...genericValidators,
    presence: (expected, value, message) => {
        if (expected !== 'required') {
            return true;
        }
        const keys = value && Object.keys(value).filter((key) => !metaKeys.includes(key));
        if (value === undefined || (keys && keys.length === 0)) {
            return message || 'Required';
        }
        return true;
    },
    reference: async (_unused, value, message, context) => {
        if (!value) {
            return true;
        }
        if (!isReference(value)) {
            return message || true;
        }
        const { type, getDocumentExists } = context;
        if (!type) {
            throw new Error(`\`type\` was not provided in validation context`);
        }
        if ('weak' in type && type.weak) {
            return true;
        }
        if (!getDocumentExists) {
            throw new Error(`\`getDocumentExists\` was not provided in validation context`);
        }
        const exists = await getDocumentExists({ id: value._ref });
        if (!exists) {
            return 'This reference must be published';
        }
        return true;
    },
    assetRequired: (flag, value, message) => {
        if (!value || !value.asset || !value.asset._ref) {
            const assetType = flag.assetType || 'Asset';
            return message || `${assetType} required`;
        }
        return true;
    },
};

function isRecord$1(obj) {
    return typeof obj === 'object' && obj !== null && !Array.isArray(obj);
}
const isoDate = /^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/;
const getFormattedDate = (type = '', value, options) => {
    let format = 'yyyy-MM-dd';
    if (options && options.dateFormat) {
        format = options.dateFormat;
    }
    if (type === 'date') {
        // If the type is date only
        return formatDate(new Date(value), format);
    }
    // If the type is datetime
    if (options && options.timeFormat) {
        format += ` ${options.timeFormat}`;
    }
    else {
        format += ' HH:mm';
    }
    return formatDate(new Date(value), format);
};
function parseDate(date, throwOnError = false) {
    if (!date)
        return null;
    if (date === 'now')
        return new Date();
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const parsed = new Date(date);
    const isInvalid = isNaN(parsed.getTime());
    if (isInvalid && throwOnError) {
        throw new Error(`Unable to parse "${date}" to a date`);
    }
    return isInvalid ? null : parsed;
}
const dateValidators = {
    ...genericValidators,
    type: (_unused, value, message) => {
        const strVal = `${value}`;
        if (!strVal || isoDate.test(value)) {
            return true;
        }
        return message || 'Must be a valid ISO-8601 formatted date string';
    },
    min: (minDate, value, message, context) => {
        const dateVal = parseDate(value);
        if (!dateVal) {
            return true; // `type()` should catch parse errors
        }
        if (!value || dateVal >= parseDate(minDate, true)) {
            return true;
        }
        if (!context.type) {
            throw new Error(`\`type\` was not provided in validation context.`);
        }
        const dateTimeOptions = isRecord$1(context.type.options)
            ? context.type.options
            : {};
        const date = getFormattedDate(context.type.name, minDate, dateTimeOptions);
        return message || `Must be at or after ${date}`;
    },
    max: (maxDate, value, message, context) => {
        const dateVal = parseDate(value);
        if (!dateVal) {
            return true; // `type()` should catch parse errors
        }
        if (!value || dateVal <= parseDate(maxDate, true)) {
            return true;
        }
        if (!context.type) {
            throw new Error(`\`type\` was not provided in validation context.`);
        }
        const dateTimeOptions = isRecord$1(context.type.options)
            ? context.type.options
            : {};
        const date = getFormattedDate(context.type.name, maxDate, dateTimeOptions);
        return message || `Must be at or before ${date}`;
    },
};

const typeValidators = {
    Boolean: booleanValidators,
    Number: numberValidators,
    String: stringValidators,
    Array: arrayValidators,
    Object: objectValidators,
    Date: dateValidators,
};
const getBaseType = (type) => {
    return type && type.type ? getBaseType(type.type) : type;
};
const isFieldRef = (constraint) => {
    if (typeof constraint !== 'object' || !constraint)
        return false;
    return constraint.type === Rule.FIELD_REF;
};
const EMPTY_ARRAY = [];
const FIELD_REF = Symbol('FIELD_REF');
const ruleConstraintTypes$1 = [
    'Array',
    'Boolean',
    'Date',
    'Number',
    'Object',
    'String',
];
// Note: `RuleClass` and `Rule` are split to fit the current `@sanity/types`
// setup. Classes are a bit weird in the `@sanity/types` package because classes
// create an actual javascript class while simultaneously creating a type
// definition.
//
// This implicitly creates two types:
// 1. the instance type — `Rule` and
// 2. the static/class type - `RuleClass`
//
// The `RuleClass` type contains the static methods and the `Rule` instance
// contains the instance methods.
//
// This package exports the RuleClass as a value without implicitly exporting
// an instance definition. This should help reminder downstream users to import
// from the `@sanity/types` package.
const Rule = class Rule {
    static FIELD_REF = FIELD_REF;
    static array = (def) => new Rule(def).type('Array');
    static object = (def) => new Rule(def).type('Object');
    static string = (def) => new Rule(def).type('String');
    static number = (def) => new Rule(def).type('Number');
    static boolean = (def) => new Rule(def).type('Boolean');
    static dateTime = (def) => new Rule(def).type('Date');
    static valueOfField = (path) => ({
        type: FIELD_REF,
        path,
    });
    _type = undefined;
    _level = undefined;
    _required = undefined;
    _typeDef = undefined;
    _message = undefined;
    _rules = [];
    _fieldRules = undefined;
    constructor(typeDef) {
        this._typeDef = typeDef;
        this.reset();
    }
    _mergeRequired(next) {
        if (this._required === 'required' || next._required === 'required')
            return 'required';
        if (this._required === 'optional' || next._required === 'optional')
            return 'optional';
        return undefined;
    }
    // Alias to static method, since we often have access to an _instance_ of a rule but not the actual Rule class
    valueOfField = Rule.valueOfField.bind(Rule);
    error(message) {
        const rule = this.clone();
        rule._level = 'error';
        rule._message = message || undefined;
        return rule;
    }
    warning(message) {
        const rule = this.clone();
        rule._level = 'warning';
        rule._message = message || undefined;
        return rule;
    }
    info(message) {
        const rule = this.clone();
        rule._level = 'info';
        rule._message = message || undefined;
        return rule;
    }
    reset() {
        this._type = this._type || undefined;
        this._rules = (this._rules || []).filter((rule) => rule.flag === 'type');
        this._message = undefined;
        this._required = undefined;
        this._level = 'error';
        this._fieldRules = undefined;
        return this;
    }
    isRequired() {
        return this._required === 'required';
    }
    clone() {
        const rule = new Rule();
        rule._type = this._type;
        rule._message = this._message;
        rule._required = this._required;
        rule._rules = cloneDeep(this._rules);
        rule._level = this._level;
        rule._fieldRules = this._fieldRules;
        rule._typeDef = this._typeDef;
        return rule;
    }
    cloneWithRules(rules) {
        const rule = this.clone();
        const newRules = new Set();
        rules.forEach((curr) => {
            if (curr.flag === 'type') {
                rule._type = curr.constraint;
            }
            newRules.add(curr.flag);
        });
        rule._rules = rule._rules
            .filter((curr) => {
            const disallowDuplicate = ['type', 'uri', 'email'].includes(curr.flag);
            const isDuplicate = newRules.has(curr.flag);
            return !(disallowDuplicate && isDuplicate);
        })
            .concat(rules);
        return rule;
    }
    merge(rule) {
        if (this._type && rule._type && this._type !== rule._type) {
            throw new Error('merge() failed: conflicting types');
        }
        const newRule = this.cloneWithRules(rule._rules);
        newRule._type = this._type || rule._type;
        newRule._message = this._message || rule._message;
        newRule._required = this._mergeRequired(rule);
        newRule._level = this._level === 'error' ? rule._level : this._level;
        return newRule;
    }
    // Validation flag setters
    type(targetType) {
        const type = `${targetType.slice(0, 1).toUpperCase()}${targetType.slice(1)}`;
        if (!ruleConstraintTypes$1.includes(type)) {
            throw new Error(`Unknown type "${targetType}"`);
        }
        const rule = this.cloneWithRules([{ flag: 'type', constraint: type }]);
        rule._type = type;
        return rule;
    }
    all(children) {
        return this.cloneWithRules([{ flag: 'all', constraint: children }]);
    }
    either(children) {
        return this.cloneWithRules([{ flag: 'either', constraint: children }]);
    }
    // Shared rules
    optional() {
        const rule = this.cloneWithRules([{ flag: 'presence', constraint: 'optional' }]);
        rule._required = 'optional';
        return rule;
    }
    required() {
        const rule = this.cloneWithRules([{ flag: 'presence', constraint: 'required' }]);
        rule._required = 'required';
        return rule;
    }
    custom(fn) {
        return this.cloneWithRules([{ flag: 'custom', constraint: fn }]);
    }
    /**
     * @deprecated use `Rule.custom` instead
     */
    block(fn) {
        return this.cloneWithRules([{ flag: 'custom', constraint: fn }]);
    }
    min(len) {
        return this.cloneWithRules([{ flag: 'min', constraint: len }]);
    }
    max(len) {
        return this.cloneWithRules([{ flag: 'max', constraint: len }]);
    }
    length(len) {
        return this.cloneWithRules([{ flag: 'length', constraint: len }]);
    }
    valid(value) {
        const values = Array.isArray(value) ? value : [value];
        return this.cloneWithRules([{ flag: 'valid', constraint: values }]);
    }
    // Numbers only
    integer() {
        return this.cloneWithRules([{ flag: 'integer' }]);
    }
    precision(limit) {
        return this.cloneWithRules([{ flag: 'precision', constraint: limit }]);
    }
    positive() {
        return this.cloneWithRules([{ flag: 'min', constraint: 0 }]);
    }
    negative() {
        return this.cloneWithRules([{ flag: 'lessThan', constraint: 0 }]);
    }
    greaterThan(num) {
        return this.cloneWithRules([{ flag: 'greaterThan', constraint: num }]);
    }
    lessThan(num) {
        return this.cloneWithRules([{ flag: 'lessThan', constraint: num }]);
    }
    // String only
    uppercase() {
        return this.cloneWithRules([{ flag: 'stringCasing', constraint: 'uppercase' }]);
    }
    lowercase() {
        return this.cloneWithRules([{ flag: 'stringCasing', constraint: 'lowercase' }]);
    }
    regex(pattern, a, b) {
        const name = typeof a === 'string' ? a : a?.name ?? b?.name;
        const invert = typeof a === 'string' ? false : a?.invert ?? b?.invert;
        const constraint = {
            pattern,
            name,
            invert: invert || false,
        };
        return this.cloneWithRules([{ flag: 'regex', constraint }]);
    }
    email() {
        return this.cloneWithRules([{ flag: 'email' }]);
    }
    uri(opts) {
        const optsScheme = opts?.scheme || ['http', 'https'];
        const schemes = Array.isArray(optsScheme) ? optsScheme : [optsScheme];
        if (!schemes.length) {
            throw new Error('scheme must have at least 1 scheme specified');
        }
        const constraint = {
            options: {
                scheme: schemes.map((scheme) => {
                    if (!(scheme instanceof RegExp) && typeof scheme !== 'string') {
                        throw new Error('scheme must be a RegExp or a String');
                    }
                    return typeof scheme === 'string' ? new RegExp(`^${escapeRegex(scheme)}$`) : scheme;
                }),
                allowRelative: opts?.allowRelative || false,
                relativeOnly: opts?.relativeOnly || false,
                allowCredentials: opts?.allowCredentials || false,
            },
        };
        return this.cloneWithRules([{ flag: 'uri', constraint }]);
    }
    // Array only
    unique() {
        return this.cloneWithRules([{ flag: 'unique' }]);
    }
    // Objects only
    reference() {
        return this.cloneWithRules([{ flag: 'reference' }]);
    }
    fields(rules) {
        if (this._type !== 'Object') {
            throw new Error('fields() can only be called on an object type');
        }
        const rule = this.cloneWithRules([]);
        rule._fieldRules = rules;
        return rule;
    }
    assetRequired() {
        const base = getBaseType(this._typeDef);
        let assetType;
        if (base && ['image', 'file'].includes(base.name)) {
            assetType = base.name === 'image' ? 'Image' : 'File';
        }
        else {
            assetType = 'Asset';
        }
        return this.cloneWithRules([{ flag: 'assetRequired', constraint: { assetType } }]);
    }
    async validate(value, context) {
        if (!context) {
            throw new Error('missing context');
        }
        const valueIsEmpty = value === null || value === undefined;
        // Short-circuit on optional, empty fields
        if (valueIsEmpty && this._required === 'optional') {
            return EMPTY_ARRAY;
        }
        const rules = 
        // Run only the _custom_ functions if the rule is not set to required or optional
        this._required === undefined && valueIsEmpty
            ? this._rules.filter((curr) => curr.flag === 'custom')
            : this._rules;
        const validators = (this._type && typeValidators[this._type]) || genericValidators;
        const results = await Promise.all(rules.map(async (curr) => {
            if (curr.flag === undefined) {
                throw new Error('Invalid rule, did not contain "flag"-property');
            }
            const validator = validators[curr.flag];
            if (!validator) {
                const forType = this._type ? `type "${this._type}"` : 'rule without declared type';
                throw new Error(`Validator for flag "${curr.flag}" not found for ${forType}`);
            }
            let specConstraint = 'constraint' in curr ? curr.constraint : null;
            if (isFieldRef(specConstraint)) {
                specConstraint = get(context.parent, specConstraint.path);
            }
            let result;
            try {
                result = await validator(specConstraint, value, this._message, context);
            }
            catch (err) {
                const errorFromException = new ValidationError(`${pathToString(context.path)}: Exception occurred while validating value: ${err.message}`);
                return convertToValidationMarker(errorFromException, 'error', context);
            }
            return convertToValidationMarker(result, this._level, context);
        }));
        return results.flat();
    }
};

// import getClient from '../getClient'
const memoizedWarnOnArraySlug = memoize(warnOnArraySlug);
function getDocumentIds(id) {
    const isDraft = id.indexOf('drafts.') === 0;
    return {
        published: isDraft ? id.slice('drafts.'.length) : id,
        draft: isDraft ? id : `drafts.${id}`,
    };
}
function serializePath(path) {
    return path.reduce((target, part, i) => {
        const isIndex = typeof part === 'number';
        const isKey = isKeyedObject(part);
        const separator = i === 0 ? '' : '.';
        const add = isIndex || isKey ? '[]' : `${separator}${part}`;
        return `${target}${add}`;
    }, '');
}
const defaultIsUnique = (slug, context) => {
    const { client, document, path, type } = context;
    const schemaOptions = type?.options;
    if (!document) {
        throw new Error(`\`document\` was not provided in validation context.`);
    }
    if (!path) {
        throw new Error(`\`path\` was not provided in validation context.`);
    }
    const disableArrayWarning = schemaOptions?.disableArrayWarning || false;
    const { published, draft } = getDocumentIds(document._id);
    const docType = document._type;
    const atPath = serializePath(path.concat('current'));
    if (!disableArrayWarning && atPath.includes('[]')) {
        memoizedWarnOnArraySlug(serializePath(path));
    }
    const constraints = [
        '_type == $docType',
        `!(_id in [$draft, $published])`,
        `${atPath} == $slug`,
    ].join(' && ');
    return client.fetch(`!defined(*[${constraints}][0]._id)`, {
        docType,
        draft,
        published,
        slug,
    }, { tag: 'validation.slug-is-unique' });
};
function warnOnArraySlug(serializedPath) {
    /* eslint-disable no-console */
    console.warn([
        `Slug field at path ${serializedPath} is within an array and cannot be automatically checked for uniqueness`,
        `If you need to check for uniqueness, provide your own "isUnique" method`,
        `To disable this message, set \`disableArrayWarning: true\` on the slug \`options\` field`,
    ].join('\n'));
    /* eslint-enable no-console */
}
/**
 * Validates slugs values by querying for uniqueness from the client.
 *
 * This is a custom rule implementation (e.g. `Rule.custom(slugValidator)`)
 * that's populated in `inferFromSchemaType` when the type name is `slug`
 */
const slugValidator = async (value, context) => {
    if (!value) {
        return true;
    }
    if (typeof value !== 'object') {
        return 'Slug must be an object';
    }
    const slugValue = value.current;
    if (!slugValue) {
        return 'Slug must have a value';
    }
    const options = context?.type?.options;
    const isUnique = options?.isUnique || defaultIsUnique;
    const wasUnique = await isUnique(slugValue, { ...context, defaultIsUnique });
    if (wasUnique) {
        return true;
    }
    return 'Slug is already in use';
};

const ruleConstraintTypes = {
    array: true,
    boolean: true,
    date: true,
    number: true,
    object: true,
    string: true,
};
const isRuleConstraint = (typeString) => typeString in ruleConstraintTypes;
function getTypeChain(type, visited) {
    if (!type)
        return [];
    if (visited.has(type))
        return [];
    visited.add(type);
    const next = type.type ? getTypeChain(type.type, visited) : [];
    return [...next, type];
}
function baseRuleReducer(inputRule, type) {
    let baseRule = inputRule;
    if (isRuleConstraint(type.jsonType)) {
        baseRule = baseRule.type(type.jsonType);
    }
    const typeOptionsList = 
    // if type.options is truthy
    type?.options &&
        // and type.options is an object (non-null from the previous)
        typeof type.options === 'object' &&
        // and if `list` is in options
        'list' in type.options &&
        // then finally access the list
        type.options.list;
    if (Array.isArray(typeOptionsList)) {
        baseRule = baseRule.valid(typeOptionsList.map((option) => extractValueFromListOption(option, type)));
    }
    if (type.name === 'datetime')
        return baseRule.type('Date');
    if (type.name === 'date')
        return baseRule.type('Date');
    if (type.name === 'url')
        return baseRule.uri();
    if (type.name === 'slug')
        return baseRule.custom(slugValidator);
    if (type.name === 'reference')
        return baseRule.reference();
    if (type.name === 'email')
        return baseRule.email();
    return baseRule;
}
function hasValueField(typeDef) {
    if (!typeDef)
        return false;
    if (!('fields' in typeDef) && typeDef.type)
        return hasValueField(typeDef.type);
    if (!('fields' in typeDef))
        return false;
    if (!Array.isArray(typeDef.fields))
        return false;
    return typeDef.fields.some((field) => field.name === 'value');
}
function extractValueFromListOption(option, typeDef) {
    // If you define a `list` option with object items, where the item has a `value` field,
    // we don't want to treat that as the value but rather the surrounding object
    // This differs from the case where you have a title/value pair setup for a string/number, for instance
    if (typeDef.jsonType === 'object' && hasValueField(typeDef))
        return option;
    return option.value === undefined
        ? option
        : option.value;
}
/**
 * Takes in `SchemaValidationValue` and returns an array of `Rule` instances.
 */
function normalizeValidationRules(typeDef) {
    if (!typeDef) {
        return [];
    }
    const validation = typeDef.validation;
    if (Array.isArray(validation)) {
        return validation.flatMap((i) => normalizeValidationRules({
            ...typeDef,
            validation: i,
        }));
    }
    if (validation instanceof Rule) {
        return [validation];
    }
    const baseRule = 
    // using an object + Object.values to de-dupe the type chain by type name
    Object.values(getTypeChain(typeDef, new Set()).reduce((acc, type) => {
        acc[type.name] = type;
        return acc;
    }, {})).reduce(baseRuleReducer, new Rule(typeDef));
    if (!validation) {
        return [baseRule];
    }
    return normalizeValidationRules({
        ...typeDef,
        validation: validation(baseRule),
    });
}

const isRecord = (maybeRecord) => typeof maybeRecord === 'object' && maybeRecord !== null && !Array.isArray(maybeRecord);
const isNonNullable = (value) => value !== null && value !== undefined;
/**
 * @internal
 */
function resolveTypeForArrayItem(item, candidates) {
    // if there is only one type available, assume that it's the correct one
    if (candidates.length === 1)
        return candidates[0];
    const itemType = isTypedObject(item) && item._type;
    const primitive = item === undefined || item === null || (!itemType && typeString(item).toLowerCase());
    if (primitive && primitive !== 'object') {
        return candidates.find((candidate) => candidate.jsonType === primitive);
    }
    return (candidates.find((candidate) => candidate.type?.name === itemType) ||
        candidates.find((candidate) => candidate.name === itemType) ||
        candidates.find((candidate) => candidate.name === 'object' && primitive === 'object'));
}
async function validateDocument(client, doc, schema, context) {
    const documentType = schema.get(doc._type);
    if (!documentType) {
        console.warn('Schema type for object type "%s" not found, skipping validation', doc._type);
        return [];
    }
    try {
        return await validateItem({
            client,
            parent: undefined,
            value: doc,
            path: [],
            document: doc,
            type: documentType,
            getDocumentExists: context?.getDocumentExists,
        });
    }
    catch (err) {
        console.error(err);
        return [
            {
                level: 'error',
                path: [],
                item: new ValidationError(err?.message),
            },
        ];
    }
}
async function validateItem({ value, type, path = [], parent, ...restOfContext }) {
    const rules = normalizeValidationRules(type);
    // run validation for the current value
    const selfChecks = rules.map((rule) => rule.validate(value, {
        ...restOfContext,
        parent,
        path,
        type,
    }));
    // run validation for nested values (conditionally)
    let nestedChecks = [];
    const selfIsRequired = rules.some((rule) => rule.isRequired());
    const shouldRunNestedObjectValidation = 
    // run nested validation for objects
    type?.jsonType === 'object' &&
        // if the value is truthy
        (!!value || // or
            // (the value is null or undefined) and the top-level value is required
            ((value === null || value === undefined) && selfIsRequired));
    if (shouldRunNestedObjectValidation) {
        const fieldTypes = type.fields.reduce((acc, field) => {
            acc[field.name] = field.type;
            return acc;
        }, {});
        // Validation for rules set at the object level with `Rule.fields({/* ... */})`
        nestedChecks = nestedChecks.concat(rules
            .map((rule) => rule._fieldRules)
            .filter(isNonNullable)
            .flatMap((fieldResults) => Object.entries(fieldResults))
            .flatMap(([name, validation]) => {
            const fieldType = fieldTypes[name];
            return normalizeValidationRules({ ...fieldType, validation }).map((subRule) => {
                const nestedValue = isRecord(value) ? value[name] : undefined;
                return subRule.validate(nestedValue, {
                    ...restOfContext,
                    parent: value,
                    path: path.concat(name),
                    type: fieldType,
                });
            });
        }));
        // Validation from each field's schema `validation: Rule => {/* ... */}` function
        nestedChecks = nestedChecks.concat(type.fields.map((field) => validateItem({
            ...restOfContext,
            parent: value,
            value: isRecord(value) ? value[field.name] : undefined,
            path: path.concat(field.name),
            type: field.type,
        })));
    }
    // note: unlike objects, arrays should not run nested validation for undefined
    // values because we won't have a valid path to put a marker (i.e. missing the
    // key or index in the path) and the downstream form builder won't have a
    // valid target component
    const shouldRunNestedValidationForArrays = type?.jsonType === 'array' && Array.isArray(value);
    if (shouldRunNestedValidationForArrays) {
        nestedChecks = nestedChecks.concat(value.map((item) => validateItem({
            ...restOfContext,
            parent: value,
            value: item,
            path: path.concat(isKeyedObject(item) ? { _key: item._key } : value.indexOf(item)),
            type: resolveTypeForArrayItem(item, type.of),
        })));
    }
    // markDefs also do no run nested validation if the parent object is undefined
    // for a similar reason to arrays
    const shouldRunNestedValidationForMarkDefs = isBlock(value) && value.markDefs.length && isBlockSchemaType(type);
    if (shouldRunNestedValidationForMarkDefs) {
        const [spanChildrenField] = type.fields;
        const spanType = spanChildrenField.type.of.find(isSpanSchemaType);
        const annotations = (spanType?.annotations || []).reduce((map, annotationType) => {
            map.set(annotationType.name, annotationType);
            return map;
        }, new Map());
        nestedChecks = nestedChecks.concat(value.markDefs.map((markDef) => validateItem({
            ...restOfContext,
            parent: value,
            value: markDef,
            path: path.concat(['markDefs', { _key: markDef._key }]),
            type: annotations.get(markDef._type),
        })));
    }
    const results = (await Promise.all([...selfChecks, ...nestedChecks])).flat();
    // run `uniqBy` if `_fieldRules` are present because they can
    // cause repeat markers
    if (rules.some((rule) => rule._fieldRules)) {
        return uniqBy(results, (rule) => JSON.stringify(rule));
    }
    return results;
}

function traverse(typeDef, visited) {
    if (visited.has(typeDef)) {
        return;
    }
    visited.add(typeDef);
    typeDef.validation = normalizeValidationRules(typeDef);
    if ('fields' in typeDef) {
        for (const field of typeDef.fields) {
            traverse(field.type, visited);
        }
    }
    if ('of' in typeDef) {
        for (const candidate of typeDef.of) {
            traverse(candidate, visited);
        }
    }
    // eslint-disable-next-line no-warning-comments
    // @ts-expect-error TODO (eventually): `annotations` does not exist on the SchemaType yet
    if (typeDef.annotations) {
        // eslint-disable-next-line no-warning-comments
        // @ts-expect-error TODO (eventually): `annotations` does not exist on the SchemaType yet
        for (const annotation of typeDef.annotations) {
            traverse(annotation, visited);
        }
    }
}
function inferFromSchemaType(typeDef) {
    traverse(typeDef, new Set());
    return typeDef;
}

// Note: Mutates schema. Refactor when @sanity/schema supports middlewares
function inferFromSchema(schema) {
    const typeNames = schema.getTypeNames();
    typeNames.forEach((typeName) => {
        const schemaType = schema.get(typeName);
        if (schemaType) {
            inferFromSchemaType(schemaType);
        }
    });
    return schema;
}

var index = { Rule: Rule, validateDocument, inferFromSchema, inferFromSchemaType };

export { Rule, index as default, inferFromSchema, inferFromSchemaType, validateDocument };
//# sourceMappingURL=index.js.map
