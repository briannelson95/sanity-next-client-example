import { jsx, Fragment } from 'react/jsx-runtime';
import { useLayoutEffect as useLayoutEffect$1, useEffect, useState, useMemo, useRef, useCallback } from 'react';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var ratio = function ratio(_ref) {
  var width = _ref.width,
      height = _ref.height;
  return width / height;
};

// round a value to a specified number of decimal places
var round = function round(value, decimals) {
  if (decimals === void 0) {
    decimals = 0;
  }

  var factor = Math.pow(10, decimals);
  return Math.round((value + Number.EPSILON) * factor) / factor;
};

var RankingFunctionComparator = function RankingFunctionComparator(rank) {
  return function (a, b) {
    return rank(b) - rank(a);
  };
};
/**
 * Min heap implementation.
 * Comparator function is expected to return a positive number, zero or a negative number if a > b, a === b or a < b.
 */

var MinHeap = function MinHeap(comparator) {
  // heap-ordered complete binary tree in heap[1..n] with heap[0] unused
  var heap = [];
  var compare = comparator;
  var n = 0; // comparator function

  var greater = function greater(i, j) {
    return compare(heap[i], heap[j]) < 0;
  }; // swap two elements


  var swap = function swap(i, j) {
    var temp = heap[i];
    heap[i] = heap[j];
    heap[j] = temp;
  }; // bubble k-th element up


  var swim = function swim(k) {
    var k2 = k >> 1;

    while (k > 1 && greater(k2, k)) {
      swap(k2, k);
      k = k2;
      k2 = k >> 1;
    }
  }; // bubble k-th element down


  var sink = function sink(k) {
    var j = k << 1;

    while (j <= n) {
      if (j < n && greater(j, j + 1)) j++;
      if (!greater(k, j)) break;
      swap(k, j);
      k = j;
      j = k << 1;
    }
  };

  return {
    /** add element to the heap */
    push: function push(element) {
      n += 1;
      heap[n] = element;
      swim(n);
    },

    /** remove the first element from the heap */
    pop: function pop() {
      if (n === 0) return undefined;
      swap(1, n);
      n -= 1;
      var max = heap.pop();
      sink(1);
      return max;
    },

    /** heap size */
    size: function size() {
      return n;
    }
  };
};

var buildPrecedentsMap = function buildPrecedentsMap(graph, startNode, endNode) {
  // store the previous vertex of the shortest path of arrival
  var precedentsMap = {}; // store nodes already visited

  var visited = {}; // store/update only the shortest edge weights measured
  // the purpose of this is object is constant time lookup vs. binary heap lookup O(n)

  var storedShortestPaths = {};
  storedShortestPaths[startNode] = 0; // priority queue of ALL nodes and storedShortestPaths
  // don't bother to delete them because it's faster to look at visited?

  var pQueue = MinHeap(RankingFunctionComparator(function (el) {
    return el.weight;
  }));
  pQueue.push({
    id: startNode,
    weight: 0
  });
  var shortestNode; // pop a node with the shortest total weight from start node

  while ((shortestNode = pQueue.pop()) !== undefined) {
    var shortestNodeId = shortestNode.id; // if already visited, continue

    if (visited[shortestNodeId]) continue; // visit neighboring nodes

    var neighboringNodes = graph(shortestNodeId);
    visited[shortestNodeId] = 1; // meet the neighbors, looking for shorter paths

    for (var neighbor in neighboringNodes) {
      // weight of path from startNode to this neighbor
      var newTotalWeight = shortestNode.weight + neighboringNodes[neighbor]; // if this is the first time meeting the neighbor OR if the new total weight from
      // start node to this neighbor node is greater than the old weight path, update it,
      // and update precedent node
      //
      // introducing deterministic tiebreaker to guard against edge cases where path weight difference can be
      // as low as 1e-12, which leads to visual flickering during subsequent re-renders as layout continues to
      // shift back and forth

      if (storedShortestPaths[neighbor] === undefined || storedShortestPaths[neighbor] > newTotalWeight && (storedShortestPaths[neighbor] / newTotalWeight > 1.005 || precedentsMap[neighbor] < shortestNodeId)) {
        storedShortestPaths[neighbor] = newTotalWeight;
        pQueue.push({
          id: neighbor,
          weight: newTotalWeight
        });
        precedentsMap[neighbor] = shortestNodeId;
      }
    }
  }

  if (typeof storedShortestPaths[endNode] === "undefined") {
    // encountered impossible layout
    return undefined;
  }

  return precedentsMap;
}; // build the route from precedent node vertices


var getPathFromPrecedentsMap = function getPathFromPrecedentsMap(precedentsMap, endNode) {
  var nodes = [];
  var n = endNode;

  while (n) {
    nodes.push(n);
    n = precedentsMap[n];
  }

  return nodes.reverse();
}; // build the precedentsMap and find the shortest path from it


var findShortestPath = function findShortestPath(graph, startNode, endNode) {
  var precedentsMap = buildPrecedentsMap(graph, startNode, endNode);
  return precedentsMap !== undefined ? getPathFromPrecedentsMap(precedentsMap, endNode) : undefined;
};

// the aspect columnRatio of the container with images and minimal aspect columnRatio of all photos
// as the maximum amount of photos per row, plus some nodes

var findIdealNodeSearch = function findIdealNodeSearch(_ref) {
  var photos = _ref.photos,
      targetRowHeight = _ref.targetRowHeight,
      containerWidth = _ref.containerWidth;
  var minRatio = photos.reduce(function (acc, photo) {
    return Math.min(ratio(photo), acc);
  }, Number.MAX_VALUE);
  return round(containerWidth / targetRowHeight / minRatio) + 2;
}; // compute sizes by creating a graph with rows as edges and photo to break on as nodes
// to calculate the single best layout using Dijkstra's findShortestPat
// get the height for a set of photos in a potential row


var getCommonHeight = function getCommonHeight(row, containerWidth, spacing, padding) {
  var rowWidth = containerWidth - (row.length - 1) * spacing - 2 * padding * row.length;
  var totalAspectRatio = row.reduce(function (acc, photo) {
    return acc + ratio(photo);
  }, 0);
  return rowWidth / totalAspectRatio;
}; // calculate the cost of breaking at this node (edge weight)


var cost = function cost(photos, i, j, width, targetRowHeight, spacing, padding) {
  var row = photos.slice(i, j);
  var commonHeight = getCommonHeight(row, width, spacing, padding);
  return commonHeight > 0 ? Math.pow(commonHeight - targetRowHeight, 2) * row.length : undefined;
}; // return function that gets the neighboring nodes of node and returns costs


var makeGetNeighbors$1 = function makeGetNeighbors(_ref2) {
  var photos = _ref2.photos,
      layoutOptions = _ref2.layoutOptions,
      targetRowHeight = _ref2.targetRowHeight,
      limitNodeSearch = _ref2.limitNodeSearch,
      rowConstraints = _ref2.rowConstraints,
      instrumentation = _ref2.instrumentation;
  return function (node) {
    var _a, _b;

    var containerWidth = layoutOptions.containerWidth,
        spacing = layoutOptions.spacing,
        padding = layoutOptions.padding;
    var results = {};
    var start = +node;
    results[+start] = 0;
    var startOffset = (_a = rowConstraints === null || rowConstraints === void 0 ? void 0 : rowConstraints.minPhotos) !== null && _a !== void 0 ? _a : 1;
    var endOffset = Math.min(limitNodeSearch, (_b = rowConstraints === null || rowConstraints === void 0 ? void 0 : rowConstraints.maxPhotos) !== null && _b !== void 0 ? _b : Infinity);

    for (var i = start + startOffset; i < photos.length + 1; i += 1) {
      if (i - start > endOffset && !(instrumentation === null || instrumentation === void 0 ? void 0 : instrumentation.fullGraphSearch)) break;
      var currentCost = cost(photos, start, i, containerWidth, targetRowHeight, spacing, padding);
      if (currentCost === undefined) break;
      results[i.toString()] = currentCost;
    }

    return results;
  };
};

var computeRowsLayout = function computeRowsLayout(_ref3) {
  var photos = _ref3.photos,
      layoutOptions = _ref3.layoutOptions,
      instrumentation = _ref3.instrumentation;

  var _a, _b;

  var spacing = layoutOptions.spacing,
      padding = layoutOptions.padding,
      containerWidth = layoutOptions.containerWidth,
      targetRowHeight = layoutOptions.targetRowHeight,
      rowConstraints = layoutOptions.rowConstraints;
  (_a = instrumentation === null || instrumentation === void 0 ? void 0 : instrumentation.onStartLayoutComputation) === null || _a === void 0 ? void 0 : _a.call(instrumentation);
  var limitNodeSearch = findIdealNodeSearch({
    photos: photos,
    containerWidth: containerWidth,
    targetRowHeight: targetRowHeight
  });
  var getNeighbors = makeGetNeighbors$1({
    photos: photos,
    layoutOptions: layoutOptions,
    targetRowHeight: targetRowHeight,
    limitNodeSearch: limitNodeSearch,
    rowConstraints: rowConstraints,
    instrumentation: instrumentation
  });
  var path = findShortestPath(getNeighbors, "0", "" + photos.length); // impossible layout

  if (path === undefined) return undefined;
  var result = [];

  var _loop = function _loop(i) {
    var row = photos.map(function (photo, index) {
      return {
        photo: photo,
        index: index
      };
    }).slice(+path[i - 1], +path[i]);
    var height = getCommonHeight(row.map(function (_ref4) {
      var photo = _ref4.photo;
      return photo;
    }), containerWidth, spacing, padding);
    result.push(row.map(function (_ref5, photoIndex) {
      var photo = _ref5.photo,
          index = _ref5.index;
      return {
        photo: photo,
        layout: {
          height: height,
          width: height * ratio(photo),
          index: index,
          photoIndex: photoIndex,
          photosCount: row.length
        }
      };
    }));
  };

  for (var i = 1; i < path.length; i += 1) {
    _loop(i);
  }

  (_b = instrumentation === null || instrumentation === void 0 ? void 0 : instrumentation.onFinishLayoutComputation) === null || _b === void 0 ? void 0 : _b.call(instrumentation, result);
  return result;
};

var _excluded$3 = ["src", "alt", "srcSet", "sizes"],
    _excluded2$1 = ["style"];

var calcWidth = function calcWidth(base, _ref, _ref2) {
  var width = _ref.width,
      photosCount = _ref.photosCount;
  var spacing = _ref2.spacing,
      padding = _ref2.padding,
      containerWidth = _ref2.containerWidth;
  var gaps = spacing * (photosCount - 1) + 2 * padding * photosCount;
  return "calc((" + base + " - " + gaps + "px) / " + round((containerWidth - gaps) / width, 5) + ")";
};

var cssWidth$1 = function cssWidth(layout, layoutOptions) {
  if (layoutOptions.layout !== "rows") {
    return "calc(100% - " + 2 * layoutOptions.padding + "px)";
  }

  return calcWidth("100%", layout, layoutOptions);
};

var calculateSizesValue = function calculateSizesValue(size, layout, layoutOptions) {
  var _a, _b;

  return calcWidth((_b = (_a = size.match(/calc\((.*)\)/)) === null || _a === void 0 ? void 0 : _a[1]) !== null && _b !== void 0 ? _b : size, layout, layoutOptions);
};

var srcSetAndSizes = function srcSetAndSizes(photo, layout, layoutOptions) {
  var srcSet, sizes;

  if (photo.images && photo.images.length > 0) {
    srcSet = photo.images.concat([{
      src: photo.src,
      width: photo.width,
      height: photo.height
    }]).sort(function (first, second) {
      return first.width - second.width;
    }).map(function (image) {
      return image.src + " " + image.width + "w";
    }).join(", ");
  }

  if (layoutOptions.sizes) {
    sizes = (layoutOptions.sizes.sizes || []).map(function (_ref3) {
      var viewport = _ref3.viewport,
          size = _ref3.size;
      return viewport + " " + calculateSizesValue(size, layout, layoutOptions);
    }).concat(calculateSizesValue(layoutOptions.sizes.size, layout, layoutOptions)).join(", ");
  } else {
    sizes = Math.ceil(layout.width / (layoutOptions.viewportWidth || layoutOptions.containerWidth) * 100) + "vw";
  }

  return {
    srcSet: srcSet,
    sizes: sizes
  };
};

var defaultRenderPhoto = function defaultRenderPhoto(_ref4) {
  var imageProps = _ref4.imageProps;

  var src = imageProps.src,
      alt = imageProps.alt,
      srcSet = imageProps.srcSet,
      sizes = imageProps.sizes,
      rest = _objectWithoutPropertiesLoose(imageProps, _excluded$3);

  return jsx("img", _extends({
    src: src,
    alt: alt
  }, srcSet ? {
    srcSet: srcSet,
    sizes: sizes
  } : null, rest));
};

var PhotoRenderer = function PhotoRenderer(props) {
  var _a;

  var photo = props.photo,
      layout = props.layout,
      layoutOptions = props.layoutOptions,
      _props$imageProps = props.imageProps;
  _props$imageProps = _props$imageProps === void 0 ? {} : _props$imageProps;

  var style = _props$imageProps.style,
      restImageProps = _objectWithoutPropertiesLoose(_props$imageProps, _excluded2$1),
      renderPhoto = props.renderPhoto;

  var onClick = layoutOptions.onClick;

  var imageStyle = _extends({
    display: "block",
    boxSizing: "content-box",
    width: cssWidth$1(layout, layoutOptions),
    height: "auto",
    aspectRatio: photo.width + " / " + photo.height
  }, layoutOptions.padding ? {
    padding: layoutOptions.padding + "px"
  } : null, (layoutOptions.layout === "columns" || layoutOptions.layout === "masonry") && layout.photoIndex < layout.photosCount - 1 ? {
    marginBottom: layoutOptions.spacing + "px"
  } : null, onClick ? {
    cursor: "pointer"
  } : null, style);

  var handleClick = onClick ? function (event) {
    onClick(event, photo, layout.index);
  } : undefined;

  var imageProps = _extends({
    src: photo.src,
    alt: (_a = photo.alt) !== null && _a !== void 0 ? _a : "",
    title: photo.title,
    onClick: handleClick,
    style: imageStyle,
    className: "react-photo-album--photo"
  }, srcSetAndSizes(photo, layout, layoutOptions), restImageProps);

  return (renderPhoto !== null && renderPhoto !== void 0 ? renderPhoto : defaultRenderPhoto)({
    photo: photo,
    layout: layout,
    layoutOptions: layoutOptions,
    imageProps: imageProps
  });
};

var _excluded$2 = ["style"];

var defaultRenderRowContainer = function defaultRenderRowContainer(_ref) {
  var rowContainerProps = _ref.rowContainerProps,
      children = _ref.children;
  return jsx("div", _extends({}, rowContainerProps, {
    children: children
  }));
};

var RowContainerRenderer = function RowContainerRenderer(props) {
  var layoutOptions = props.layoutOptions,
      rowIndex = props.rowIndex,
      rowsCount = props.rowsCount,
      renderRowContainer = props.renderRowContainer,
      _props$rowContainerPr = props.rowContainerProps;
  _props$rowContainerPr = _props$rowContainerPr === void 0 ? {} : _props$rowContainerPr;

  var style = _props$rowContainerPr.style,
      restRowContainerProps = _objectWithoutPropertiesLoose(_props$rowContainerPr, _excluded$2),
      children = props.children;

  var rowContainerProps = _extends({
    className: "react-photo-album--row",
    style: _extends({
      display: "flex",
      flexDirection: "row",
      flexWrap: "nowrap",
      alignItems: "flex-start",
      justifyContent: "space-between"
    }, rowIndex < rowsCount - 1 ? {
      marginBottom: layoutOptions.spacing + "px"
    } : null, style)
  }, restRowContainerProps);

  return (renderRowContainer !== null && renderRowContainer !== void 0 ? renderRowContainer : defaultRenderRowContainer)({
    layoutOptions: layoutOptions,
    rowIndex: rowIndex,
    rowsCount: rowsCount,
    rowContainerProps: rowContainerProps,
    children: children
  });
};

var RowsLayout = function RowsLayout(props) {
  var photos = props.photos,
      layoutOptions = props.layoutOptions,
      renderPhoto = props.renderPhoto,
      renderRowContainer = props.renderRowContainer,
      componentsProps = props.componentsProps,
      instrumentation = props.instrumentation;
  var rowsLayout = computeRowsLayout({
    photos: photos,
    layoutOptions: layoutOptions,
    instrumentation: instrumentation
  });
  if (rowsLayout === undefined) return jsx(Fragment, {});
  return jsx(Fragment, {
    children: rowsLayout.map(function (row, rowIndex) {
      return jsx(RowContainerRenderer, {
        layoutOptions: layoutOptions,
        rowIndex: rowIndex,
        rowsCount: rowsLayout.length,
        renderRowContainer: renderRowContainer,
        rowContainerProps: componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.rowContainerProps,
        children: row.map(function (_ref) {
          var photo = _ref.photo,
              layout = _ref.layout;
          return jsx(PhotoRenderer, {
            photo: photo,
            layout: layout,
            layoutOptions: layoutOptions,
            renderPhoto: renderPhoto,
            imageProps: componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.imageProps
          }, photo.key || photo.src);
        })
      }, "row-" + rowIndex);
    })
  });
};

var computeShortestPath = function computeShortestPath(graph, pathLength, startNode, endNode) {
  var _;

  // computation matrix: node id x path length x [previous node id, path weight]
  // i.e. element in comp[X][k] represents previous node and path weight of the best path of length k
  // from the starting node to node X
  var comp = []; // sorted set of neighboring nodes that need to be visited
  // i.e. queue[k][X] represents node X with partial path of length k

  var queue = {
    0: (_ = {}, _[startNode] = null, _)
  };

  var _loop = function _loop(length) {
    Object.keys(queue[length]).forEach(function (n) {
      var node = +n;
      var accumulatedWeight = length > 0 && comp[node][length] ? comp[node][length][1] : 0;
      graph(node).forEach(function (_ref) {
        var neighbor = _ref.neighbor,
            weight = _ref.weight;

        if (!comp[neighbor]) {
          comp[neighbor] = [];
        } // introducing deterministic tiebreaker to guard against edge cases where path weight difference can be
        // as low as 1e-12, which leads to visual flickering during subsequent re-renders as layout continues to
        // shift back and forth


        var newTotalWeight = accumulatedWeight + weight;

        if (!comp[neighbor][length + 1] || comp[neighbor][length + 1][1] > newTotalWeight && (comp[neighbor][length + 1][1] / newTotalWeight > 1.0001 || node < comp[neighbor][length + 1][0])) {
          comp[neighbor][length + 1] = [node, newTotalWeight];
        }

        if (length < pathLength - 1 && neighbor !== endNode) {
          if (!queue[length + 1]) {
            queue[length + 1] = {};
          }

          queue[length + 1][neighbor] = null;
        }
      });
    });
  };

  for (var length = 0; length < pathLength; length += 1) {
    _loop(length);
  }

  return comp;
};

var reconstructShortestPath = function reconstructShortestPath(comp, pathLength, endNode) {
  var path = [endNode];

  for (var node = endNode, length = pathLength; length > 0; length -= 1) {
    var _comp$node$length = comp[node][length],
        prevNode = _comp$node$length[0];
    node = prevNode;
    path.push(node);
  }

  return path.reverse();
}; // Find the shortest path of length N in a weighted directed graph using dynamic programming algorithm.


var findShortestPathLengthN = function findShortestPathLengthN(graph, pathLength, startNode, endNode) {
  return reconstructShortestPath(computeShortestPath(graph, pathLength, startNode, endNode), pathLength, endNode);
};

var makeGetNeighbors = function makeGetNeighbors(_ref) {
  var photos = _ref.photos,
      spacing = _ref.spacing,
      padding = _ref.padding,
      targetColumnWidth = _ref.targetColumnWidth,
      targetColumnHeight = _ref.targetColumnHeight,
      instrumentation = _ref.instrumentation;
  return function (node) {
    var results = [];
    var cutOffHeight = targetColumnHeight * 1.5;
    var height = targetColumnWidth / ratio(photos[node]) + 2 * padding;

    for (var i = node + 1; i < photos.length + 1; i += 1) {
      results.push({
        neighbor: i,
        weight: Math.pow(targetColumnHeight - height, 2)
      });

      if (height > cutOffHeight && !(instrumentation === null || instrumentation === void 0 ? void 0 : instrumentation.fullGraphSearch) || i === photos.length) {
        break;
      }

      height += targetColumnWidth / ratio(photos[i]) + spacing + 2 * padding;
    }

    return results;
  };
};

var buildColumnsModel = function buildColumnsModel(_ref2) {
  var path = _ref2.path,
      photos = _ref2.photos,
      containerWidth = _ref2.containerWidth,
      columnsGaps = _ref2.columnsGaps,
      columnsRatios = _ref2.columnsRatios,
      spacing = _ref2.spacing,
      padding = _ref2.padding;
  var columnsModel = [];
  var totalRatio = columnsRatios.reduce(function (acc, ratio) {
    return acc + ratio;
  }, 0);

  var _loop = function _loop(i) {
    var column = photos.map(function (photo, index) {
      return {
        photo: photo,
        index: index
      };
    }).slice(path[i], path[i + 1]);
    var totalAdjustedGaps = columnsRatios.reduce(function (acc, ratio, index) {
      return acc + (columnsGaps[i] - columnsGaps[index]) * ratio;
    }, 0);
    var columnWidth = (containerWidth - (path.length - 2) * spacing - 2 * (path.length - 1) * padding - totalAdjustedGaps) * columnsRatios[i] / totalRatio;
    columnsModel.push(column.map(function (_ref3, photoIndex) {
      var photo = _ref3.photo,
          index = _ref3.index;
      return {
        photo: photo,
        layout: {
          width: columnWidth,
          height: columnWidth / ratio(photo),
          index: index,
          photoIndex: photoIndex,
          photosCount: column.length
        }
      };
    }));
  };

  for (var i = 0; i < path.length - 1; i += 1) {
    _loop(i);
  }

  return columnsModel;
};

var computeColumnsModel = function computeColumnsModel(_ref4) {
  var photos = _ref4.photos,
      layoutOptions = _ref4.layoutOptions,
      targetColumnWidth = _ref4.targetColumnWidth,
      instrumentation = _ref4.instrumentation;
  var columns = layoutOptions.columns,
      spacing = layoutOptions.spacing,
      padding = layoutOptions.padding,
      containerWidth = layoutOptions.containerWidth;
  var columnsGaps = [];
  var columnsRatios = []; // fill first available columns if there are not enough photos

  if (photos.length <= columns) {
    for (var index = 0; index < photos.length; index += 1) {
      columnsGaps[index] = 2 * padding;
      columnsRatios[index] = ratio(photos[index]);
    }

    var _columnsModel = buildColumnsModel({
      path: Array.from({
        length: photos.length + 1
      }).map(function (_, index) {
        return index;
      }),
      photos: photos,
      columnsRatios: columnsRatios,
      columnsGaps: columnsGaps,
      containerWidth: containerWidth,
      spacing: spacing,
      padding: padding
    });

    return {
      columnsGaps: columnsGaps,
      columnsRatios: columnsRatios,
      columnsModel: _columnsModel
    };
  } // target column height including spacing and padding


  var targetColumnHeight = (photos.reduce(function (acc, photo) {
    return acc + targetColumnWidth / ratio(photo);
  }, 0) + spacing * (photos.length - columns) + 2 * padding * photos.length) / columns;
  var getNeighbors = makeGetNeighbors({
    photos: photos,
    targetColumnWidth: targetColumnWidth,
    targetColumnHeight: targetColumnHeight,
    spacing: spacing,
    padding: padding,
    instrumentation: instrumentation
  });
  var path = findShortestPathLengthN(getNeighbors, columns, 0, photos.length).map(function (node) {
    return +node;
  });

  for (var i = 0; i < path.length - 1; i += 1) {
    var column = photos.slice(path[i], path[i + 1]);
    columnsGaps[i] = spacing * (column.length - 1) + 2 * padding * column.length;
    columnsRatios[i] = 1 / column.reduce(function (acc, photo) {
      return acc + 1 / ratio(photo);
    }, 0);
  }

  var columnsModel = buildColumnsModel({
    path: path,
    photos: photos,
    columnsRatios: columnsRatios,
    columnsGaps: columnsGaps,
    containerWidth: containerWidth,
    spacing: spacing,
    padding: padding
  });
  return {
    columnsGaps: columnsGaps,
    columnsRatios: columnsRatios,
    columnsModel: columnsModel
  };
};

var computeLayout = function computeLayout(props) {
  var photos = props.photos,
      layoutOptions = props.layoutOptions,
      instrumentation = props.instrumentation;
  var columns = layoutOptions.columns,
      spacing = layoutOptions.spacing,
      padding = layoutOptions.padding,
      containerWidth = layoutOptions.containerWidth;
  var targetColumnWidth = (containerWidth - spacing * (columns - 1) - 2 * padding * columns) / columns;

  var _computeColumnsModel = computeColumnsModel({
    photos: photos,
    layoutOptions: layoutOptions,
    targetColumnWidth: targetColumnWidth,
    instrumentation: instrumentation
  }),
      columnsGaps = _computeColumnsModel.columnsGaps,
      columnsRatios = _computeColumnsModel.columnsRatios,
      columnsModel = _computeColumnsModel.columnsModel;

  if (columnsModel.findIndex(function (columnModel) {
    return columnModel.findIndex(function (_ref5) {
      var _ref5$layout = _ref5.layout,
          width = _ref5$layout.width,
          height = _ref5$layout.height;
      return width < 0 || height < 0;
    }) >= 0;
  }) >= 0) {
    // encountered impossible layout
    if (columns > 1) {
      // will try to find a solution recursively with fewer columns
      return computeLayout({
        photos: photos,
        layoutOptions: _extends({}, layoutOptions, {
          columns: columns - 1
        }),
        instrumentation: instrumentation
      });
    } else {
      // bailing out
      return undefined;
    }
  }

  return {
    columnsModel: columnsModel,
    columnsGaps: columnsGaps,
    columnsRatios: columnsRatios
  };
};

var computeColumnsLayout = function computeColumnsLayout(_ref6) {
  var photos = _ref6.photos,
      layoutOptions = _ref6.layoutOptions,
      instrumentation = _ref6.instrumentation;

  var _a, _b;

  (_a = instrumentation === null || instrumentation === void 0 ? void 0 : instrumentation.onStartLayoutComputation) === null || _a === void 0 ? void 0 : _a.call(instrumentation);
  var result = computeLayout({
    photos: photos,
    layoutOptions: _extends({}, layoutOptions, {
      columns: Math.min(layoutOptions.columns, photos.length)
    }),
    instrumentation: instrumentation
  });
  (_b = instrumentation === null || instrumentation === void 0 ? void 0 : instrumentation.onFinishLayoutComputation) === null || _b === void 0 ? void 0 : _b.call(instrumentation, result);
  return result;
};

var _excluded$1 = ["style"],
    _excluded2 = ["layoutOptions", "renderColumnContainer", "children", "columnContainerProps"];

var defaultRenderColumnContainer = function defaultRenderColumnContainer(_ref) {
  var columnContainerProps = _ref.columnContainerProps,
      children = _ref.children;
  return jsx("div", _extends({}, columnContainerProps, {
    children: children
  }));
};

var cssWidth = function cssWidth(props) {
  var layoutOptions = props.layoutOptions,
      columnIndex = props.columnIndex,
      columnsCount = props.columnsCount,
      columnsGaps = props.columnsGaps,
      columnsRatios = props.columnsRatios;
  var layout = layoutOptions.layout,
      spacing = layoutOptions.spacing,
      padding = layoutOptions.padding;

  if (layout === "masonry" || !columnsGaps || !columnsRatios) {
    return "calc((100% - " + spacing * (columnsCount - 1) + "px) / " + columnsCount + ")";
  }

  var totalRatio = columnsRatios.reduce(function (acc, ratio) {
    return acc + ratio;
  }, 0);
  var totalAdjustedGaps = columnsRatios.reduce(function (acc, ratio, index) {
    return acc + (columnsGaps[columnIndex] - columnsGaps[index]) * ratio;
  }, 0);
  return "calc((100% - " + round((columnsCount - 1) * spacing + 2 * columnsCount * padding + totalAdjustedGaps, 3) + "px) * " + round(columnsRatios[columnIndex] / totalRatio, 5) + " + " + 2 * padding + "px)";
};

var ColumnContainerRenderer = function ColumnContainerRenderer(props) {
  var layoutOptions = props.layoutOptions,
      renderColumnContainer = props.renderColumnContainer,
      children = props.children,
      _props$columnContaine = props.columnContainerProps;
  _props$columnContaine = _props$columnContaine === void 0 ? {} : _props$columnContaine;

  var style = _props$columnContaine.style,
      restColumnContainerProps = _objectWithoutPropertiesLoose(_props$columnContaine, _excluded$1),
      rest = _objectWithoutPropertiesLoose(props, _excluded2);

  var columnContainerProps = _extends({
    className: "react-photo-album--column",
    style: _extends({
      display: "flex",
      flexDirection: "column",
      flexWrap: "nowrap",
      alignItems: "flex-start",
      width: cssWidth(props),
      justifyContent: layoutOptions.layout === "columns" ? "space-between" : "flex-start"
    }, style)
  }, restColumnContainerProps);

  return (renderColumnContainer !== null && renderColumnContainer !== void 0 ? renderColumnContainer : defaultRenderColumnContainer)(_extends({
    layoutOptions: layoutOptions,
    columnContainerProps: columnContainerProps,
    children: children
  }, rest));
};

var ColumnsLayout = function ColumnsLayout(props) {
  var photos = props.photos,
      layoutOptions = props.layoutOptions,
      renderPhoto = props.renderPhoto,
      renderColumnContainer = props.renderColumnContainer,
      componentsProps = props.componentsProps,
      instrumentation = props.instrumentation;
  var columnsLayout = computeColumnsLayout({
    photos: photos,
    layoutOptions: layoutOptions,
    instrumentation: instrumentation
  });
  if (columnsLayout === undefined) return jsx(Fragment, {});
  var columnsModel = columnsLayout.columnsModel,
      columnsRatios = columnsLayout.columnsRatios,
      columnsGaps = columnsLayout.columnsGaps;
  return jsx(Fragment, {
    children: columnsModel.map(function (column, columnIndex) {
      return jsx(ColumnContainerRenderer, {
        layoutOptions: layoutOptions,
        columnIndex: columnIndex,
        columnsCount: columnsModel.length,
        columnsGaps: columnsGaps,
        columnsRatios: columnsRatios,
        renderColumnContainer: renderColumnContainer,
        columnContainerProps: componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.columnContainerProps,
        children: column.map(function (_ref) {
          var photo = _ref.photo,
              layout = _ref.layout;
          return jsx(PhotoRenderer, {
            photo: photo,
            layout: layout,
            layoutOptions: layoutOptions,
            renderPhoto: renderPhoto,
            imageProps: componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.imageProps
          }, photo.key || photo.src);
        })
      }, "column-" + columnIndex);
    })
  });
};

var computeMasonryLayout = function computeMasonryLayout(props) {
  var _a, _b;

  var photos = props.photos,
      layoutOptions = props.layoutOptions,
      instrumentation = props.instrumentation;
  var spacing = layoutOptions.spacing,
      padding = layoutOptions.padding,
      containerWidth = layoutOptions.containerWidth;
  var columns = Math.min(layoutOptions.columns, photos.length);
  (_a = instrumentation === null || instrumentation === void 0 ? void 0 : instrumentation.onStartLayoutComputation) === null || _a === void 0 ? void 0 : _a.call(instrumentation); // calculate column width based on total width and columns count

  var columnWidth = (containerWidth - spacing * (columns - 1) - 2 * padding * columns) / columns; // encountered impossible layout

  if (columnWidth <= 0) {
    // will try to find a solution recursively with fewer columns
    return columns > 1 ? computeMasonryLayout(_extends({}, props, {
      layoutOptions: _extends({}, layoutOptions, {
        columns: columns - 1
      })
    })) : undefined;
  } // store current top positions for each column


  var columnsCurrentTopPositions = [];

  for (var i = 0; i < columns; i += 1) {
    columnsCurrentTopPositions[i] = 0;
  } // group photos by column


  var columnsModel = photos.reduce(function (acc, photo, index) {
    // find the shortest column
    var shortestColumn = columnsCurrentTopPositions.reduce(function (acc, item, i) {
      return (// subtracting 1 here to compensate for floating point precision errors
        // when two columns have identical height their floating point values can be slightly off
        // in subsequent re-renders, leading to images jumping between columns
        item < columnsCurrentTopPositions[acc] - 1 ? i : acc
      );
    }, 0); // update top position of the shortest column

    columnsCurrentTopPositions[shortestColumn] = columnsCurrentTopPositions[shortestColumn] + columnWidth / ratio(photo) + spacing + 2 * padding; // place a photo into the shortest column

    if (!acc[shortestColumn]) {
      acc[shortestColumn] = [];
    }

    acc[shortestColumn].push({
      photo: photo,
      index: index
    });
    return acc;
  }, []); // map through each column and photo and add layout properties

  var result = columnsModel.map(function (column) {
    return column.map(function (_ref, photoIndex) {
      var photo = _ref.photo,
          index = _ref.index;
      return {
        photo: photo,
        layout: {
          width: columnWidth,
          height: columnWidth / ratio(photo),
          index: index,
          photoIndex: photoIndex,
          photosCount: column.length
        }
      };
    });
  });
  (_b = instrumentation === null || instrumentation === void 0 ? void 0 : instrumentation.onFinishLayoutComputation) === null || _b === void 0 ? void 0 : _b.call(instrumentation, result);
  return result;
};

var MasonryLayout = function MasonryLayout(props) {
  var photos = props.photos,
      layoutOptions = props.layoutOptions,
      renderPhoto = props.renderPhoto,
      renderColumnContainer = props.renderColumnContainer,
      componentsProps = props.componentsProps,
      instrumentation = props.instrumentation;
  var masonryLayout = computeMasonryLayout({
    photos: photos,
    layoutOptions: layoutOptions,
    instrumentation: instrumentation
  });
  if (masonryLayout === undefined) return jsx(Fragment, {});
  return jsx(Fragment, {
    children: masonryLayout.map(function (column, columnIndex) {
      return jsx(ColumnContainerRenderer, {
        layoutOptions: layoutOptions,
        columnsCount: masonryLayout.length,
        columnIndex: columnIndex,
        renderColumnContainer: renderColumnContainer,
        columnContainerProps: componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.columnContainerProps,
        children: column.map(function (_ref) {
          var photo = _ref.photo,
              layout = _ref.layout;
          return jsx(PhotoRenderer, {
            photo: photo,
            layout: layout,
            layoutOptions: layoutOptions,
            renderPhoto: renderPhoto,
            imageProps: componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.imageProps
          }, photo.key || photo.src);
        })
      }, "masonry-column-" + columnIndex);
    })
  });
};

var _excluded = ["style"];

var defaultRenderContainer = function defaultRenderContainer(_ref) {
  var containerProps = _ref.containerProps,
      children = _ref.children,
      containerRef = _ref.containerRef;
  return jsx("div", _extends({
    ref: containerRef
  }, containerProps, {
    children: children
  }));
};

var ContainerRenderer = function ContainerRenderer(props) {
  var layoutOptions = props.layoutOptions,
      renderContainer = props.renderContainer,
      children = props.children,
      containerRef = props.containerRef,
      _props$containerProps = props.containerProps;
  _props$containerProps = _props$containerProps === void 0 ? {} : _props$containerProps;

  var style = _props$containerProps.style,
      restContainerProps = _objectWithoutPropertiesLoose(_props$containerProps, _excluded);

  var layout = layoutOptions.layout;

  var containerProps = _extends({
    className: "react-photo-album react-photo-album--" + layout,
    style: _extends({
      display: "flex",
      flexWrap: "nowrap",
      justifyContent: "space-between",
      flexDirection: layout === "rows" ? "column" : "row"
    }, style)
  }, restContainerProps); // we are dealing with deprecated exotic component returned by forwardRef


  if (renderContainer && typeof renderContainer === "object") {
    var Component = renderContainer;
    return jsx(Component, {
      ref: containerRef,
      layoutOptions: layoutOptions,
      containerProps: containerProps,
      children: children
    });
  }

  return (renderContainer !== null && renderContainer !== void 0 ? renderContainer : defaultRenderContainer)({
    containerProps: containerProps,
    containerRef: containerRef,
    layoutOptions: layoutOptions,
    children: children
  });
};

/* istanbul ignore next */

var useLayoutEffect = typeof document !== "undefined" ? useLayoutEffect$1 : useEffect;

var useMounted = function useMounted() {
  var _useState = useState(false),
      mounted = _useState[0],
      setMounted = _useState[1];

  useLayoutEffect(function () {
    setMounted(true);
    return function () {
      return setMounted(false);
    };
  }, []);
  return mounted;
};

var useContainerWidth = function useContainerWidth(resizeObserverProvider, breakpoints) {
  var observerRef = useRef();

  var _useState = useState(),
      containerWidth = _useState[0],
      setContainerWidth = _useState[1];

  var containerRef = useCallback(function (node) {
    var _a;

    if (observerRef.current) {
      observerRef.current.disconnect();
      observerRef.current = undefined;
    }

    var updateWidth = function updateWidth() {
      var newWidth = node === null || node === void 0 ? void 0 : node.clientWidth;

      if (newWidth !== undefined && breakpoints && breakpoints.length > 0) {
        var sortedBreakpoints = [].concat(breakpoints.filter(function (x) {
          return x > 0;
        })).sort(function (a, b) {
          return b - a;
        });
        sortedBreakpoints.push(Math.floor(sortedBreakpoints[sortedBreakpoints.length - 1] / 2));
        newWidth = sortedBreakpoints.find(function (breakpoint, index) {
          return breakpoint <= newWidth || index === sortedBreakpoints.length - 1;
        });
      }

      setContainerWidth(newWidth);
    };

    updateWidth();

    if (node) {
      observerRef.current = typeof ResizeObserver !== "undefined" ? new ResizeObserver(updateWidth) : resizeObserverProvider === null || resizeObserverProvider === void 0 ? void 0 : resizeObserverProvider(updateWidth);
      (_a = observerRef.current) === null || _a === void 0 ? void 0 : _a.observe(node);
    }
  }, [resizeObserverProvider, breakpoints]);
  return useMemo(function () {
    return {
      containerRef: containerRef,
      containerWidth: containerWidth
    };
  }, [containerRef, containerWidth]);
};

var breakpoints = Object.freeze([1200, 600, 300, 0]);

var unwrap = function unwrap(value, containerWidth) {
  return typeof value === "function" ? value(containerWidth) : value;
};

var unwrapParameter = function unwrapParameter(value, containerWidth) {
  return typeof value !== "undefined" ? unwrap(value, containerWidth) : undefined;
};

var selectResponsiveValue = function selectResponsiveValue(values, containerWidth) {
  var index = breakpoints.findIndex(function (breakpoint) {
    return breakpoint <= containerWidth;
  });
  return unwrap(values[index >= 0 ? index : 0], containerWidth);
};

var resolveResponsiveParameter = function resolveResponsiveParameter(parameter, containerWidth, values) {
  var value = unwrapParameter(parameter, containerWidth);
  return value === undefined ? selectResponsiveValue(values, containerWidth) : value;
};

var resolveLayoutOptions = function resolveLayoutOptions(_ref) {
  var layout = _ref.layout,
      onClick = _ref.onClick,
      viewportWidth = _ref.viewportWidth,
      containerWidth = _ref.containerWidth,
      targetRowHeight = _ref.targetRowHeight,
      rowConstraints = _ref.rowConstraints,
      columns = _ref.columns,
      spacing = _ref.spacing,
      padding = _ref.padding,
      sizes = _ref.sizes;
  return {
    layout: layout,
    onClick: onClick,
    viewportWidth: viewportWidth,
    containerWidth: containerWidth,
    columns: resolveResponsiveParameter(columns, containerWidth, [5, 4, 3, 2]),
    spacing: resolveResponsiveParameter(spacing, containerWidth, [20, 15, 10, 5]),
    padding: resolveResponsiveParameter(padding, containerWidth, [0, 0, 0, 0, 0]),
    targetRowHeight: resolveResponsiveParameter(targetRowHeight, containerWidth, [function (w) {
      return w / 5;
    }, function (w) {
      return w / 4;
    }, function (w) {
      return w / 3;
    }, function (w) {
      return w / 2;
    }]),
    sizes: sizes,
    rowConstraints: rowConstraints
  };
};

var resolveComponentsProps = function resolveComponentsProps(componentsProps, containerWidth) {
  return typeof componentsProps === "function" ? componentsProps(containerWidth) : componentsProps;
};

var PhotoAlbum = function PhotoAlbum(props) {
  var photos = props.photos,
      layout = props.layout,
      renderPhoto = props.renderPhoto,
      renderContainer = props.renderContainer,
      renderRowContainer = props.renderRowContainer,
      renderColumnContainer = props.renderColumnContainer,
      defaultContainerWidth = props.defaultContainerWidth,
      resizeObserverProvider = props.resizeObserverProvider,
      breakpoints = props.breakpoints,
      instrumentation = props.instrumentation;
  var mounted = useMounted();

  var _useContainerWidth = useContainerWidth(resizeObserverProvider, breakpoints),
      containerRef = _useContainerWidth.containerRef,
      containerWidth = _useContainerWidth.containerWidth; // safeguard against incorrect usage


  if (!layout || !["rows", "columns", "masonry"].includes(layout) || !Array.isArray(photos)) return jsx(Fragment, {});
  var layoutOptions = resolveLayoutOptions(_extends({
    containerWidth: mounted && containerWidth || defaultContainerWidth || 800,
    viewportWidth: mounted && window.innerWidth || undefined
  }, props));
  var componentsProps = resolveComponentsProps(props.componentsProps, layoutOptions.containerWidth);
  var commonLayoutProps = {
    photos: photos,
    renderPhoto: renderPhoto,
    componentsProps: componentsProps,
    instrumentation: instrumentation
  };
  return jsx(ContainerRenderer, {
    containerRef: containerRef,
    layoutOptions: layoutOptions,
    renderContainer: renderContainer,
    containerProps: componentsProps === null || componentsProps === void 0 ? void 0 : componentsProps.containerProps,
    children: layout === "rows" ? jsx(RowsLayout, _extends({
      layoutOptions: layoutOptions,
      renderRowContainer: renderRowContainer
    }, commonLayoutProps)) : layout === "columns" ? jsx(ColumnsLayout, _extends({
      layoutOptions: layoutOptions,
      renderColumnContainer: renderColumnContainer
    }, commonLayoutProps)) : jsx(MasonryLayout, _extends({
      layoutOptions: layoutOptions,
      renderColumnContainer: renderColumnContainer
    }, commonLayoutProps))
  });
};

export { PhotoAlbum, PhotoAlbum as default };
//# sourceMappingURL=index.esm.js.map
