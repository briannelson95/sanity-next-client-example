/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}var MarkProcessor = /** @class */ (function () {
    function MarkProcessor(string, marks, parseOptions) {
        this.allowBoost = false;
        this.string = string;
        this.marks = marks;
        this.index = 0;
        this.parseOptions = parseOptions;
    }
    MarkProcessor.prototype.hasMark = function (pos) {
        if (pos === void 0) { pos = 0; }
        return this.index + pos < this.marks.length;
    };
    MarkProcessor.prototype.getMark = function (pos) {
        if (pos === void 0) { pos = 0; }
        return this.marks[this.index + pos];
    };
    MarkProcessor.prototype.shift = function () {
        this.index += 1;
    };
    MarkProcessor.prototype.process = function (visitor) {
        var mark = this.marks[this.index];
        this.shift();
        var func = visitor[mark.name];
        if (!func) {
            throw new Error("Unknown handler: ".concat(mark.name));
        }
        return func.call(visitor, this, mark);
    };
    MarkProcessor.prototype.processString = function () {
        this.shift();
        return this.processStringEnd();
    };
    MarkProcessor.prototype.processStringEnd = function () {
        var prev = this.marks[this.index - 1];
        var curr = this.marks[this.index];
        this.shift();
        return this.string.slice(prev.position, curr.position);
    };
    MarkProcessor.prototype.slice = function (len) {
        var pos = this.marks[this.index].position;
        return this.string.slice(pos, pos + len);
    };
    return MarkProcessor;
}());var RFC3339_REGEX = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?(Z|([-+]\d{2}:\d{2}))$/;
function parseRFC3339(str) {
    if (RFC3339_REGEX.test(str)) {
        return new Date(str);
    }
    return null;
}
function formatRFC3339(d) {
    var year = addLeadingZero(d.getUTCFullYear(), 4);
    var month = addLeadingZero(d.getUTCMonth() + 1, 2);
    var day = addLeadingZero(d.getUTCDate(), 2);
    var hour = addLeadingZero(d.getUTCHours(), 2);
    var minute = addLeadingZero(d.getUTCMinutes(), 2);
    var second = addLeadingZero(d.getUTCSeconds(), 2);
    var fractionalSecond = '';
    var millis = d.getMilliseconds();
    if (millis != 0) {
        fractionalSecond = ".".concat(addLeadingZero(millis, 3));
    }
    return "".concat(year, "-").concat(month, "-").concat(day, "T").concat(hour, ":").concat(minute, ":").concat(second).concat(fractionalSecond, "Z");
}
function addLeadingZero(num, targetLength) {
    var str = num.toString();
    while (str.length < targetLength) {
        str = "0".concat(str);
    }
    return str;
}function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
function pathRegExp(pattern) {
    var re = [];
    for (var _i = 0, _a = pattern.split('.'); _i < _a.length; _i++) {
        var part = _a[_i];
        if (part === '*') {
            re.push('[^.]+');
        }
        else if (part === '**') {
            re.push('.*');
        }
        else {
            re.push(escapeRegExp(part));
        }
    }
    return new RegExp("^".concat(re.join('.'), "$"));
}
var Path = /** @class */ (function () {
    function Path(pattern) {
        this.pattern = pattern;
        this.patternRe = pathRegExp(pattern);
    }
    Path.prototype.matches = function (str) {
        return this.patternRe.test(str);
    };
    Path.prototype.toJSON = function () {
        return this.pattern;
    };
    return Path;
}());var StreamValue = /** @class */ (function () {
    function StreamValue(generator) {
        this.type = 'stream';
        this.generator = generator;
        this.ticker = null;
        this.isDone = false;
        this.data = [];
    }
    // eslint-disable-next-line class-methods-use-this
    StreamValue.prototype.isArray = function () {
        return true;
    };
    StreamValue.prototype.get = function () {
        var e_1, _a;
        return __awaiter(this, void 0, void 0, function () {
            var result, _b, _c, value, _d, _e, e_1_1;
            return __generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        result = [];
                        _f.label = 1;
                    case 1:
                        _f.trys.push([1, 7, 8, 13]);
                        _b = __asyncValues(this);
                        _f.label = 2;
                    case 2: return [4 /*yield*/, _b.next()];
                    case 3:
                        if (!(_c = _f.sent(), !_c.done)) return [3 /*break*/, 6];
                        value = _c.value;
                        _e = (_d = result).push;
                        return [4 /*yield*/, value.get()];
                    case 4:
                        _e.apply(_d, [_f.sent()]);
                        _f.label = 5;
                    case 5: return [3 /*break*/, 2];
                    case 6: return [3 /*break*/, 13];
                    case 7:
                        e_1_1 = _f.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 13];
                    case 8:
                        _f.trys.push([8, , 11, 12]);
                        if (!(_c && !_c.done && (_a = _b["return"]))) return [3 /*break*/, 10];
                        return [4 /*yield*/, _a.call(_b)];
                    case 9:
                        _f.sent();
                        _f.label = 10;
                    case 10: return [3 /*break*/, 12];
                    case 11:
                        if (e_1) throw e_1.error;
                        return [7 /*endfinally*/];
                    case 12: return [7 /*endfinally*/];
                    case 13: return [2 /*return*/, result];
                }
            });
        });
    };
    StreamValue.prototype[Symbol.asyncIterator] = function () {
        return __asyncGenerator(this, arguments, function _a() {
            var i;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        i = 0;
                        _b.label = 1;
                    case 1:
                        _b.label = 2;
                    case 2:
                        if (!(i < this.data.length)) return [3 /*break*/, 6];
                        return [4 /*yield*/, __await(this.data[i])];
                    case 3: return [4 /*yield*/, _b.sent()];
                    case 4:
                        _b.sent();
                        _b.label = 5;
                    case 5:
                        i++;
                        return [3 /*break*/, 2];
                    case 6:
                        if (!this.isDone) return [3 /*break*/, 8];
                        return [4 /*yield*/, __await(void 0)];
                    case 7: return [2 /*return*/, _b.sent()];
                    case 8: return [4 /*yield*/, __await(this._nextTick())];
                    case 9:
                        _b.sent();
                        return [3 /*break*/, 1];
                    case 10: return [2 /*return*/];
                }
            });
        });
    };
    StreamValue.prototype._nextTick = function () {
        var _this = this;
        if (this.ticker) {
            return this.ticker;
        }
        var currentResolver;
        var setupTicker = function () {
            _this.ticker = new Promise(function (resolve) {
                currentResolver = resolve;
            });
        };
        var tick = function () {
            currentResolver();
            setupTicker();
        };
        var fetch = function () { return __awaiter(_this, void 0, void 0, function () {
            var _a, _b, value, e_2_1;
            var e_2, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _d.trys.push([0, 5, 6, 11]);
                        _a = __asyncValues(this.generator());
                        _d.label = 1;
                    case 1: return [4 /*yield*/, _a.next()];
                    case 2:
                        if (!(_b = _d.sent(), !_b.done)) return [3 /*break*/, 4];
                        value = _b.value;
                        this.data.push(value);
                        tick();
                        _d.label = 3;
                    case 3: return [3 /*break*/, 1];
                    case 4: return [3 /*break*/, 11];
                    case 5:
                        e_2_1 = _d.sent();
                        e_2 = { error: e_2_1 };
                        return [3 /*break*/, 11];
                    case 6:
                        _d.trys.push([6, , 9, 10]);
                        if (!(_b && !_b.done && (_c = _a["return"]))) return [3 /*break*/, 8];
                        return [4 /*yield*/, _c.call(_a)];
                    case 7:
                        _d.sent();
                        _d.label = 8;
                    case 8: return [3 /*break*/, 10];
                    case 9:
                        if (e_2) throw e_2.error;
                        return [7 /*endfinally*/];
                    case 10: return [7 /*endfinally*/];
                    case 11:
                        this.isDone = true;
                        tick();
                        return [2 /*return*/];
                }
            });
        }); };
        setupTicker();
        fetch();
        return this.ticker;
    };
    return StreamValue;
}());var StaticValue = /** @class */ (function () {
    function StaticValue(data, type) {
        this.data = data;
        this.type = type;
    }
    StaticValue.prototype.isArray = function () {
        return this.type === 'array';
    };
    // eslint-disable-next-line require-await
    StaticValue.prototype.get = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.data];
            });
        });
    };
    StaticValue.prototype[Symbol.asyncIterator] = function () {
        if (Array.isArray(this.data)) {
            return (function (data) {
                var _i, data_1, element;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            _i = 0, data_1 = data;
                            _a.label = 1;
                        case 1:
                            if (!(_i < data_1.length)) return [3 /*break*/, 4];
                            element = data_1[_i];
                            return [4 /*yield*/, fromJS(element)];
                        case 2:
                            _a.sent();
                            _a.label = 3;
                        case 3:
                            _i++;
                            return [3 /*break*/, 1];
                        case 4: return [2 /*return*/];
                    }
                });
            })(this.data);
        }
        throw new Error("Cannot iterate over: ".concat(this.type));
    };
    return StaticValue;
}());
var NULL_VALUE = new StaticValue(null, 'null');
var TRUE_VALUE = new StaticValue(true, 'boolean');
var FALSE_VALUE = new StaticValue(false, 'boolean');
var DateTime = /** @class */ (function () {
    function DateTime(date) {
        this.date = date;
    }
    DateTime.parseToValue = function (str) {
        var date = parseRFC3339(str);
        if (date) {
            return new StaticValue(new DateTime(date), 'datetime');
        }
        return NULL_VALUE;
    };
    DateTime.prototype.equals = function (other) {
        return this.date.getTime() == other.date.getTime();
    };
    DateTime.prototype.add = function (secs) {
        var copy = new Date(this.date.getTime());
        copy.setTime(copy.getTime() + secs * 1000);
        return new DateTime(copy);
    };
    DateTime.prototype.difference = function (other) {
        return (this.date.getTime() - other.date.getTime()) / 1000;
    };
    DateTime.prototype.compareTo = function (other) {
        return this.date.getTime() - other.date.getTime();
    };
    DateTime.prototype.toString = function () {
        return formatRFC3339(this.date);
    };
    DateTime.prototype.toJSON = function () {
        return this.toString();
    };
    return DateTime;
}());
function fromNumber(num) {
    if (Number.isFinite(num)) {
        return new StaticValue(num, 'number');
    }
    return NULL_VALUE;
}
function fromString(str) {
    return new StaticValue(str, 'string');
}
function fromDateTime(dt) {
    return new StaticValue(dt, 'datetime');
}
function fromPath(path) {
    return new StaticValue(path, 'path');
}
function isIterator(obj) {
    return obj && typeof obj.next === 'function';
}
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function fromJS(val) {
    if (isIterator(val)) {
        return new StreamValue(function () {
            return __asyncGenerator(this, arguments, function () {
                var val_1, val_1_1, value, e_1_1;
                var e_1, _a;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            _b.trys.push([0, 7, 8, 13]);
                            val_1 = __asyncValues(val);
                            _b.label = 1;
                        case 1: return [4 /*yield*/, __await(val_1.next())];
                        case 2:
                            if (!(val_1_1 = _b.sent(), !val_1_1.done)) return [3 /*break*/, 6];
                            value = val_1_1.value;
                            return [4 /*yield*/, __await(fromJS(value))];
                        case 3: return [4 /*yield*/, _b.sent()];
                        case 4:
                            _b.sent();
                            _b.label = 5;
                        case 5: return [3 /*break*/, 1];
                        case 6: return [3 /*break*/, 13];
                        case 7:
                            e_1_1 = _b.sent();
                            e_1 = { error: e_1_1 };
                            return [3 /*break*/, 13];
                        case 8:
                            _b.trys.push([8, , 11, 12]);
                            if (!(val_1_1 && !val_1_1.done && (_a = val_1["return"]))) return [3 /*break*/, 10];
                            return [4 /*yield*/, __await(_a.call(val_1))];
                        case 9:
                            _b.sent();
                            _b.label = 10;
                        case 10: return [3 /*break*/, 12];
                        case 11:
                            if (e_1) throw e_1.error;
                            return [7 /*endfinally*/];
                        case 12: return [7 /*endfinally*/];
                        case 13: return [2 /*return*/];
                    }
                });
            });
        });
    }
    else if (val === null || val === undefined) {
        return NULL_VALUE;
    }
    return new StaticValue(val, getType(val));
}
/**
 * Returns the type of the value.
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function getType(data) {
    if (data === null || typeof data === 'undefined') {
        return 'null';
    }
    if (Array.isArray(data)) {
        return 'array';
    }
    if (data instanceof Path) {
        return 'path';
    }
    if (data instanceof DateTime) {
        return 'datetime';
    }
    return typeof data;
}var TYPE_ORDER = {
    datetime: 1,
    number: 2,
    string: 3,
    boolean: 4
};
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function partialCompare(a, b) {
    var aType = getType(a);
    var bType = getType(b);
    if (aType !== bType) {
        return null;
    }
    switch (aType) {
        case 'number':
        case 'boolean':
            return a - b;
        case 'string':
            if (a < b)
                return -1;
            if (a > b)
                return 1;
            return 0;
        case 'datetime':
            return a.compareTo(b);
        default:
            return null;
    }
}
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function totalCompare(a, b) {
    var aType = getType(a);
    var bType = getType(b);
    var aTypeOrder = TYPE_ORDER[aType] || 100;
    var bTypeOrder = TYPE_ORDER[bType] || 100;
    if (aTypeOrder !== bTypeOrder) {
        return aTypeOrder - bTypeOrder;
    }
    var result = partialCompare(a, b);
    if (result === null) {
        result = 0;
    }
    return result;
}var CHARS = /([^!@#$%^&*(),\\/?";:{}|[\]+<>\s-])+/g;
var CHARS_WITH_WILDCARD = /([^!@#$%^&(),\\/?";:{}|[\]+<>\s-])+/g;
var EDGE_CHARS = /(\b\.+|\.+\b)/g;
var MAX_TERM_LENGTH = 1024;
function matchText(tokens, patterns) {
    if (tokens.length === 0 || patterns.length === 0) {
        return false;
    }
    return patterns.every(function (pattern) { return pattern(tokens); });
}
function matchTokenize(text) {
    return text.replace(EDGE_CHARS, '').match(CHARS) || [];
}
function matchAnalyzePattern(text) {
    var termsRe = matchPatternRegex(text);
    return termsRe.map(function (re) { return function (tokens) { return tokens.some(function (token) { return re.test(token); }); }; });
}
function matchPatternRegex(text) {
    var terms = text.replace(EDGE_CHARS, '').match(CHARS_WITH_WILDCARD) || [];
    return terms.map(function (term) { return new RegExp("^".concat(term.slice(0, MAX_TERM_LENGTH).replace(/\*/g, '.*'), "$"), 'i'); });
}
function gatherText(value, cb) {
    var value_1, value_1_1;
    var e_1, _a;
    return __awaiter(this, void 0, void 0, function () {
        var success, part, e_1_1;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    if (value.type === 'string') {
                        cb(value.data);
                        return [2 /*return*/, true];
                    }
                    if (!value.isArray()) return [3 /*break*/, 13];
                    success = true;
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, 6, 7, 12]);
                    value_1 = __asyncValues(value);
                    _b.label = 2;
                case 2: return [4 /*yield*/, value_1.next()];
                case 3:
                    if (!(value_1_1 = _b.sent(), !value_1_1.done)) return [3 /*break*/, 5];
                    part = value_1_1.value;
                    if (part.type === 'string') {
                        cb(part.data);
                    }
                    else {
                        success = false;
                    }
                    _b.label = 4;
                case 4: return [3 /*break*/, 2];
                case 5: return [3 /*break*/, 12];
                case 6:
                    e_1_1 = _b.sent();
                    e_1 = { error: e_1_1 };
                    return [3 /*break*/, 12];
                case 7:
                    _b.trys.push([7, , 10, 11]);
                    if (!(value_1_1 && !value_1_1.done && (_a = value_1["return"]))) return [3 /*break*/, 9];
                    return [4 /*yield*/, _a.call(value_1)];
                case 8:
                    _b.sent();
                    _b.label = 9;
                case 9: return [3 /*break*/, 11];
                case 10:
                    if (e_1) throw e_1.error;
                    return [7 /*endfinally*/];
                case 11: return [7 /*endfinally*/];
                case 12: return [2 /*return*/, success];
                case 13: return [2 /*return*/, false];
            }
        });
    });
}// BM25 similarity constants
var BM25k = 1.2;
function evaluateScore(node, scope, execute) {
    return __awaiter(this, void 0, void 0, function () {
        var innerScore, boost, _a, leftScore, rightScore, leftScore, rightScore, res;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    if (node.type === 'OpCall' && node.op === 'match') {
                        return [2 /*return*/, evaluateMatchScore(node.left, node.right, scope, execute)];
                    }
                    if (!(node.type === 'FuncCall' && node.name === 'boost')) return [3 /*break*/, 3];
                    return [4 /*yield*/, evaluateScore(node.args[0], scope, execute)];
                case 1:
                    innerScore = _b.sent();
                    return [4 /*yield*/, execute(node.args[1], scope)];
                case 2:
                    boost = _b.sent();
                    if (boost.type === 'number' && innerScore > 0) {
                        return [2 /*return*/, innerScore + boost.data];
                    }
                    return [2 /*return*/, 0];
                case 3:
                    _a = node.type;
                    switch (_a) {
                        case 'Or': return [3 /*break*/, 4];
                        case 'And': return [3 /*break*/, 7];
                    }
                    return [3 /*break*/, 10];
                case 4: return [4 /*yield*/, evaluateScore(node.left, scope, execute)];
                case 5:
                    leftScore = _b.sent();
                    return [4 /*yield*/, evaluateScore(node.right, scope, execute)];
                case 6:
                    rightScore = _b.sent();
                    return [2 /*return*/, leftScore + rightScore];
                case 7: return [4 /*yield*/, evaluateScore(node.left, scope, execute)];
                case 8:
                    leftScore = _b.sent();
                    return [4 /*yield*/, evaluateScore(node.right, scope, execute)];
                case 9:
                    rightScore = _b.sent();
                    if (leftScore === 0 || rightScore === 0)
                        return [2 /*return*/, 0];
                    return [2 /*return*/, leftScore + rightScore];
                case 10: return [4 /*yield*/, execute(node, scope)];
                case 11:
                    res = _b.sent();
                    return [2 /*return*/, res.type === 'boolean' && res.data === true ? 1 : 0];
            }
        });
    });
}
function evaluateMatchScore(left, right, scope, execute) {
    return __awaiter(this, void 0, void 0, function () {
        var text, pattern, tokens, terms, didSucceed, score, _loop_1, _i, terms_1, re;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, execute(left, scope)];
                case 1:
                    text = _a.sent();
                    return [4 /*yield*/, execute(right, scope)];
                case 2:
                    pattern = _a.sent();
                    tokens = [];
                    terms = [];
                    return [4 /*yield*/, gatherText(text, function (part) {
                            tokens = tokens.concat(matchTokenize(part));
                        })];
                case 3:
                    _a.sent();
                    return [4 /*yield*/, gatherText(pattern, function (part) {
                            terms = terms.concat(matchPatternRegex(part));
                        })];
                case 4:
                    didSucceed = _a.sent();
                    if (!didSucceed) {
                        return [2 /*return*/, 0];
                    }
                    if (tokens.length === 0 || terms.length === 0) {
                        return [2 /*return*/, 0];
                    }
                    score = 0;
                    _loop_1 = function (re) {
                        var freq = tokens.reduce(function (c, token) { return c + (re.test(token) ? 1 : 0); }, 0);
                        score += (freq * (BM25k + 1)) / (freq + BM25k);
                    };
                    for (_i = 0, terms_1 = terms; _i < terms_1.length; _i++) {
                        re = terms_1[_i];
                        _loop_1(re);
                    }
                    return [2 /*return*/, score];
            }
        });
    });
}function portableTextContent(value) {
    return __awaiter(this, void 0, void 0, function () {
        var texts;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!(value.type === 'object')) return [3 /*break*/, 1];
                    return [2 /*return*/, blockText(value.data)];
                case 1:
                    if (!value.isArray()) return [3 /*break*/, 3];
                    return [4 /*yield*/, arrayText(value)];
                case 2:
                    texts = _a.sent();
                    if (texts.length > 0) {
                        return [2 /*return*/, texts.join('\n\n')];
                    }
                    _a.label = 3;
                case 3: return [2 /*return*/, null];
            }
        });
    });
}
function arrayText(value, result) {
    var value_1, value_1_1;
    var e_1, _a;
    if (result === void 0) { result = []; }
    return __awaiter(this, void 0, void 0, function () {
        var block, text, e_1_1;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _b.trys.push([0, 7, 8, 13]);
                    value_1 = __asyncValues(value);
                    _b.label = 1;
                case 1: return [4 /*yield*/, value_1.next()];
                case 2:
                    if (!(value_1_1 = _b.sent(), !value_1_1.done)) return [3 /*break*/, 6];
                    block = value_1_1.value;
                    if (!(block.type === 'object')) return [3 /*break*/, 3];
                    text = blockText(block.data);
                    if (text !== null)
                        result.push(text);
                    return [3 /*break*/, 5];
                case 3:
                    if (!block.isArray()) return [3 /*break*/, 5];
                    return [4 /*yield*/, arrayText(block, result)];
                case 4:
                    _b.sent();
                    _b.label = 5;
                case 5: return [3 /*break*/, 1];
                case 6: return [3 /*break*/, 13];
                case 7:
                    e_1_1 = _b.sent();
                    e_1 = { error: e_1_1 };
                    return [3 /*break*/, 13];
                case 8:
                    _b.trys.push([8, , 11, 12]);
                    if (!(value_1_1 && !value_1_1.done && (_a = value_1["return"]))) return [3 /*break*/, 10];
                    return [4 /*yield*/, _a.call(value_1)];
                case 9:
                    _b.sent();
                    _b.label = 10;
                case 10: return [3 /*break*/, 12];
                case 11:
                    if (e_1) throw e_1.error;
                    return [7 /*endfinally*/];
                case 12: return [7 /*endfinally*/];
                case 13: return [2 /*return*/, result];
            }
        });
    });
}
function blockText(obj) {
    if (typeof obj._type !== 'string')
        return null;
    var children = obj.children;
    if (!Array.isArray(children))
        return null;
    var result = '';
    for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {
        var child = children_1[_i];
        if (child &&
            typeof child === 'object' &&
            typeof child._type === 'string' &&
            child._type === 'span' &&
            typeof child.text === 'string') {
            result += child.text;
        }
    }
    return result;
}function hasReference(value, pathSet) {
    switch (getType(value)) {
        case 'array':
            for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {
                var v = value_1[_i];
                if (hasReference(v, pathSet)) {
                    return true;
                }
            }
            break;
        case 'object':
            if (value._ref) {
                return pathSet.has(value._ref);
            }
            for (var _a = 0, _b = Object.values(value); _a < _b.length; _a++) {
                var v = _b[_a];
                if (hasReference(v, pathSet)) {
                    return true;
                }
            }
            break;
    }
    return false;
}
function countUTF8(str) {
    var count = 0;
    for (var i = 0; i < str.length; i++) {
        var code = str.charCodeAt(i);
        if (code >= 0xd800 && code <= 0xdbff) {
            // High surrogate. Don't count this.
            // By only counting the low surrogate we will correctly
            // count the number of UTF-8 code points.
            continue;
        }
        count++;
    }
    return count;
}
var global = {};
global.anywhere = function anywhere() {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            throw new Error('not implemented');
        });
    });
};
global.anywhere.arity = 1;
global.coalesce = function coalesce(args, scope, execute) {
    return __awaiter(this, void 0, void 0, function () {
        var _i, args_1, arg, value;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _i = 0, args_1 = args;
                    _a.label = 1;
                case 1:
                    if (!(_i < args_1.length)) return [3 /*break*/, 4];
                    arg = args_1[_i];
                    return [4 /*yield*/, execute(arg, scope)];
                case 2:
                    value = _a.sent();
                    if (value.type !== 'null') {
                        return [2 /*return*/, value];
                    }
                    _a.label = 3;
                case 3:
                    _i++;
                    return [3 /*break*/, 1];
                case 4: return [2 /*return*/, NULL_VALUE];
            }
        });
    });
};
global.count = function count(args, scope, execute) {
    var e_1, _a;
    return __awaiter(this, void 0, void 0, function () {
        var inner, num, inner_1, inner_1_1, e_1_1;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, execute(args[0], scope)];
                case 1:
                    inner = _b.sent();
                    if (!inner.isArray()) {
                        return [2 /*return*/, NULL_VALUE];
                    }
                    num = 0;
                    _b.label = 2;
                case 2:
                    _b.trys.push([2, 7, 8, 13]);
                    inner_1 = __asyncValues(inner);
                    _b.label = 3;
                case 3: return [4 /*yield*/, inner_1.next()];
                case 4:
                    if (!(inner_1_1 = _b.sent(), !inner_1_1.done)) return [3 /*break*/, 6];
                    inner_1_1.value;
                    num++;
                    _b.label = 5;
                case 5: return [3 /*break*/, 3];
                case 6: return [3 /*break*/, 13];
                case 7:
                    e_1_1 = _b.sent();
                    e_1 = { error: e_1_1 };
                    return [3 /*break*/, 13];
                case 8:
                    _b.trys.push([8, , 11, 12]);
                    if (!(inner_1_1 && !inner_1_1.done && (_a = inner_1["return"]))) return [3 /*break*/, 10];
                    return [4 /*yield*/, _a.call(inner_1)];
                case 9:
                    _b.sent();
                    _b.label = 10;
                case 10: return [3 /*break*/, 12];
                case 11:
                    if (e_1) throw e_1.error;
                    return [7 /*endfinally*/];
                case 12: return [7 /*endfinally*/];
                case 13: return [2 /*return*/, fromNumber(num)];
            }
        });
    });
};
global.count.arity = 1;
global.dateTime = function dateTime(args, scope, execute) {
    return __awaiter(this, void 0, void 0, function () {
        var val;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, execute(args[0], scope)];
                case 1:
                    val = _a.sent();
                    if (val.type === 'datetime') {
                        return [2 /*return*/, val];
                    }
                    if (val.type !== 'string') {
                        return [2 /*return*/, NULL_VALUE];
                    }
                    return [2 /*return*/, DateTime.parseToValue(val.data)];
            }
        });
    });
};
global.dateTime.arity = 1;
global.defined = function defined(args, scope, execute) {
    return __awaiter(this, void 0, void 0, function () {
        var inner;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, execute(args[0], scope)];
                case 1:
                    inner = _a.sent();
                    return [2 /*return*/, inner.type === 'null' ? FALSE_VALUE : TRUE_VALUE];
            }
        });
    });
};
global.defined.arity = 1;
// eslint-disable-next-line require-await
global.identity = function identity(args, scope) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, fromString(scope.context.identity)];
        });
    });
};
global.identity.arity = 0;
global.length = function length(args, scope, execute) {
    var e_2, _a;
    return __awaiter(this, void 0, void 0, function () {
        var inner, num, inner_2, inner_2_1, e_2_1;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, execute(args[0], scope)];
                case 1:
                    inner = _b.sent();
                    if (inner.type === 'string') {
                        return [2 /*return*/, fromNumber(countUTF8(inner.data))];
                    }
                    if (!inner.isArray()) return [3 /*break*/, 14];
                    num = 0;
                    _b.label = 2;
                case 2:
                    _b.trys.push([2, 7, 8, 13]);
                    inner_2 = __asyncValues(inner);
                    _b.label = 3;
                case 3: return [4 /*yield*/, inner_2.next()];
                case 4:
                    if (!(inner_2_1 = _b.sent(), !inner_2_1.done)) return [3 /*break*/, 6];
                    inner_2_1.value;
                    num++;
                    _b.label = 5;
                case 5: return [3 /*break*/, 3];
                case 6: return [3 /*break*/, 13];
                case 7:
                    e_2_1 = _b.sent();
                    e_2 = { error: e_2_1 };
                    return [3 /*break*/, 13];
                case 8:
                    _b.trys.push([8, , 11, 12]);
                    if (!(inner_2_1 && !inner_2_1.done && (_a = inner_2["return"]))) return [3 /*break*/, 10];
                    return [4 /*yield*/, _a.call(inner_2)];
                case 9:
                    _b.sent();
                    _b.label = 10;
                case 10: return [3 /*break*/, 12];
                case 11:
                    if (e_2) throw e_2.error;
                    return [7 /*endfinally*/];
                case 12: return [7 /*endfinally*/];
                case 13: return [2 /*return*/, fromNumber(num)];
                case 14: return [2 /*return*/, NULL_VALUE];
            }
        });
    });
};
global.length.arity = 1;
global.path = function path(args, scope, execute) {
    return __awaiter(this, void 0, void 0, function () {
        var inner;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, execute(args[0], scope)];
                case 1:
                    inner = _a.sent();
                    if (inner.type !== 'string') {
                        return [2 /*return*/, NULL_VALUE];
                    }
                    return [2 /*return*/, fromPath(new Path(inner.data))];
            }
        });
    });
};
global.path.arity = 1;
global.string = function string(args, scope, execute) {
    return __awaiter(this, void 0, void 0, function () {
        var value;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, execute(args[0], scope)];
                case 1:
                    value = _a.sent();
                    switch (value.type) {
                        case 'number':
                        case 'string':
                        case 'boolean':
                        case 'datetime':
                            return [2 /*return*/, fromString("".concat(value.data))];
                        default:
                            return [2 /*return*/, NULL_VALUE];
                    }
                    return [2 /*return*/];
            }
        });
    });
};
global.string.arity = 1;
global.references = function references(args, scope, execute) {
    var e_3, _a;
    return __awaiter(this, void 0, void 0, function () {
        var pathSet, _i, args_2, arg, path, path_1, path_1_1, elem, e_3_1, scopeValue;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    pathSet = new Set();
                    _i = 0, args_2 = args;
                    _b.label = 1;
                case 1:
                    if (!(_i < args_2.length)) return [3 /*break*/, 16];
                    arg = args_2[_i];
                    return [4 /*yield*/, execute(arg, scope)];
                case 2:
                    path = _b.sent();
                    if (!(path.type === 'string')) return [3 /*break*/, 3];
                    pathSet.add(path.data);
                    return [3 /*break*/, 15];
                case 3:
                    if (!path.isArray()) return [3 /*break*/, 15];
                    _b.label = 4;
                case 4:
                    _b.trys.push([4, 9, 10, 15]);
                    path_1 = (e_3 = void 0, __asyncValues(path));
                    _b.label = 5;
                case 5: return [4 /*yield*/, path_1.next()];
                case 6:
                    if (!(path_1_1 = _b.sent(), !path_1_1.done)) return [3 /*break*/, 8];
                    elem = path_1_1.value;
                    if (elem.type === 'string') {
                        pathSet.add(elem.data);
                    }
                    _b.label = 7;
                case 7: return [3 /*break*/, 5];
                case 8: return [3 /*break*/, 15];
                case 9:
                    e_3_1 = _b.sent();
                    e_3 = { error: e_3_1 };
                    return [3 /*break*/, 15];
                case 10:
                    _b.trys.push([10, , 13, 14]);
                    if (!(path_1_1 && !path_1_1.done && (_a = path_1["return"]))) return [3 /*break*/, 12];
                    return [4 /*yield*/, _a.call(path_1)];
                case 11:
                    _b.sent();
                    _b.label = 12;
                case 12: return [3 /*break*/, 14];
                case 13:
                    if (e_3) throw e_3.error;
                    return [7 /*endfinally*/];
                case 14: return [7 /*endfinally*/];
                case 15:
                    _i++;
                    return [3 /*break*/, 1];
                case 16:
                    if (pathSet.size === 0) {
                        return [2 /*return*/, FALSE_VALUE];
                    }
                    return [4 /*yield*/, scope.value.get()];
                case 17:
                    scopeValue = _b.sent();
                    return [2 /*return*/, hasReference(scopeValue, pathSet) ? TRUE_VALUE : FALSE_VALUE];
            }
        });
    });
};
global.references.arity = function (c) { return c >= 1; };
global.round = function round(args, scope, execute) {
    return __awaiter(this, void 0, void 0, function () {
        var value, num, prec, precValue;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, execute(args[0], scope)];
                case 1:
                    value = _a.sent();
                    if (value.type !== 'number') {
                        return [2 /*return*/, NULL_VALUE];
                    }
                    num = value.data;
                    prec = 0;
                    if (!(args.length === 2)) return [3 /*break*/, 3];
                    return [4 /*yield*/, execute(args[1], scope)];
                case 2:
                    precValue = _a.sent();
                    if (precValue.type !== 'number' || precValue.data < 0 || !Number.isInteger(precValue.data)) {
                        return [2 /*return*/, NULL_VALUE];
                    }
                    prec = precValue.data;
                    _a.label = 3;
                case 3:
                    if (prec === 0) {
                        if (num < 0) {
                            // JavaScript's round() function will always rounds towards positive infinity (-3.5 -> -3).
                            // The behavior we're interested in is to "round half away from zero".
                            return [2 /*return*/, fromNumber(-Math.round(-num))];
                        }
                        return [2 /*return*/, fromNumber(Math.round(num))];
                    }
                    return [2 /*return*/, fromNumber(Number(num.toFixed(prec)))];
            }
        });
    });
};
global.round.arity = function (count) { return count >= 1 && count <= 2; };
// eslint-disable-next-line require-await
global.now = function now(args, scope) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, fromString(scope.context.timestamp.toISOString())];
        });
    });
};
global.now.arity = 0;
// eslint-disable-next-line require-await
global.boost = function boost() {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            // This should be handled by the scoring function.
            throw new Error('unexpected boost call');
        });
    });
};
global.boost.arity = 2;
var string = {};
string.lower = function (args, scope, execute) {
    return __awaiter(this, void 0, void 0, function () {
        var value;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, execute(args[0], scope)];
                case 1:
                    value = _a.sent();
                    if (value.type !== 'string') {
                        return [2 /*return*/, NULL_VALUE];
                    }
                    return [2 /*return*/, fromString(value.data.toLowerCase())];
            }
        });
    });
};
string.lower.arity = 1;
string.upper = function (args, scope, execute) {
    return __awaiter(this, void 0, void 0, function () {
        var value;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, execute(args[0], scope)];
                case 1:
                    value = _a.sent();
                    if (value.type !== 'string') {
                        return [2 /*return*/, NULL_VALUE];
                    }
                    return [2 /*return*/, fromString(value.data.toUpperCase())];
            }
        });
    });
};
string.upper.arity = 1;
global.lower = string.lower;
global.upper = string.upper;
var pt = {};
pt.text = function (args, scope, execute) {
    return __awaiter(this, void 0, void 0, function () {
        var value, text;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, execute(args[0], scope)];
                case 1:
                    value = _a.sent();
                    return [4 /*yield*/, portableTextContent(value)];
                case 2:
                    text = _a.sent();
                    if (text === null) {
                        return [2 /*return*/, NULL_VALUE];
                    }
                    return [2 /*return*/, fromString(text)];
            }
        });
    });
};
pt.text.arity = 1;
var sanity = {};
// eslint-disable-next-line require-await
sanity.projectId = function (args, scope) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            if (scope.context.sanity) {
                return [2 /*return*/, fromString(scope.context.sanity.projectId)];
            }
            return [2 /*return*/, NULL_VALUE];
        });
    });
};
// eslint-disable-next-line require-await
sanity.dataset = function (args, scope) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            if (scope.context.sanity) {
                return [2 /*return*/, fromString(scope.context.sanity.dataset)];
            }
            return [2 /*return*/, NULL_VALUE];
        });
    });
};
var pipeFunctions = {};
pipeFunctions.order = function order(base, args, scope, execute) {
    var base_1, base_1_1;
    var e_4, _a;
    return __awaiter(this, void 0, void 0, function () {
        var mappers, directions, n, _i, args_3, mapper, direction, aux, idx, value, newScope, tuple, i, result, _b, _c, e_4_1;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0: 
                // eslint-disable-next-line max-len
                // This is a workaround for https://github.com/rpetrich/babel-plugin-transform-async-to-promises/issues/59
                return [4 /*yield*/, true];
                case 1:
                    // eslint-disable-next-line max-len
                    // This is a workaround for https://github.com/rpetrich/babel-plugin-transform-async-to-promises/issues/59
                    _d.sent();
                    if (!base.isArray()) {
                        return [2 /*return*/, NULL_VALUE];
                    }
                    mappers = [];
                    directions = [];
                    n = 0;
                    for (_i = 0, args_3 = args; _i < args_3.length; _i++) {
                        mapper = args_3[_i];
                        direction = 'asc';
                        if (mapper.type === 'Desc') {
                            direction = 'desc';
                            mapper = mapper.base;
                        }
                        else if (mapper.type === 'Asc') {
                            mapper = mapper.base;
                        }
                        mappers.push(mapper);
                        directions.push(direction);
                        n++;
                    }
                    aux = [];
                    idx = 0;
                    _d.label = 2;
                case 2:
                    _d.trys.push([2, 13, 14, 19]);
                    base_1 = __asyncValues(base);
                    _d.label = 3;
                case 3: return [4 /*yield*/, base_1.next()];
                case 4:
                    if (!(base_1_1 = _d.sent(), !base_1_1.done)) return [3 /*break*/, 12];
                    value = base_1_1.value;
                    newScope = scope.createNested(value);
                    return [4 /*yield*/, value.get()];
                case 5:
                    tuple = [_d.sent(), idx];
                    i = 0;
                    _d.label = 6;
                case 6:
                    if (!(i < n)) return [3 /*break*/, 10];
                    return [4 /*yield*/, execute(mappers[i], newScope)];
                case 7:
                    result = _d.sent();
                    _c = (_b = tuple).push;
                    return [4 /*yield*/, result.get()];
                case 8:
                    _c.apply(_b, [_d.sent()]);
                    _d.label = 9;
                case 9:
                    i++;
                    return [3 /*break*/, 6];
                case 10:
                    aux.push(tuple);
                    idx++;
                    _d.label = 11;
                case 11: return [3 /*break*/, 3];
                case 12: return [3 /*break*/, 19];
                case 13:
                    e_4_1 = _d.sent();
                    e_4 = { error: e_4_1 };
                    return [3 /*break*/, 19];
                case 14:
                    _d.trys.push([14, , 17, 18]);
                    if (!(base_1_1 && !base_1_1.done && (_a = base_1["return"]))) return [3 /*break*/, 16];
                    return [4 /*yield*/, _a.call(base_1)];
                case 15:
                    _d.sent();
                    _d.label = 16;
                case 16: return [3 /*break*/, 18];
                case 17:
                    if (e_4) throw e_4.error;
                    return [7 /*endfinally*/];
                case 18: return [7 /*endfinally*/];
                case 19:
                    aux.sort(function (aTuple, bTuple) {
                        for (var i = 0; i < n; i++) {
                            var c = totalCompare(aTuple[i + 2], bTuple[i + 2]);
                            if (directions[i] === 'desc') {
                                c = -c;
                            }
                            if (c !== 0) {
                                return c;
                            }
                        }
                        // Fallback to sorting on the original index for stable sorting.
                        return aTuple[1] - bTuple[1];
                    });
                    return [2 /*return*/, fromJS(aux.map(function (v) { return v[0]; }))];
            }
        });
    });
};
pipeFunctions.order.arity = function (count) { return count >= 1; };
// eslint-disable-next-line require-await
pipeFunctions.score = function score(base, args, scope, execute) {
    var base_2, base_2_1;
    var e_5, _a;
    return __awaiter(this, void 0, void 0, function () {
        var unknown, scored, value, _b, _c, newScope, valueScore, _i, args_4, arg, _d, newObject, e_5_1;
        return __generator(this, function (_e) {
            switch (_e.label) {
                case 0:
                    if (!base.isArray())
                        return [2 /*return*/, NULL_VALUE
                            // Anything that isn't an object should be sorted first.
                        ];
                    unknown = [];
                    scored = [];
                    _e.label = 1;
                case 1:
                    _e.trys.push([1, 12, 13, 18]);
                    base_2 = __asyncValues(base);
                    _e.label = 2;
                case 2: return [4 /*yield*/, base_2.next()];
                case 3:
                    if (!(base_2_1 = _e.sent(), !base_2_1.done)) return [3 /*break*/, 11];
                    value = base_2_1.value;
                    if (!(value.type !== 'object')) return [3 /*break*/, 5];
                    _c = (_b = unknown).push;
                    return [4 /*yield*/, value.get()];
                case 4:
                    _c.apply(_b, [_e.sent()]);
                    return [3 /*break*/, 10];
                case 5:
                    newScope = scope.createNested(value);
                    valueScore = typeof value.data._score === 'number' ? value.data._score : 0;
                    _i = 0, args_4 = args;
                    _e.label = 6;
                case 6:
                    if (!(_i < args_4.length)) return [3 /*break*/, 9];
                    arg = args_4[_i];
                    _d = valueScore;
                    return [4 /*yield*/, evaluateScore(arg, newScope, execute)];
                case 7:
                    valueScore = _d + _e.sent();
                    _e.label = 8;
                case 8:
                    _i++;
                    return [3 /*break*/, 6];
                case 9:
                    newObject = Object.assign({}, value.data, { _score: valueScore });
                    scored.push(newObject);
                    _e.label = 10;
                case 10: return [3 /*break*/, 2];
                case 11: return [3 /*break*/, 18];
                case 12:
                    e_5_1 = _e.sent();
                    e_5 = { error: e_5_1 };
                    return [3 /*break*/, 18];
                case 13:
                    _e.trys.push([13, , 16, 17]);
                    if (!(base_2_1 && !base_2_1.done && (_a = base_2["return"]))) return [3 /*break*/, 15];
                    return [4 /*yield*/, _a.call(base_2)];
                case 14:
                    _e.sent();
                    _e.label = 15;
                case 15: return [3 /*break*/, 17];
                case 16:
                    if (e_5) throw e_5.error;
                    return [7 /*endfinally*/];
                case 17: return [7 /*endfinally*/];
                case 18:
                    scored.sort(function (a, b) { return b._score - a._score; });
                    return [2 /*return*/, fromJS(scored)];
            }
        });
    });
};
pipeFunctions.score.arity = function (count) { return count >= 1; };
var delta = {};
delta.operation = function (args, scope) {
    return __awaiter(this, void 0, void 0, function () {
        var hasBefore, hasAfter;
        return __generator(this, function (_a) {
            hasBefore = scope.context.before !== null;
            hasAfter = scope.context.after !== null;
            if (hasBefore && hasAfter) {
                return [2 /*return*/, fromString('update')];
            }
            if (hasAfter) {
                return [2 /*return*/, fromString('create')];
            }
            if (hasBefore) {
                return [2 /*return*/, fromString('delete')];
            }
            return [2 /*return*/, NULL_VALUE];
        });
    });
};
delta.changedAny = function () {
    throw new Error('not implemented');
};
delta.changedAny.arity = 1;
delta.changedAny.mode = 'delta';
delta.changedOnly = function () {
    throw new Error('not implemented');
};
delta.changedOnly.arity = 1;
delta.changedOnly.mode = 'delta';
var diff = {};
diff.changedAny = function () {
    throw new Error('not implemented');
};
diff.changedAny.arity = 3;
diff.changedOnly = function () {
    throw new Error('not implemented');
};
diff.changedOnly.arity = 3;
var namespaces = {
    global: global,
    string: string,
    pt: pt,
    delta: delta,
    diff: diff,
    sanity: sanity
};const WS = /^([\t\n\v\f\r \u0085\u00A0]|(\/\/[^\n]*\n))+/;
const NUM = /^\d+/;
const IDENT = /^[a-zA-Z_][a-zA-Z_0-9]*/;

// Precedence levels for binary operators:
const PREC_PAIR = 1;
const PREC_OR = 2;
const PREC_AND = 3;
const PREC_COMP = 4;
const PREC_ORDER = 4;
const PREC_ADD = 6;
const PREC_SUB = 6;
const PREC_MUL = 7;
const PREC_DIV = 7;
const PREC_MOD = 7;
const PREC_POW = 8;

// Precedence levels for prefix operators:
const PREC_POS = 10;
const PREC_NOT = 10;
const PREC_NEG = 8;

function parse$1(str) {
  let pos = 0;
  pos = skipWS(str, pos);
  let result = parseExpr(str, pos, 0);
  if (result.type === 'error') return result
  pos = skipWS(str, result.position);
  if (pos !== str.length) {
    if (result.failPosition) {
      pos = result.failPosition - 1;
    }
    return {type: 'error', position: pos}
  }
  delete result.position;
  delete result.failPosition;
  return result
}

function parseExpr(str, pos, level) {
  // In this function we parse precedence "manually" by having two variables:
  //
  // `level` is the minimum precedence level we want to parse at. If this is
  // e.g. 7 then this function will not parse `3 + 4` (since addition is at 6),
  // but instead just return `1` and leave ` + 5` remaining. We use this so that
  // while handling the RHS of the multiplication in `1 + 2 * 3 + 4` we only parse `3`.
  //
  // `lhsLevel` is the precedence level of the currently parsed expression on
  // the left-hand side. This is mainly used to handle non-associcativeness.

  // This means that you'll see code like:
  // - `if (level > PREC_XXX) break`: Operator is at this precedence level.
  // - `if (lhsLevel < PREC_XXX) break`: Operator is left-associative.
  // - `if (lhsLevel <= PREC_XXX) break`: Operator is right/non-associative.
  // - `parseExpr(str, pos, PREC_XXX + 1)`: Operator is left/non-assoicate.
  // - `parseExpr(str, pos, PREC_XXX)`: Operator is right-assoicate.

  let startPos = pos;
  let token = str[pos];
  let marks;

  switch (token) {
    case '+': {
      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_POS);
      if (rhs.type === 'error') return rhs
      marks = [{name: 'pos', position: startPos}].concat(rhs.marks);
      pos = rhs.position;
      break
    }
    case '-': {
      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NEG);
      if (rhs.type === 'error') return rhs
      marks = [{name: 'neg', position: startPos}].concat(rhs.marks);
      pos = rhs.position;
      break
    }
    case '(': {
      let rhs = parseExpr(str, skipWS(str, pos + 1), 0);
      if (rhs.type === 'error') return rhs
      pos = skipWS(str, rhs.position);
      switch (str[pos]) {
        case ',': {
          // Tuples
          marks = [{name: 'tuple', position: startPos}].concat(rhs.marks);
          pos = skipWS(str, pos + 1);
          while (true) {
            rhs = parseExpr(str, pos, 0);
            if (rhs.type === 'error') return rhs
            pos = skipWS(str, rhs.position);
            if (str[pos] !== ',') break
            pos = skipWS(str, pos + 1);
          }
          if (str[pos] !== ')') return {type: 'error', position: pos}
          pos++;
          marks.push({name: 'tuple_end', position: pos});
          break
        }
        case ')': {
          pos++;
          marks = [{name: 'group', position: startPos}].concat(rhs.marks);
          break
        }
        default:
          return {type: 'error', position: pos}
      }
      break
    }
    case '!': {
      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NOT);
      if (rhs.type === 'error') return rhs
      marks = [{name: 'not', position: startPos}].concat(rhs.marks);
      pos = rhs.position;
      break
    }
    case '{': {
      let result = parseObject(str, pos);
      if (result.type === 'error') return result
      marks = result.marks;
      pos = result.position;
      break
    }
    case '[':
      marks = [{name: 'array', position: pos}];
      pos = skipWS(str, pos + 1);

      if (str[pos] !== ']') {
        while (true) {
          if (str.slice(pos, pos + 3) === '...') {
            marks.push({name: 'array_splat', position: pos});
            pos = skipWS(str, pos + 3);
          }

          let res = parseExpr(str, pos, 0);
          if (res.type === 'error') return res
          marks = marks.concat(res.marks);
          pos = res.position;
          pos = skipWS(str, pos);
          if (str[pos] !== ',') break
          pos = skipWS(str, pos + 1);
          if (str[pos] === ']') break
        }
      }

      if (str[pos] === ']') {
        pos++;
        marks.push({name: 'array_end', position: pos});
      } else {
        return {type: 'error', position: pos}
      }

      break
    case "'":
    case '"': {
      let result = parseString(str, pos);
      if (result.type === 'error') return result
      marks = result.marks;
      pos = result.position;
      break
    }
    case '^': {
      pos++;
      marks = [];
      while (str[pos] === '.' && str[pos + 1] === '^') {
        marks.push({name: 'dblparent', position: startPos});
        pos += 2;
      }
      marks.push({name: 'parent', position: startPos});
      break
    }
    case '@':
      marks = [{name: 'this', position: startPos}];
      pos++;
      break
    case '*':
      marks = [{name: 'everything', position: startPos}];
      pos++;
      break
    case '$': {
      let identLen = parseRegex(str, pos + 1, IDENT);
      if (identLen) {
        pos += 1 + identLen;
        marks = [
          {name: 'param', position: startPos},
          {name: 'ident', position: startPos + 1},
          {name: 'ident_end', position: pos},
        ];
      }
      break
    }
    default: {
      let numLen = parseRegex(str, pos, NUM);
      if (numLen) {
        pos += numLen;
        let name = 'integer';

        if (str[pos] === '.') {
          let fracLen = parseRegex(str, pos + 1, NUM);
          if (fracLen) {
            name = 'float';
            pos += 1 + fracLen;
          }
        }

        if (str[pos] === 'e' || str[pos] === 'E') {
          name = 'sci';
          pos++;
          if (str[pos] === '+' || str[pos] === '-') {
            pos++;
          }
          let expLen = parseRegex(str, pos, NUM);
          if (!expLen) return {type: 'error', position: pos}
          pos += expLen;
        }

        marks = [
          {name, position: startPos},
          {name: name + '_end', position: pos},
        ];

        break
      }

      let identLen = parseRegex(str, pos, IDENT);
      if (identLen) {
        pos += identLen;
        switch (str[pos]) {
          case ':':
          case '(': {
            let result = parseFuncCall(str, startPos, pos);
            if (result.type === 'error') return result
            marks = result.marks;
            pos = result.position;
            break
          }
          default: {
            marks = [
              {name: 'this_attr', position: startPos},
              {name: 'ident', position: startPos},
              {name: 'ident_end', position: pos},
            ];
          }
        }

        break
      }
    }
  }

  if (!marks) {
    return {type: 'error', position: pos}
  }

  let lhsLevel = 12;
  let trav;

  loop: while (true) {
    let innerPos = skipWS(str, pos);
    if (innerPos === str.length) {
      pos = innerPos;
      break
    }

    trav = parseTraversal(str, innerPos);
    if (trav.type === 'success') {
      marks.unshift({name: 'traverse', position: startPos});
      while (trav.type === 'success') {
        marks = marks.concat(trav.marks);
        pos = trav.position;
        trav = parseTraversal(str, skipWS(str, pos));
      }
      marks.push({name: 'traversal_end', position: pos});
      continue
    }

    let token = str[innerPos];
    switch (token) {
      case '=': {
        let nextToken = str[innerPos + 1];
        switch (nextToken) {
          case '>': {
            // =>
            if (level > PREC_PAIR || lhsLevel <= PREC_PAIR) break loop
            let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_PAIR);
            if (rhs.type === 'error') return rhs
            marks = marks.concat(rhs.marks);
            marks.unshift({name: 'pair', position: startPos});
            pos = rhs.position;
            lhsLevel = PREC_PAIR;
            break
          }
          case '=': {
            // ==
            if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop
            let rhs = parseExpr(str, skipWS(str, innerPos + 2), 5);
            if (rhs.type === 'error') return rhs
            marks.unshift({name: 'comp', position: startPos});
            marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 2});
            marks = marks.concat(rhs.marks);
            pos = rhs.position;
            lhsLevel = PREC_COMP;
            break
          }
          default:
            break loop
        }
        break
      }
      case '+': {
        if (level > PREC_ADD || lhsLevel < PREC_ADD) break loop
        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_ADD + 1);
        if (rhs.type === 'error') return rhs
        marks = marks.concat(rhs.marks);
        marks.unshift({name: 'add', position: startPos});
        pos = rhs.position;
        lhsLevel = PREC_ADD;
        break
      }
      case '-': {
        if (level > PREC_SUB || lhsLevel < PREC_SUB) break loop
        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_SUB + 1);
        if (rhs.type === 'error') return rhs
        marks = marks.concat(rhs.marks);
        marks.unshift({name: 'sub', position: startPos});
        pos = rhs.position;
        lhsLevel = PREC_SUB;
        break
      }
      case '*': {
        if (str[innerPos + 1] === '*') {
          // **
          if (level > PREC_POW || lhsLevel <= PREC_POW) break loop
          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_POW);
          if (rhs.type === 'error') return rhs
          marks = marks.concat(rhs.marks);
          marks.unshift({name: 'pow', position: startPos});
          pos = rhs.position;
          lhsLevel = PREC_POW;
          break
        }

        // *
        if (level > PREC_MUL || lhsLevel < PREC_MUL) break loop
        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MUL + 1);
        if (rhs.type === 'error') return rhs
        marks = marks.concat(rhs.marks);
        marks.unshift({name: 'mul', position: startPos});
        pos = rhs.position;
        lhsLevel = PREC_MUL;
        break
      }
      case '/': {
        if (level > PREC_DIV || lhsLevel < PREC_DIV) break loop
        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_DIV + 1);
        if (rhs.type === 'error') return rhs
        marks = marks.concat(rhs.marks);
        marks.unshift({name: 'div', position: startPos});
        pos = rhs.position;
        lhsLevel = PREC_DIV;
        break
      }
      case '%': {
        if (level > PREC_MOD || lhsLevel < PREC_MOD) break loop
        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MOD + 1);
        if (rhs.type === 'error') return rhs
        marks = marks.concat(rhs.marks);
        marks.unshift({name: 'mod', position: startPos});
        pos = rhs.position;
        lhsLevel = PREC_MOD;
        break
      }
      case '<':
      case '>': {
        if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop
        let nextPos = innerPos + 1;
        if (str[nextPos] === '=') {
          nextPos++;
        }
        let rhs = parseExpr(str, skipWS(str, nextPos), PREC_COMP + 1);
        if (rhs.type === 'error') return rhs
        marks.unshift({name: 'comp', position: startPos});
        marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: nextPos});
        marks = marks.concat(rhs.marks);
        pos = rhs.position;
        lhsLevel = PREC_COMP;
        break
      }
      case '|': {
        if (str[innerPos + 1] === '|') {
          // ||
          if (level > PREC_OR || lhsLevel < PREC_OR) break loop
          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_OR + 1);
          if (rhs.type === 'error') return rhs
          marks = marks.concat(rhs.marks);
          marks.unshift({name: 'or', position: startPos});
          pos = rhs.position;
          lhsLevel = PREC_OR;
        } else {
          if (level > 11 || lhsLevel < 11) break loop
          // pipe call
          let identPos = skipWS(str, innerPos + 1);
          let identLen = parseRegex(str, identPos, IDENT);
          if (!identLen) return {type: 'error', position: identPos}
          pos = identPos + identLen;
          if (str[pos] === '(' || str[pos] === ':') {
            let result = parseFuncCall(str, identPos, pos);
            if (result.type === 'error') return result
            marks = marks.concat(result.marks);
            marks.unshift({name: 'pipecall', position: startPos});
            pos = result.position;
            lhsLevel = 11;
          }
        }
        break
      }
      case '&': {
        // &&
        if (str[innerPos + 1] != '&') break loop
        if (level > PREC_AND || lhsLevel < PREC_AND) break loop
        let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_AND + 1);
        if (rhs.type === 'error') return rhs
        marks = marks.concat(rhs.marks);
        marks.unshift({name: 'and', position: startPos});
        pos = rhs.position;
        lhsLevel = PREC_AND;
        break
      }
      case '!': {
        // !=
        if (str[innerPos + 1] !== '=') break loop
        if (level > PREC_COMP || lhsLevel < PREC_COMP) break loop
        let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_COMP + 1);
        if (rhs.type === 'error') return rhs
        marks.unshift({name: 'comp', position: startPos});
        marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 2});
        marks = marks.concat(rhs.marks);
        pos = rhs.position;
        lhsLevel = PREC_COMP;
        break
      }
      case 'd': {
        // asc
        if (str.slice(innerPos, innerPos + 4) !== 'desc') break loop
        if (level > PREC_ORDER || lhsLevel < PREC_ORDER) break loop
        marks.unshift({name: 'desc', position: startPos});
        pos = innerPos + 4;
        lhsLevel = PREC_ORDER;
        break
      }
      case 'a': {
        // asc
        if (str.slice(innerPos, innerPos + 3) !== 'asc') break loop
        if (level > PREC_ORDER || lhsLevel < PREC_ORDER) break loop
        marks.unshift({name: 'asc', position: startPos});
        pos = innerPos + 3;
        lhsLevel = PREC_ORDER;
        break
      }
      default: {
        let ident = parseRegexStr(str, innerPos, IDENT);
        switch (ident) {
          case 'in': {
            if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop

            pos = skipWS(str, innerPos + 2);

            let isGroup = false;

            if (str[pos] === '(') {
              isGroup = true;
              pos = skipWS(str, pos + 1);
            }

            let rangePos = pos;
            let result = parseExpr(str, pos, PREC_COMP + 1);
            if (result.type === 'error') return result

            pos = skipWS(str, result.position);

            if (str[pos] === '.' && str[pos + 1] === '.') {
              // LHS in RANGE
              let type = 'inc_range';
              if (str[pos + 2] === '.') {
                type = 'exc_range';
                pos = skipWS(str, pos + 3);
              } else {
                pos = skipWS(str, pos + 2);
              }

              let rhs = parseExpr(str, pos, PREC_COMP + 1);
              if (rhs.type === 'error') return rhs
              marks.unshift({name: 'in_range', position: startPos});
              marks = marks.concat({name: type, position: rangePos}, result.marks, rhs.marks);
              pos = rhs.position;
            } else {
              // LHS in RHS
              marks.unshift({name: 'comp', position: startPos});
              marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 2});
              marks = marks.concat(result.marks);
            }

            if (isGroup) {
              pos = skipWS(str, pos);
              if (str[pos] !== ')') return {type: 'error', position: pos}
              pos++;
            }

            lhsLevel = PREC_COMP;
            break
          }
          case 'match': {
            // match operator
            if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop
            let rhs = parseExpr(str, skipWS(str, innerPos + 5), PREC_COMP + 1);
            if (rhs.type === 'error') return rhs
            marks.unshift({name: 'comp', position: startPos});
            marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 5});
            marks = marks.concat(rhs.marks);
            pos = rhs.position;
            lhsLevel = 4;
            break
          }
          default: {
            break loop
          }
        }
      }
    }
  }

  let failPosition = trav?.type === 'error' && trav.position;

  return {type: 'success', marks, position: pos, failPosition}
}

function parseTraversal(str, pos) {
  let startPos = pos;
  switch (str[pos]) {
    case '.': {
      pos = skipWS(str, pos + 1);
      let identStart = pos;
      let identLen = parseRegex(str, pos, IDENT);
      if (!identLen) return {type: 'error', position: pos}
      pos += identLen;

      return {
        type: 'success',
        marks: [
          {name: 'attr_access', position: startPos},
          {name: 'ident', position: identStart},
          {name: 'ident_end', position: pos},
        ],
        position: pos,
      }
    }
    case '-':
      if (str[pos + 1] !== '>') return {type: 'error', position: pos}
      // ->

      let marks = [{name: 'deref', position: startPos}];
      pos += 2;

      let identPos = skipWS(str, pos);
      let identLen = parseRegex(str, identPos, IDENT);
      if (identLen) {
        pos = identPos + identLen;
        marks.push(
          {name: 'deref_attr', position: identPos},
          {name: 'ident', position: identPos},
          {name: 'ident_end', position: pos}
        );
      }

      return {
        type: 'success',
        marks,
        position: pos,
      }
    case '[': {
      pos = skipWS(str, pos + 1);

      if (str[pos] === ']') {
        return {
          type: 'success',
          marks: [{name: 'array_postfix', position: startPos}],
          position: pos + 1,
        }
      }

      let rangePos = pos;
      let result = parseExpr(str, pos, 0);
      if (result.type === 'error') return result

      pos = skipWS(str, result.position);

      if (str[pos] === '.' && str[pos + 1] === '.') {
        let type = 'inc_range';
        if (str[pos + 2] === '.') {
          type = 'exc_range';
          pos += 3;
        } else {
          pos += 2;
        }

        pos = skipWS(str, pos);
        let rhs = parseExpr(str, pos, 0);
        if (rhs.type === 'error') return rhs
        pos = skipWS(str, rhs.position);
        if (str[pos] !== ']') return {type: 'error', position: pos}

        return {
          type: 'success',
          marks: [
            {name: 'slice', position: startPos},
            {name: type, position: rangePos},
          ].concat(result.marks, rhs.marks),
          position: pos + 1,
        }
      }

      if (str[pos] !== ']') return {type: 'error', position: pos}

      return {
        type: 'success',
        marks: [{name: 'square_bracket', position: startPos}].concat(result.marks),
        position: pos + 1,
      }
    }
    case '|': {
      pos = skipWS(str, pos + 1);
      if (str[pos] === '{') {
        let result = parseObject(str, pos);
        if (result.type === 'error') return result
        result.marks.unshift({name: 'projection', position: startPos});
        return result
      }
      break
    }
    case '{': {
      let result = parseObject(str, pos);
      if (result.type === 'error') return result
      result.marks.unshift({name: 'projection', position: startPos});
      return result
    }
  }

  return {type: 'error', position: pos}
}

function parseFuncCall(str, startPos, pos) {
  let marks = [];

  marks.push({name: 'func_call', position: startPos});

  if (str[pos] === ':' && str[pos + 1] === ':') {
    marks.push({name: 'namespace', position: startPos});
    marks.push({name: 'ident', position: startPos}, {name: 'ident_end', position: pos});
    pos = skipWS(str, pos + 2);
    let nameLen = parseRegex(str, pos, IDENT);
    if (!nameLen) return {type: 'error', position: pos}
    marks.push({name: 'ident', position: pos}, {name: 'ident_end', position: pos + nameLen});
    pos = skipWS(str, pos + nameLen);
    if (str[pos] !== '(') return {type: 'error', position: pos}
    pos++;
  } else {
    marks.push({name: 'ident', position: startPos}, {name: 'ident_end', position: pos});
    pos = skipWS(str, pos + 1);
  }

  let lastPos = pos;

  if (str[pos] !== ')') {
    while (true) {
      let result = parseExpr(str, pos, 0);
      if (result.type === 'error') return result
      marks = marks.concat(result.marks);
      lastPos = result.position;
      pos = skipWS(str, result.position);
      if (str[pos] !== ',') break
      pos = skipWS(str, pos + 1);
      // Also allow trailing commas
      if (str[pos] === ')') break
    }
  }

  if (str[pos] !== ')') {
    return {type: 'error', position: pos}
  }

  // NOTE: a bit arbitrary the func_args_end points comes before the whitespace.
  marks.push({name: 'func_args_end', position: lastPos});

  return {
    type: 'success',
    marks,
    position: pos + 1,
  }
}

function parseObject(str, pos) {
  let marks = [{name: 'object', position: pos}];
  pos = skipWS(str, pos + 1);

  while (str[pos] !== '}') {
    let pairPos = pos;

    if (str.slice(pos, pos + 3) === '...') {
      pos = skipWS(str, pos + 3);
      if (str[pos] !== '}' && str[pos] !== ',') {
        let expr = parseExpr(str, pos, 0);
        if (expr.type === 'error') return expr
        marks.push({name: 'object_splat', position: pairPos});
        marks = marks.concat(expr.marks);
        pos = expr.position;
      } else {
        marks.push({name: 'object_splat_this', position: pairPos});
      }
    } else {
      let expr = parseExpr(str, pos, 0);
      if (expr.type === 'error') return expr
      let nextPos = skipWS(str, expr.position);
      if (expr.marks[0].name === 'str' && str[nextPos] === ':') {
        let value = parseExpr(str, skipWS(str, nextPos + 1), 0);
        if (value.type === 'error') return value
        marks.push({name: 'object_pair', position: pairPos});
        marks = marks.concat(expr.marks, value.marks);
        pos = value.position;
      } else {
        marks = marks.concat({name: 'object_expr', position: pos}, expr.marks);
        pos = expr.position;
      }
    }
    pos = skipWS(str, pos);
    if (str[pos] !== ',') break
    pos = skipWS(str, pos + 1);
  }

  if (str[pos] !== '}') {
    return {type: 'error', position: pos}
  }

  pos++;
  marks.push({name: 'object_end', position: pos});
  return {type: 'success', marks, position: pos}
}

function parseString(str, pos) {
  let token = str[pos];
  pos = pos + 1;
  const marks = [{name: 'str', position: pos}];
  str: for (; ; pos++) {
    if (pos > str.length) return {type: 'error', position: pos}

    switch (str[pos]) {
      case token: {
        marks.push({name: 'str_end', position: pos});
        pos++;
        break str
      }
      case '\\': {
        marks.push({name: 'str_pause', position: pos});
        if (str[pos + 1] === 'u') {
          if (str[pos + 2] === '{') {
            marks.push({name: 'unicode_hex', position: pos + 3});
            pos = str.indexOf('}', pos + 3);
            marks.push({name: 'unicode_hex_end', position: pos});
          } else {
            marks.push({name: 'unicode_hex', position: pos + 2});
            marks.push({name: 'unicode_hex_end', position: pos + 6});
            pos += 5;
          }
        } else {
          marks.push({name: 'single_escape', position: pos + 1});
          pos += 1;
        }
        marks.push({name: 'str_start', position: pos + 1});
      }
    }
  }

  return {type: 'success', marks, position: pos}
}

function skipWS(str, pos) {
  return pos + parseRegex(str, pos, WS)
}

/**
 * Parses a regex at a position and returns the number of characters that was matched.
 */
function parseRegex(str, pos, re) {
  let m = re.exec(str.slice(pos));
  return m ? m[0].length : 0
}

/**
 * Parses a regex at a position and returns matched string.
 */
function parseRegexStr(str, pos, re) {
  let m = re.exec(str.slice(pos));
  return m ? m[0] : null
}/**
 * Join combines two traversals, returning a mapper which is the result of first
 * applying `a` and then applying `b`.
 */
function join(a, b) {
    return function (base) { return b(a(base)); };
}
/**
 * Map returns a new mapper which will the inner mappe to each element of the array.
 */
function map(inner) {
    return function (base) { return ({ type: 'Map', base: base, expr: inner({ type: 'This' }) }); };
}
function flatMap(inner) {
    return function (base) { return ({ type: 'FlatMap', base: base, expr: inner({ type: 'This' }) }); };
}
function traverseArray(build, right) {
    if (!right) {
        return {
            type: 'a-a',
            build: build
        };
    }
    switch (right.type) {
        case 'a-a':
            return {
                type: 'a-a',
                build: join(build, right.build)
            };
        case 'a-b':
            return {
                type: 'a-b',
                build: join(build, right.build)
            };
        case 'b-b':
            return {
                type: 'a-a',
                build: join(build, map(right.build))
            };
        case 'b-a':
            return {
                type: 'a-a',
                build: join(build, flatMap(right.build))
            };
        default:
            throw new Error("unknown type: ".concat(right.type));
    }
}
function traversePlain(mapper, right) {
    if (!right) {
        return {
            type: 'b-b',
            build: mapper
        };
    }
    switch (right.type) {
        case 'a-a':
        case 'b-a':
            return {
                type: 'b-a',
                build: join(mapper, right.build)
            };
        case 'a-b':
        case 'b-b':
            return {
                type: 'b-b',
                build: join(mapper, right.build)
            };
        default:
            throw new Error("unknown type: ".concat(right.type));
    }
}
function traverseElement(mapper, right) {
    if (!right) {
        return {
            type: 'a-b',
            build: mapper
        };
    }
    switch (right.type) {
        case 'a-a':
        case 'b-a':
            return {
                type: 'a-a',
                build: join(mapper, right.build)
            };
        case 'a-b':
        case 'b-b':
            return {
                type: 'a-b',
                build: join(mapper, right.build)
            };
        default:
            throw new Error("unknown type: ".concat(right.type));
    }
}
function traverseProjection(mapper, right) {
    if (!right) {
        return {
            type: 'b-b',
            build: mapper
        };
    }
    switch (right.type) {
        case 'a-a':
            return {
                type: 'a-a',
                build: join(map(mapper), right.build)
            };
        case 'a-b':
            return {
                type: 'a-b',
                build: join(map(mapper), right.build)
            };
        case 'b-a':
            return {
                type: 'b-a',
                build: join(mapper, right.build)
            };
        case 'b-b':
            return {
                type: 'b-b',
                build: join(mapper, right.build)
            };
        default:
            throw new Error("unknown type: ".concat(right.type));
    }
}var isEqual = equality;
function equality(a, b) {
    if ((a.type === 'string' && b.type === 'string') ||
        (a.type === 'boolean' && b.type === 'boolean') ||
        (a.type === 'null' && b.type === 'null') ||
        (a.type === 'number' && b.type === 'number')) {
        return a.data === b.data;
    }
    if (a.type === 'datetime' && b.type === 'datetime') {
        return a.data.equals(b.data);
    }
    return false;
}var operators = {
    '==': function eq(left, right) {
        return isEqual(left, right) ? TRUE_VALUE : FALSE_VALUE;
    },
    '!=': function neq(left, right) {
        return isEqual(left, right) ? FALSE_VALUE : TRUE_VALUE;
    },
    '>': function gt(left, right) {
        if (left.type === 'stream' || right.type === 'stream')
            return NULL_VALUE;
        var result = partialCompare(left.data, right.data);
        if (result === null) {
            return NULL_VALUE;
        }
        return result > 0 ? TRUE_VALUE : FALSE_VALUE;
    },
    '>=': function gte(left, right) {
        if (left.type === 'stream' || right.type === 'stream')
            return NULL_VALUE;
        var result = partialCompare(left.data, right.data);
        if (result === null) {
            return NULL_VALUE;
        }
        return result >= 0 ? TRUE_VALUE : FALSE_VALUE;
    },
    '<': function lt(left, right) {
        if (left.type === 'stream' || right.type === 'stream')
            return NULL_VALUE;
        var result = partialCompare(left.data, right.data);
        if (result === null) {
            return NULL_VALUE;
        }
        return result < 0 ? TRUE_VALUE : FALSE_VALUE;
    },
    '<=': function lte(left, right) {
        if (left.type === 'stream' || right.type === 'stream')
            return NULL_VALUE;
        var result = partialCompare(left.data, right.data);
        if (result === null) {
            return NULL_VALUE;
        }
        return result <= 0 ? TRUE_VALUE : FALSE_VALUE;
    },
    // eslint-disable-next-line func-name-matching
    "in": function inop(left, right) {
        var right_1, right_1_1;
        var e_1, _a;
        return __awaiter(this, void 0, void 0, function () {
            var b, e_1_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (right.type === 'path') {
                            if (left.type !== 'string') {
                                return [2 /*return*/, NULL_VALUE];
                            }
                            return [2 /*return*/, right.data.matches(left.data) ? TRUE_VALUE : FALSE_VALUE];
                        }
                        if (!right.isArray()) return [3 /*break*/, 13];
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 6, 7, 12]);
                        right_1 = __asyncValues(right);
                        _b.label = 2;
                    case 2: return [4 /*yield*/, right_1.next()];
                    case 3:
                        if (!(right_1_1 = _b.sent(), !right_1_1.done)) return [3 /*break*/, 5];
                        b = right_1_1.value;
                        if (isEqual(left, b)) {
                            return [2 /*return*/, TRUE_VALUE];
                        }
                        _b.label = 4;
                    case 4: return [3 /*break*/, 2];
                    case 5: return [3 /*break*/, 12];
                    case 6:
                        e_1_1 = _b.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 12];
                    case 7:
                        _b.trys.push([7, , 10, 11]);
                        if (!(right_1_1 && !right_1_1.done && (_a = right_1["return"]))) return [3 /*break*/, 9];
                        return [4 /*yield*/, _a.call(right_1)];
                    case 8:
                        _b.sent();
                        _b.label = 9;
                    case 9: return [3 /*break*/, 11];
                    case 10:
                        if (e_1) throw e_1.error;
                        return [7 /*endfinally*/];
                    case 11: return [7 /*endfinally*/];
                    case 12: return [2 /*return*/, FALSE_VALUE];
                    case 13: return [2 /*return*/, NULL_VALUE];
                }
            });
        });
    },
    match: function match(left, right) {
        return __awaiter(this, void 0, void 0, function () {
            var tokens, patterns, didSucceed, matched;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tokens = [];
                        patterns = [];
                        return [4 /*yield*/, gatherText(left, function (part) {
                                tokens = tokens.concat(matchTokenize(part));
                            })];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, gatherText(right, function (part) {
                                patterns = patterns.concat(matchAnalyzePattern(part));
                            })];
                    case 2:
                        didSucceed = _a.sent();
                        if (!didSucceed) {
                            return [2 /*return*/, FALSE_VALUE];
                        }
                        matched = matchText(tokens, patterns);
                        return [2 /*return*/, matched ? TRUE_VALUE : FALSE_VALUE];
                }
            });
        });
    },
    '+': function plus(left, right) {
        if (left.type === 'datetime' && right.type === 'number') {
            return fromDateTime(left.data.add(right.data));
        }
        if (left.type === 'number' && right.type === 'number') {
            return fromNumber(left.data + right.data);
        }
        if (left.type === 'string' && right.type === 'string') {
            return fromString(left.data + right.data);
        }
        if (left.type === 'object' && right.type === 'object') {
            return fromJS(__assign(__assign({}, left.data), right.data));
        }
        if (left.type === 'array' && right.type === 'array') {
            return fromJS(left.data.concat(right.data));
        }
        if (left.isArray() && right.isArray()) {
            return new StreamValue(function () {
                return __asyncGenerator(this, arguments, function () {
                    var left_1, left_1_1, val, e_2_1, right_2, right_2_1, val, e_3_1;
                    var e_2, _a, e_3, _b;
                    return __generator(this, function (_c) {
                        switch (_c.label) {
                            case 0:
                                _c.trys.push([0, 7, 8, 13]);
                                left_1 = __asyncValues(left);
                                _c.label = 1;
                            case 1: return [4 /*yield*/, __await(left_1.next())];
                            case 2:
                                if (!(left_1_1 = _c.sent(), !left_1_1.done)) return [3 /*break*/, 6];
                                val = left_1_1.value;
                                return [4 /*yield*/, __await(val)];
                            case 3: return [4 /*yield*/, _c.sent()];
                            case 4:
                                _c.sent();
                                _c.label = 5;
                            case 5: return [3 /*break*/, 1];
                            case 6: return [3 /*break*/, 13];
                            case 7:
                                e_2_1 = _c.sent();
                                e_2 = { error: e_2_1 };
                                return [3 /*break*/, 13];
                            case 8:
                                _c.trys.push([8, , 11, 12]);
                                if (!(left_1_1 && !left_1_1.done && (_a = left_1["return"]))) return [3 /*break*/, 10];
                                return [4 /*yield*/, __await(_a.call(left_1))];
                            case 9:
                                _c.sent();
                                _c.label = 10;
                            case 10: return [3 /*break*/, 12];
                            case 11:
                                if (e_2) throw e_2.error;
                                return [7 /*endfinally*/];
                            case 12: return [7 /*endfinally*/];
                            case 13:
                                _c.trys.push([13, 20, 21, 26]);
                                right_2 = __asyncValues(right);
                                _c.label = 14;
                            case 14: return [4 /*yield*/, __await(right_2.next())];
                            case 15:
                                if (!(right_2_1 = _c.sent(), !right_2_1.done)) return [3 /*break*/, 19];
                                val = right_2_1.value;
                                return [4 /*yield*/, __await(val)];
                            case 16: return [4 /*yield*/, _c.sent()];
                            case 17:
                                _c.sent();
                                _c.label = 18;
                            case 18: return [3 /*break*/, 14];
                            case 19: return [3 /*break*/, 26];
                            case 20:
                                e_3_1 = _c.sent();
                                e_3 = { error: e_3_1 };
                                return [3 /*break*/, 26];
                            case 21:
                                _c.trys.push([21, , 24, 25]);
                                if (!(right_2_1 && !right_2_1.done && (_b = right_2["return"]))) return [3 /*break*/, 23];
                                return [4 /*yield*/, __await(_b.call(right_2))];
                            case 22:
                                _c.sent();
                                _c.label = 23;
                            case 23: return [3 /*break*/, 25];
                            case 24:
                                if (e_3) throw e_3.error;
                                return [7 /*endfinally*/];
                            case 25: return [7 /*endfinally*/];
                            case 26: return [2 /*return*/];
                        }
                    });
                });
            });
        }
        return NULL_VALUE;
    },
    '-': function minus(left, right) {
        if (left.type === 'datetime' && right.type === 'number') {
            return fromDateTime(left.data.add(-right.data));
        }
        if (left.type === 'datetime' && right.type === 'datetime') {
            return fromNumber(left.data.difference(right.data));
        }
        if (left.type === 'number' && right.type === 'number') {
            return fromNumber(left.data - right.data);
        }
        return NULL_VALUE;
    },
    '*': numericOperator(function (a, b) { return a * b; }),
    '/': numericOperator(function (a, b) { return a / b; }),
    '%': numericOperator(function (a, b) { return a % b; }),
    '**': numericOperator(function (a, b) { return Math.pow(a, b); })
};
function numericOperator(impl) {
    return function (left, right) {
        if (left.type === 'number' && right.type === 'number') {
            var result = impl(left.data, right.data);
            return fromNumber(result);
        }
        return NULL_VALUE;
    };
}var Scope = /** @class */ (function () {
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    function Scope(params, source, value, context, parent) {
        this.isHidden = false;
        this.params = params;
        this.source = source;
        this.value = value;
        this.context = context;
        this.parent = parent;
    }
    Scope.prototype.createNested = function (value) {
        if (this.isHidden) {
            return new Scope(this.params, this.source, value, this.context, this.parent);
        }
        return new Scope(this.params, this.source, value, this.context, this);
    };
    Scope.prototype.createHidden = function (value) {
        var result = this.createNested(value);
        result.isHidden = true;
        return result;
    };
    return Scope;
}());function evaluate(node, scope, execute) {
    if (execute === void 0) { execute = evaluate; }
    var func = EXECUTORS[node.type];
    return func(node, scope, execute);
}
/**
 * Applies the function to a value, but tries to avoid creating unnecessary promises.
 */
function promiselessApply(value, cb) {
    if ('then' in value) {
        return value.then(cb);
    }
    return cb(value);
}
var EXECUTORS = {
    This: function (_, scope) {
        return scope.value;
    },
    Selector: function () {
        // These should be evaluated separely using a different evaluator.
        // At the mooment we haven't implemented this.
        throw new Error('Selectors can not be evaluated');
    },
    Everything: function (_, scope) {
        return scope.source;
    },
    Parameter: function (_a, scope) {
        var name = _a.name;
        return fromJS(scope.params[name]);
    },
    Context: function (_a, scope) {
        var key = _a.key;
        if (key === 'before' || key === 'after') {
            var value = scope.context[key];
            return value || NULL_VALUE;
        }
        throw new Error("unknown context key: ".concat(key));
    },
    Parent: function (_a, scope) {
        var n = _a.n;
        var current = scope;
        for (var i = 0; i < n; i++) {
            if (!current.parent) {
                return NULL_VALUE;
            }
            current = current.parent;
        }
        return current.value;
    },
    OpCall: function (_a, scope, execute) {
        var _this = this;
        var op = _a.op, left = _a.left, right = _a.right;
        var func = operators[op];
        if (!func) {
            throw new Error("Unknown operator: ".concat(op));
        }
        var leftValue = execute(left, scope);
        var rightValue = execute(right, scope);
        // Avoid uneccesary promises
        // This is required for constant evaluation to work correctly.
        if ('then' in leftValue || 'then' in rightValue) {
            return (function () { return __awaiter(_this, void 0, void 0, function () { var _a, _b; return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = func;
                        return [4 /*yield*/, leftValue];
                    case 1:
                        _b = [_c.sent()];
                        return [4 /*yield*/, rightValue];
                    case 2: return [2 /*return*/, _a.apply(void 0, _b.concat([_c.sent()]))];
                }
            }); }); })();
        }
        return func(leftValue, rightValue);
    },
    Select: function (_a, scope, execute) {
        var alternatives = _a.alternatives, fallback = _a.fallback;
        return __awaiter(this, void 0, void 0, function () {
            var _i, alternatives_1, alt, altCond;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _i = 0, alternatives_1 = alternatives;
                        _b.label = 1;
                    case 1:
                        if (!(_i < alternatives_1.length)) return [3 /*break*/, 4];
                        alt = alternatives_1[_i];
                        return [4 /*yield*/, execute(alt.condition, scope)];
                    case 2:
                        altCond = _b.sent();
                        if (altCond.type === 'boolean' && altCond.data === true) {
                            return [2 /*return*/, execute(alt.value, scope)];
                        }
                        _b.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4:
                        if (fallback) {
                            return [2 /*return*/, execute(fallback, scope)];
                        }
                        return [2 /*return*/, NULL_VALUE];
                }
            });
        });
    },
    InRange: function (_a, scope, execute) {
        var base = _a.base, left = _a.left, right = _a.right, isInclusive = _a.isInclusive;
        return __awaiter(this, void 0, void 0, function () {
            var value, leftValue, rightValue, leftCmp, _b, _c, rightCmp, _d, _e;
            return __generator(this, function (_f) {
                switch (_f.label) {
                    case 0: return [4 /*yield*/, execute(base, scope)];
                    case 1:
                        value = _f.sent();
                        return [4 /*yield*/, execute(left, scope)];
                    case 2:
                        leftValue = _f.sent();
                        return [4 /*yield*/, execute(right, scope)];
                    case 3:
                        rightValue = _f.sent();
                        _b = partialCompare;
                        return [4 /*yield*/, value.get()];
                    case 4:
                        _c = [_f.sent()];
                        return [4 /*yield*/, leftValue.get()];
                    case 5:
                        leftCmp = _b.apply(void 0, _c.concat([_f.sent()]));
                        if (leftCmp === null) {
                            return [2 /*return*/, NULL_VALUE];
                        }
                        _d = partialCompare;
                        return [4 /*yield*/, value.get()];
                    case 6:
                        _e = [_f.sent()];
                        return [4 /*yield*/, rightValue.get()];
                    case 7:
                        rightCmp = _d.apply(void 0, _e.concat([_f.sent()]));
                        if (rightCmp === null) {
                            return [2 /*return*/, NULL_VALUE];
                        }
                        if (isInclusive) {
                            return [2 /*return*/, leftCmp >= 0 && rightCmp <= 0 ? TRUE_VALUE : FALSE_VALUE];
                        }
                        return [2 /*return*/, leftCmp >= 0 && rightCmp < 0 ? TRUE_VALUE : FALSE_VALUE];
                }
            });
        });
    },
    Filter: function (_a, scope, execute) {
        var base = _a.base, expr = _a.expr;
        return __awaiter(this, void 0, void 0, function () {
            var baseValue;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, execute(base, scope)];
                    case 1:
                        baseValue = _b.sent();
                        if (!baseValue.isArray()) {
                            return [2 /*return*/, NULL_VALUE];
                        }
                        return [2 /*return*/, new StreamValue(function () {
                                return __asyncGenerator(this, arguments, function () {
                                    var baseValue_1, baseValue_1_1, elem, newScope, exprValue, e_1_1;
                                    var e_1, _a;
                                    return __generator(this, function (_b) {
                                        switch (_b.label) {
                                            case 0:
                                                _b.trys.push([0, 8, 9, 14]);
                                                baseValue_1 = __asyncValues(baseValue);
                                                _b.label = 1;
                                            case 1: return [4 /*yield*/, __await(baseValue_1.next())];
                                            case 2:
                                                if (!(baseValue_1_1 = _b.sent(), !baseValue_1_1.done)) return [3 /*break*/, 7];
                                                elem = baseValue_1_1.value;
                                                newScope = scope.createNested(elem);
                                                return [4 /*yield*/, __await(execute(expr, newScope))];
                                            case 3:
                                                exprValue = _b.sent();
                                                if (!(exprValue.type === 'boolean' && exprValue.data === true)) return [3 /*break*/, 6];
                                                return [4 /*yield*/, __await(elem)];
                                            case 4: return [4 /*yield*/, _b.sent()];
                                            case 5:
                                                _b.sent();
                                                _b.label = 6;
                                            case 6: return [3 /*break*/, 1];
                                            case 7: return [3 /*break*/, 14];
                                            case 8:
                                                e_1_1 = _b.sent();
                                                e_1 = { error: e_1_1 };
                                                return [3 /*break*/, 14];
                                            case 9:
                                                _b.trys.push([9, , 12, 13]);
                                                if (!(baseValue_1_1 && !baseValue_1_1.done && (_a = baseValue_1["return"]))) return [3 /*break*/, 11];
                                                return [4 /*yield*/, __await(_a.call(baseValue_1))];
                                            case 10:
                                                _b.sent();
                                                _b.label = 11;
                                            case 11: return [3 /*break*/, 13];
                                            case 12:
                                                if (e_1) throw e_1.error;
                                                return [7 /*endfinally*/];
                                            case 13: return [7 /*endfinally*/];
                                            case 14: return [2 /*return*/];
                                        }
                                    });
                                });
                            })];
                }
            });
        });
    },
    Projection: function (_a, scope, execute) {
        var base = _a.base, expr = _a.expr;
        return __awaiter(this, void 0, void 0, function () {
            var baseValue, newScope;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, execute(base, scope)];
                    case 1:
                        baseValue = _b.sent();
                        if (baseValue.type !== 'object') {
                            return [2 /*return*/, NULL_VALUE];
                        }
                        newScope = scope.createNested(baseValue);
                        return [2 /*return*/, execute(expr, newScope)];
                }
            });
        });
    },
    FuncCall: function (_a, scope, execute) {
        var func = _a.func, args = _a.args;
        return func(args, scope, execute);
    },
    PipeFuncCall: function (_a, scope, execute) {
        var func = _a.func, base = _a.base, args = _a.args;
        return __awaiter(this, void 0, void 0, function () {
            var baseValue;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, execute(base, scope)];
                    case 1:
                        baseValue = _b.sent();
                        return [2 /*return*/, func(baseValue, args, scope, execute)];
                }
            });
        });
    },
    AccessAttribute: function (_a, scope, execute) {
        var base = _a.base, name = _a.name;
        return __awaiter(this, void 0, void 0, function () {
            var value;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        value = scope.value;
                        if (!base) return [3 /*break*/, 2];
                        return [4 /*yield*/, execute(base, scope)];
                    case 1:
                        value = _b.sent();
                        _b.label = 2;
                    case 2:
                        if (value.type === 'object') {
                            if (value.data.hasOwnProperty(name)) {
                                return [2 /*return*/, fromJS(value.data[name])];
                            }
                        }
                        return [2 /*return*/, NULL_VALUE];
                }
            });
        });
    },
    AccessElement: function (_a, scope, execute) {
        var base = _a.base, index = _a.index;
        return __awaiter(this, void 0, void 0, function () {
            var baseValue, data, finalIndex;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, execute(base, scope)];
                    case 1:
                        baseValue = _b.sent();
                        if (!baseValue.isArray()) {
                            return [2 /*return*/, NULL_VALUE];
                        }
                        return [4 /*yield*/, baseValue.get()];
                    case 2:
                        data = _b.sent();
                        finalIndex = index < 0 ? index + data.length : index;
                        return [2 /*return*/, fromJS(data[finalIndex])];
                }
            });
        });
    },
    Slice: function (_a, scope, execute) {
        var base = _a.base, left = _a.left, right = _a.right, isInclusive = _a.isInclusive;
        return __awaiter(this, void 0, void 0, function () {
            var baseValue, array, leftIdx, rightIdx;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, execute(base, scope)];
                    case 1:
                        baseValue = _b.sent();
                        if (!baseValue.isArray()) {
                            return [2 /*return*/, NULL_VALUE];
                        }
                        return [4 /*yield*/, baseValue.get()];
                    case 2:
                        array = (_b.sent());
                        leftIdx = left;
                        rightIdx = right;
                        // Handle negative index
                        if (leftIdx < 0) {
                            leftIdx = array.length + leftIdx;
                        }
                        if (rightIdx < 0) {
                            rightIdx = array.length + rightIdx;
                        }
                        // Convert from inclusive to exclusive index
                        if (isInclusive) {
                            rightIdx++;
                        }
                        if (leftIdx < 0) {
                            leftIdx = 0;
                        }
                        if (rightIdx < 0) {
                            rightIdx = 0;
                        }
                        // Note: At this point the indices might point out-of-bound, but
                        // .slice handles this correctly.
                        return [2 /*return*/, fromJS(array.slice(leftIdx, rightIdx))];
                }
            });
        });
    },
    Deref: function (_a, scope, execute) {
        var e_2, _b;
        var base = _a.base;
        return __awaiter(this, void 0, void 0, function () {
            var value, id, _c, _d, doc, e_2_1;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0: return [4 /*yield*/, execute(base, scope)];
                    case 1:
                        value = _e.sent();
                        if (!scope.source.isArray()) {
                            return [2 /*return*/, NULL_VALUE];
                        }
                        if (value.type !== 'object') {
                            return [2 /*return*/, NULL_VALUE];
                        }
                        id = value.data._ref;
                        if (typeof id !== 'string') {
                            return [2 /*return*/, NULL_VALUE];
                        }
                        _e.label = 2;
                    case 2:
                        _e.trys.push([2, 7, 8, 13]);
                        _c = __asyncValues(scope.source);
                        _e.label = 3;
                    case 3: return [4 /*yield*/, _c.next()];
                    case 4:
                        if (!(_d = _e.sent(), !_d.done)) return [3 /*break*/, 6];
                        doc = _d.value;
                        if (doc.type === 'object' && id === doc.data._id) {
                            return [2 /*return*/, doc];
                        }
                        _e.label = 5;
                    case 5: return [3 /*break*/, 3];
                    case 6: return [3 /*break*/, 13];
                    case 7:
                        e_2_1 = _e.sent();
                        e_2 = { error: e_2_1 };
                        return [3 /*break*/, 13];
                    case 8:
                        _e.trys.push([8, , 11, 12]);
                        if (!(_d && !_d.done && (_b = _c["return"]))) return [3 /*break*/, 10];
                        return [4 /*yield*/, _b.call(_c)];
                    case 9:
                        _e.sent();
                        _e.label = 10;
                    case 10: return [3 /*break*/, 12];
                    case 11:
                        if (e_2) throw e_2.error;
                        return [7 /*endfinally*/];
                    case 12: return [7 /*endfinally*/];
                    case 13: return [2 /*return*/, NULL_VALUE];
                }
            });
        });
    },
    Value: function (_a) {
        var value = _a.value;
        return fromJS(value);
    },
    Group: function (_a, scope, execute) {
        var base = _a.base;
        return execute(base, scope);
    },
    Object: function (_a, scope, execute) {
        var attributes = _a.attributes;
        return __awaiter(this, void 0, void 0, function () {
            var result, _i, attributes_1, attr, attrType, _b, value, _c, _d, cond, value, value;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        result = {};
                        _i = 0, attributes_1 = attributes;
                        _e.label = 1;
                    case 1:
                        if (!(_i < attributes_1.length)) return [3 /*break*/, 12];
                        attr = attributes_1[_i];
                        attrType = attr.type;
                        _b = attr.type;
                        switch (_b) {
                            case 'ObjectAttributeValue': return [3 /*break*/, 2];
                            case 'ObjectConditionalSplat': return [3 /*break*/, 5];
                            case 'ObjectSplat': return [3 /*break*/, 8];
                        }
                        return [3 /*break*/, 10];
                    case 2: return [4 /*yield*/, execute(attr.value, scope)];
                    case 3:
                        value = _e.sent();
                        _c = result;
                        _d = attr.name;
                        return [4 /*yield*/, value.get()];
                    case 4:
                        _c[_d] = _e.sent();
                        return [3 /*break*/, 11];
                    case 5: return [4 /*yield*/, execute(attr.condition, scope)];
                    case 6:
                        cond = _e.sent();
                        if (cond.type !== 'boolean' || cond.data === false) {
                            return [3 /*break*/, 11];
                        }
                        return [4 /*yield*/, execute(attr.value, scope)];
                    case 7:
                        value = _e.sent();
                        if (value.type === 'object') {
                            Object.assign(result, value.data);
                        }
                        return [3 /*break*/, 11];
                    case 8: return [4 /*yield*/, execute(attr.value, scope)];
                    case 9:
                        value = _e.sent();
                        if (value.type === 'object') {
                            Object.assign(result, value.data);
                        }
                        return [3 /*break*/, 11];
                    case 10: throw new Error("Unknown node type: ".concat(attrType));
                    case 11:
                        _i++;
                        return [3 /*break*/, 1];
                    case 12: return [2 /*return*/, fromJS(result)];
                }
            });
        });
    },
    Array: function (_a, scope, execute) {
        var elements = _a.elements;
        return new StreamValue(function () {
            return __asyncGenerator(this, arguments, function () {
                var _i, elements_1, element, value, value_1, value_1_1, v, e_3_1;
                var e_3, _a;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            _i = 0, elements_1 = elements;
                            _b.label = 1;
                        case 1:
                            if (!(_i < elements_1.length)) return [3 /*break*/, 21];
                            element = elements_1[_i];
                            return [4 /*yield*/, __await(execute(element.value, scope))];
                        case 2:
                            value = _b.sent();
                            if (!element.isSplat) return [3 /*break*/, 17];
                            if (!value.isArray()) return [3 /*break*/, 16];
                            _b.label = 3;
                        case 3:
                            _b.trys.push([3, 10, 11, 16]);
                            value_1 = (e_3 = void 0, __asyncValues(value));
                            _b.label = 4;
                        case 4: return [4 /*yield*/, __await(value_1.next())];
                        case 5:
                            if (!(value_1_1 = _b.sent(), !value_1_1.done)) return [3 /*break*/, 9];
                            v = value_1_1.value;
                            return [4 /*yield*/, __await(v)];
                        case 6: return [4 /*yield*/, _b.sent()];
                        case 7:
                            _b.sent();
                            _b.label = 8;
                        case 8: return [3 /*break*/, 4];
                        case 9: return [3 /*break*/, 16];
                        case 10:
                            e_3_1 = _b.sent();
                            e_3 = { error: e_3_1 };
                            return [3 /*break*/, 16];
                        case 11:
                            _b.trys.push([11, , 14, 15]);
                            if (!(value_1_1 && !value_1_1.done && (_a = value_1["return"]))) return [3 /*break*/, 13];
                            return [4 /*yield*/, __await(_a.call(value_1))];
                        case 12:
                            _b.sent();
                            _b.label = 13;
                        case 13: return [3 /*break*/, 15];
                        case 14:
                            if (e_3) throw e_3.error;
                            return [7 /*endfinally*/];
                        case 15: return [7 /*endfinally*/];
                        case 16: return [3 /*break*/, 20];
                        case 17: return [4 /*yield*/, __await(value)];
                        case 18: return [4 /*yield*/, _b.sent()];
                        case 19:
                            _b.sent();
                            _b.label = 20;
                        case 20:
                            _i++;
                            return [3 /*break*/, 1];
                        case 21: return [2 /*return*/];
                    }
                });
            });
        });
    },
    Tuple: function () {
        throw new Error('tuples can not be evaluated');
    },
    Or: function (_a, scope, execute) {
        var left = _a.left, right = _a.right;
        return __awaiter(this, void 0, void 0, function () {
            var leftValue, rightValue;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, execute(left, scope)];
                    case 1:
                        leftValue = _b.sent();
                        return [4 /*yield*/, execute(right, scope)];
                    case 2:
                        rightValue = _b.sent();
                        if (leftValue.type === 'boolean') {
                            if (leftValue.data === true) {
                                return [2 /*return*/, TRUE_VALUE];
                            }
                        }
                        if (rightValue.type === 'boolean') {
                            if (rightValue.data === true) {
                                return [2 /*return*/, TRUE_VALUE];
                            }
                        }
                        if (leftValue.type !== 'boolean' || rightValue.type !== 'boolean') {
                            return [2 /*return*/, NULL_VALUE];
                        }
                        return [2 /*return*/, FALSE_VALUE];
                }
            });
        });
    },
    And: function (_a, scope, execute) {
        var left = _a.left, right = _a.right;
        return __awaiter(this, void 0, void 0, function () {
            var leftValue, rightValue;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, execute(left, scope)];
                    case 1:
                        leftValue = _b.sent();
                        return [4 /*yield*/, execute(right, scope)];
                    case 2:
                        rightValue = _b.sent();
                        if (leftValue.type === 'boolean') {
                            if (leftValue.data === false) {
                                return [2 /*return*/, FALSE_VALUE];
                            }
                        }
                        if (rightValue.type === 'boolean') {
                            if (rightValue.data === false) {
                                return [2 /*return*/, FALSE_VALUE];
                            }
                        }
                        if (leftValue.type !== 'boolean' || rightValue.type !== 'boolean') {
                            return [2 /*return*/, NULL_VALUE];
                        }
                        return [2 /*return*/, TRUE_VALUE];
                }
            });
        });
    },
    Not: function (_a, scope, execute) {
        var base = _a.base;
        return __awaiter(this, void 0, void 0, function () {
            var value;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, execute(base, scope)];
                    case 1:
                        value = _b.sent();
                        if (value.type !== 'boolean') {
                            return [2 /*return*/, NULL_VALUE];
                        }
                        return [2 /*return*/, value.data ? FALSE_VALUE : TRUE_VALUE];
                }
            });
        });
    },
    Neg: function (_a, scope, execute) {
        var base = _a.base;
        return promiselessApply(execute(base, scope), function (value) {
            if (value.type !== 'number') {
                return NULL_VALUE;
            }
            return fromNumber(-value.data);
        });
    },
    Pos: function (_a, scope, execute) {
        var base = _a.base;
        return promiselessApply(execute(base, scope), function (value) {
            if (value.type !== 'number') {
                return NULL_VALUE;
            }
            return fromNumber(value.data);
        });
    },
    Asc: function () {
        return NULL_VALUE;
    },
    Desc: function () {
        return NULL_VALUE;
    },
    ArrayCoerce: function (_a, scope, execute) {
        var base = _a.base;
        return __awaiter(this, void 0, void 0, function () {
            var value;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, execute(base, scope)];
                    case 1:
                        value = _b.sent();
                        return [2 /*return*/, value.isArray() ? value : NULL_VALUE];
                }
            });
        });
    },
    Map: function (_a, scope, execute) {
        var base = _a.base, expr = _a.expr;
        return __awaiter(this, void 0, void 0, function () {
            var value;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, execute(base, scope)];
                    case 1:
                        value = _b.sent();
                        if (!value.isArray()) {
                            return [2 /*return*/, NULL_VALUE];
                        }
                        return [2 /*return*/, new StreamValue(function () {
                                return __asyncGenerator(this, arguments, function () {
                                    var value_2, value_2_1, elem, newScope, e_4_1;
                                    var e_4, _a;
                                    return __generator(this, function (_b) {
                                        switch (_b.label) {
                                            case 0:
                                                _b.trys.push([0, 8, 9, 14]);
                                                value_2 = __asyncValues(value);
                                                _b.label = 1;
                                            case 1: return [4 /*yield*/, __await(value_2.next())];
                                            case 2:
                                                if (!(value_2_1 = _b.sent(), !value_2_1.done)) return [3 /*break*/, 7];
                                                elem = value_2_1.value;
                                                newScope = scope.createHidden(elem);
                                                return [4 /*yield*/, __await(execute(expr, newScope))];
                                            case 3: return [4 /*yield*/, __await.apply(void 0, [_b.sent()])];
                                            case 4: return [4 /*yield*/, _b.sent()];
                                            case 5:
                                                _b.sent();
                                                _b.label = 6;
                                            case 6: return [3 /*break*/, 1];
                                            case 7: return [3 /*break*/, 14];
                                            case 8:
                                                e_4_1 = _b.sent();
                                                e_4 = { error: e_4_1 };
                                                return [3 /*break*/, 14];
                                            case 9:
                                                _b.trys.push([9, , 12, 13]);
                                                if (!(value_2_1 && !value_2_1.done && (_a = value_2["return"]))) return [3 /*break*/, 11];
                                                return [4 /*yield*/, __await(_a.call(value_2))];
                                            case 10:
                                                _b.sent();
                                                _b.label = 11;
                                            case 11: return [3 /*break*/, 13];
                                            case 12:
                                                if (e_4) throw e_4.error;
                                                return [7 /*endfinally*/];
                                            case 13: return [7 /*endfinally*/];
                                            case 14: return [2 /*return*/];
                                        }
                                    });
                                });
                            })];
                }
            });
        });
    },
    FlatMap: function (_a, scope, execute) {
        var base = _a.base, expr = _a.expr;
        return __awaiter(this, void 0, void 0, function () {
            var value;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, execute(base, scope)];
                    case 1:
                        value = _b.sent();
                        if (!value.isArray()) {
                            return [2 /*return*/, NULL_VALUE];
                        }
                        return [2 /*return*/, new StreamValue(function () {
                                return __asyncGenerator(this, arguments, function () {
                                    var value_3, value_3_1, elem, newScope, innerValue, innerValue_1, innerValue_1_1, inner, e_5_1, e_6_1;
                                    var e_6, _a, e_5, _b;
                                    return __generator(this, function (_c) {
                                        switch (_c.label) {
                                            case 0:
                                                _c.trys.push([0, 23, 24, 29]);
                                                value_3 = __asyncValues(value);
                                                _c.label = 1;
                                            case 1: return [4 /*yield*/, __await(value_3.next())];
                                            case 2:
                                                if (!(value_3_1 = _c.sent(), !value_3_1.done)) return [3 /*break*/, 22];
                                                elem = value_3_1.value;
                                                newScope = scope.createHidden(elem);
                                                return [4 /*yield*/, __await(execute(expr, newScope))];
                                            case 3:
                                                innerValue = _c.sent();
                                                if (!innerValue.isArray()) return [3 /*break*/, 18];
                                                _c.label = 4;
                                            case 4:
                                                _c.trys.push([4, 11, 12, 17]);
                                                innerValue_1 = (e_5 = void 0, __asyncValues(innerValue));
                                                _c.label = 5;
                                            case 5: return [4 /*yield*/, __await(innerValue_1.next())];
                                            case 6:
                                                if (!(innerValue_1_1 = _c.sent(), !innerValue_1_1.done)) return [3 /*break*/, 10];
                                                inner = innerValue_1_1.value;
                                                return [4 /*yield*/, __await(inner)];
                                            case 7: return [4 /*yield*/, _c.sent()];
                                            case 8:
                                                _c.sent();
                                                _c.label = 9;
                                            case 9: return [3 /*break*/, 5];
                                            case 10: return [3 /*break*/, 17];
                                            case 11:
                                                e_5_1 = _c.sent();
                                                e_5 = { error: e_5_1 };
                                                return [3 /*break*/, 17];
                                            case 12:
                                                _c.trys.push([12, , 15, 16]);
                                                if (!(innerValue_1_1 && !innerValue_1_1.done && (_b = innerValue_1["return"]))) return [3 /*break*/, 14];
                                                return [4 /*yield*/, __await(_b.call(innerValue_1))];
                                            case 13:
                                                _c.sent();
                                                _c.label = 14;
                                            case 14: return [3 /*break*/, 16];
                                            case 15:
                                                if (e_5) throw e_5.error;
                                                return [7 /*endfinally*/];
                                            case 16: return [7 /*endfinally*/];
                                            case 17: return [3 /*break*/, 21];
                                            case 18: return [4 /*yield*/, __await(innerValue)];
                                            case 19: return [4 /*yield*/, _c.sent()];
                                            case 20:
                                                _c.sent();
                                                _c.label = 21;
                                            case 21: return [3 /*break*/, 1];
                                            case 22: return [3 /*break*/, 29];
                                            case 23:
                                                e_6_1 = _c.sent();
                                                e_6 = { error: e_6_1 };
                                                return [3 /*break*/, 29];
                                            case 24:
                                                _c.trys.push([24, , 27, 28]);
                                                if (!(value_3_1 && !value_3_1.done && (_a = value_3["return"]))) return [3 /*break*/, 26];
                                                return [4 /*yield*/, __await(_a.call(value_3))];
                                            case 25:
                                                _c.sent();
                                                _c.label = 26;
                                            case 26: return [3 /*break*/, 28];
                                            case 27:
                                                if (e_6) throw e_6.error;
                                                return [7 /*endfinally*/];
                                            case 28: return [7 /*endfinally*/];
                                            case 29: return [2 /*return*/];
                                        }
                                    });
                                });
                            })];
                }
            });
        });
    }
};
/**
 * Evaluates a query.
 */
function evaluateQuery(tree, options) {
    if (options === void 0) { options = {}; }
    var root = fromJS(options.root);
    var dataset = fromJS(options.dataset);
    var params = __assign({}, options.params);
    var scope = new Scope(params, dataset, root, {
        timestamp: options.timestamp || new Date(),
        identity: options.identity === undefined ? 'me' : options.identity,
        sanity: options.sanity,
        after: options.after ? fromJS(options.after) : null,
        before: options.before ? fromJS(options.before) : null
    }, null);
    return evaluate(tree, scope);
}function canConstantEvaluate(node) {
    switch (node.type) {
        case 'Group':
        case 'Value':
        case 'Parameter':
            return true;
        case 'Pos':
        case 'Neg':
            return canConstantEvaluate(node.base);
        case 'OpCall':
            switch (node.op) {
                case '+':
                case '-':
                case '*':
                case '/':
                case '%':
                case '**':
                    return canConstantEvaluate(node.left) && canConstantEvaluate(node.right);
                default:
                    return false;
            }
        default:
            return false;
    }
}
var DUMMY_SCOPE = new Scope({}, NULL_VALUE, NULL_VALUE, { timestamp: new Date(0), identity: 'me', before: null, after: null }, null);
function tryConstantEvaluate(node) {
    if (!canConstantEvaluate(node)) {
        return null;
    }
    return constantEvaluate(node);
}
function constantEvaluate(node) {
    var value = evaluate(node, DUMMY_SCOPE, constantEvaluate);
    if ('then' in value) {
        throw new Error('BUG: constant evaluate should never return a promise');
    }
    return value;
}var ESCAPE_SEQUENCE = {
    "'": "'",
    '"': '"',
    '\\': '\\',
    '/': '/',
    b: '\b',
    f: '\f',
    n: '\n',
    r: '\r',
    t: '\t'
};
function expandHex(str) {
    var charCode = parseInt(str, 16);
    return String.fromCharCode(charCode);
}
var GroqQueryError = /** @class */ (function (_super) {
    __extends(GroqQueryError, _super);
    function GroqQueryError() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.name = 'GroqQueryError';
        return _this;
    }
    return GroqQueryError;
}(Error));
var EXPR_BUILDER = {
    group: function (p) {
        var inner = p.process(EXPR_BUILDER);
        return {
            type: 'Group',
            base: inner
        };
    },
    everything: function () {
        return { type: 'Everything' };
    },
    "this": function () {
        return { type: 'This' };
    },
    parent: function () {
        return {
            type: 'Parent',
            n: 1
        };
    },
    dblparent: function (p) {
        var next = p.process(EXPR_BUILDER);
        return {
            type: 'Parent',
            n: next.n + 1
        };
    },
    traverse: function (p) {
        var base = p.process(EXPR_BUILDER);
        var traversalList = [];
        while (p.getMark().name !== 'traversal_end') {
            traversalList.push(p.process(TRAVERSE_BUILDER));
        }
        p.shift();
        var traversal = null;
        for (var i = traversalList.length - 1; i >= 0; i--) {
            traversal = traversalList[i](traversal);
        }
        if (base.type === 'Everything' || base.type === 'Array' || base.type === 'PipeFuncCall') {
            traversal = traverseArray(function (val) { return val; }, traversal);
        }
        if (traversal === null)
            throw new Error('BUG: unexpected empty traversal');
        return traversal.build(base);
    },
    this_attr: function (p) {
        var name = p.processString();
        if (name === 'null') {
            return { type: 'Value', value: null };
        }
        if (name === 'true') {
            return { type: 'Value', value: true };
        }
        if (name === 'false') {
            return { type: 'Value', value: false };
        }
        return {
            type: 'AccessAttribute',
            name: name
        };
    },
    neg: function (p) {
        var base = p.process(EXPR_BUILDER);
        return {
            type: 'Neg',
            base: base
        };
    },
    pos: function (p) {
        var base = p.process(EXPR_BUILDER);
        return {
            type: 'Pos',
            base: base
        };
    },
    add: function (p) {
        var left = p.process(EXPR_BUILDER);
        var right = p.process(EXPR_BUILDER);
        return {
            type: 'OpCall',
            op: '+',
            left: left,
            right: right
        };
    },
    sub: function (p) {
        var left = p.process(EXPR_BUILDER);
        var right = p.process(EXPR_BUILDER);
        return {
            type: 'OpCall',
            op: '-',
            left: left,
            right: right
        };
    },
    mul: function (p) {
        var left = p.process(EXPR_BUILDER);
        var right = p.process(EXPR_BUILDER);
        return {
            type: 'OpCall',
            op: '*',
            left: left,
            right: right
        };
    },
    div: function (p) {
        var left = p.process(EXPR_BUILDER);
        var right = p.process(EXPR_BUILDER);
        return {
            type: 'OpCall',
            op: '/',
            left: left,
            right: right
        };
    },
    mod: function (p) {
        var left = p.process(EXPR_BUILDER);
        var right = p.process(EXPR_BUILDER);
        return {
            type: 'OpCall',
            op: '%',
            left: left,
            right: right
        };
    },
    pow: function (p) {
        var left = p.process(EXPR_BUILDER);
        var right = p.process(EXPR_BUILDER);
        return {
            type: 'OpCall',
            op: '**',
            left: left,
            right: right
        };
    },
    comp: function (p) {
        var left = p.process(EXPR_BUILDER);
        var op = p.processString();
        var right = p.process(EXPR_BUILDER);
        return {
            type: 'OpCall',
            op: op,
            left: left,
            right: right
        };
    },
    in_range: function (p) {
        var base = p.process(EXPR_BUILDER);
        var isInclusive = p.getMark().name === 'inc_range';
        p.shift();
        var left = p.process(EXPR_BUILDER);
        var right = p.process(EXPR_BUILDER);
        return {
            type: 'InRange',
            base: base,
            left: left,
            right: right,
            isInclusive: isInclusive
        };
    },
    str: function (p) {
        var value = '';
        // eslint-disable-next-line no-labels
        loop: while (p.hasMark()) {
            var mark = p.getMark();
            switch (mark.name) {
                case 'str_end':
                    value += p.processStringEnd();
                    // eslint-disable-next-line no-labels
                    break loop;
                case 'str_pause':
                    value += p.processStringEnd();
                    break;
                case 'str_start':
                    p.shift();
                    break;
                case 'single_escape': {
                    var char = p.slice(1);
                    p.shift();
                    value += ESCAPE_SEQUENCE[char];
                    break;
                }
                case 'unicode_hex':
                    p.shift();
                    value += expandHex(p.processStringEnd());
                    break;
                default:
                    throw new Error("unexpected mark: ".concat(mark.name));
            }
        }
        return { type: 'Value', value: value };
    },
    integer: function (p) {
        var strValue = p.processStringEnd();
        return {
            type: 'Value',
            value: Number(strValue)
        };
    },
    float: function (p) {
        var strValue = p.processStringEnd();
        return {
            type: 'Value',
            value: Number(strValue)
        };
    },
    sci: function (p) {
        var strValue = p.processStringEnd();
        return {
            type: 'Value',
            value: Number(strValue)
        };
    },
    object: function (p) {
        var attributes = [];
        while (p.getMark().name !== 'object_end') {
            attributes.push(p.process(OBJECT_BUILDER));
        }
        p.shift();
        return {
            type: 'Object',
            attributes: attributes
        };
    },
    array: function (p) {
        var elements = [];
        while (p.getMark().name !== 'array_end') {
            var isSplat = false;
            if (p.getMark().name === 'array_splat') {
                isSplat = true;
                p.shift();
            }
            var value = p.process(EXPR_BUILDER);
            elements.push({
                type: 'ArrayElement',
                value: value,
                isSplat: isSplat
            });
        }
        p.shift();
        return {
            type: 'Array',
            elements: elements
        };
    },
    tuple: function (p) {
        var members = [];
        while (p.getMark().name !== 'tuple_end') {
            members.push(p.process(EXPR_BUILDER));
        }
        p.shift();
        return {
            type: 'Tuple',
            members: members
        };
    },
    func_call: function (p) {
        var namespace = 'global';
        if (p.getMark().name === 'namespace') {
            p.shift();
            namespace = p.processString();
        }
        var name = p.processString();
        if (namespace === 'global' && name === 'select') {
            var result = {
                type: 'Select',
                alternatives: []
            };
            while (p.getMark().name !== 'func_args_end') {
                if (p.getMark().name === 'pair') {
                    if (result.fallback)
                        throw new GroqQueryError("unexpected argument to select()");
                    p.shift();
                    var condition = p.process(EXPR_BUILDER);
                    var value = p.process(EXPR_BUILDER);
                    result.alternatives.push({
                        type: 'SelectAlternative',
                        condition: condition,
                        value: value
                    });
                }
                else {
                    if (result.fallback)
                        throw new GroqQueryError("unexpected argument to select()");
                    var value = p.process(EXPR_BUILDER);
                    result.fallback = value;
                }
            }
            p.shift();
            return result;
        }
        var args = [];
        while (p.getMark().name !== 'func_args_end') {
            if (argumentShouldBeSelector(namespace, name, args.length)) {
                // Since the diff/delta functions aren't validated yet we only want to validate the selector
                // being used. We expect the null valued arg to throw an error at evaluation time.
                p.process(SELECTOR_BUILDER);
                args.push({ type: 'Selector' });
            }
            else {
                args.push(p.process(EXPR_BUILDER));
            }
        }
        p.shift();
        if (namespace === 'global' && (name === 'before' || name === 'after')) {
            if (p.parseOptions.mode === 'delta') {
                return {
                    type: 'Context',
                    key: name
                };
            }
        }
        if (namespace === 'global' && name === 'boost' && !p.allowBoost)
            throw new GroqQueryError('unexpected boost');
        var funcs = namespaces[namespace];
        if (!funcs) {
            throw new GroqQueryError("Undefined namespace: ".concat(namespace));
        }
        var func = funcs[name];
        if (!func) {
            throw new GroqQueryError("Undefined function: ".concat(name));
        }
        if (func.arity !== undefined) {
            validateArity(name, func.arity, args.length);
        }
        if (func.mode !== undefined && func.mode !== p.parseOptions.mode) {
            throw new GroqQueryError("Undefined function: ".concat(name));
        }
        return {
            type: 'FuncCall',
            func: func,
            name: name,
            args: args
        };
    },
    pipecall: function (p) {
        var base = p.process(EXPR_BUILDER);
        p.shift(); // Remove the func_call
        var namespace = 'global';
        if (p.getMark().name === 'namespace') {
            p.shift();
            namespace = p.processString();
        }
        if (namespace !== 'global') {
            throw new GroqQueryError("Undefined namespace: ".concat(namespace));
        }
        var name = p.processString();
        var args = [];
        var oldAllowBoost = p.allowBoost;
        if (name === 'score') {
            // Only allow boost inside a score expression
            p.allowBoost = true;
        }
        for (;;) {
            var markName = p.getMark().name;
            if (markName === 'func_args_end') {
                break;
            }
            if (name === 'order') {
                if (markName === 'asc') {
                    p.shift();
                    args.push({ type: 'Asc', base: p.process(EXPR_BUILDER) });
                    continue;
                }
                else if (markName === 'desc') {
                    p.shift();
                    args.push({ type: 'Desc', base: p.process(EXPR_BUILDER) });
                    continue;
                }
            }
            args.push(p.process(EXPR_BUILDER));
        }
        p.shift();
        p.allowBoost = oldAllowBoost;
        var func = pipeFunctions[name];
        if (!func) {
            throw new GroqQueryError("Undefined pipe function: ".concat(name));
        }
        if (func.arity) {
            validateArity(name, func.arity, args.length);
        }
        return {
            type: 'PipeFuncCall',
            func: func,
            base: base,
            name: name,
            args: args
        };
    },
    pair: function (p) {
        throw new GroqQueryError("unexpected =>");
    },
    and: function (p) {
        var left = p.process(EXPR_BUILDER);
        var right = p.process(EXPR_BUILDER);
        return {
            type: 'And',
            left: left,
            right: right
        };
    },
    or: function (p) {
        var left = p.process(EXPR_BUILDER);
        var right = p.process(EXPR_BUILDER);
        return {
            type: 'Or',
            left: left,
            right: right
        };
    },
    not: function (p) {
        var base = p.process(EXPR_BUILDER);
        return {
            type: 'Not',
            base: base
        };
    },
    asc: function (p) {
        throw new GroqQueryError('unexpected asc');
    },
    desc: function (p) {
        throw new GroqQueryError('unexpected desc');
    },
    param: function (p) {
        var name = p.processString();
        if (p.parseOptions.params && p.parseOptions.params.hasOwnProperty(name)) {
            return {
                type: 'Value',
                value: p.parseOptions.params[name]
            };
        }
        return {
            type: 'Parameter',
            name: name
        };
    }
};
var OBJECT_BUILDER = {
    object_expr: function (p) {
        if (p.getMark().name === 'pair') {
            p.shift();
            var condition = p.process(EXPR_BUILDER);
            var value_1 = p.process(EXPR_BUILDER);
            return {
                type: 'ObjectConditionalSplat',
                condition: condition,
                value: value_1
            };
        }
        var value = p.process(EXPR_BUILDER);
        return {
            type: 'ObjectAttributeValue',
            name: extractPropertyKey(value),
            value: value
        };
    },
    object_pair: function (p) {
        var name = p.process(EXPR_BUILDER);
        if (name.type !== 'Value')
            throw new Error('name must be string');
        var value = p.process(EXPR_BUILDER);
        return {
            type: 'ObjectAttributeValue',
            name: name.value,
            value: value
        };
    },
    object_splat: function (p) {
        var value = p.process(EXPR_BUILDER);
        return {
            type: 'ObjectSplat',
            value: value
        };
    },
    object_splat_this: function () {
        return {
            type: 'ObjectSplat',
            value: { type: 'This' }
        };
    }
};
var TRAVERSE_BUILDER = {
    square_bracket: function (p) {
        var expr = p.process(EXPR_BUILDER);
        var value = tryConstantEvaluate(expr);
        if (value && value.type === 'number') {
            return function (right) {
                return traverseElement(function (base) { return ({ type: 'AccessElement', base: base, index: value.data }); }, right);
            };
        }
        if (value && value.type === 'string') {
            return function (right) {
                return traversePlain(function (base) { return ({ type: 'AccessAttribute', base: base, name: value.data }); }, right);
            };
        }
        return function (right) {
            return traverseArray(function (base) { return ({
                type: 'Filter',
                base: base,
                expr: expr
            }); }, right);
        };
    },
    slice: function (p) {
        var isInclusive = p.getMark().name === 'inc_range';
        p.shift();
        var left = p.process(EXPR_BUILDER);
        var right = p.process(EXPR_BUILDER);
        var leftValue = tryConstantEvaluate(left);
        var rightValue = tryConstantEvaluate(right);
        if (!leftValue || !rightValue || leftValue.type !== 'number' || rightValue.type !== 'number') {
            throw new GroqQueryError('slicing must use constant numbers');
        }
        return function (rhs) {
            return traverseArray(function (base) { return ({
                type: 'Slice',
                base: base,
                left: leftValue.data,
                right: rightValue.data,
                isInclusive: isInclusive
            }); }, rhs);
        };
    },
    projection: function (p) {
        var obj = p.process(EXPR_BUILDER);
        return function (right) {
            return traverseProjection(function (base) { return ({ type: 'Projection', base: base, expr: obj }); }, right);
        };
    },
    attr_access: function (p) {
        var name = p.processString();
        return function (right) { return traversePlain(function (base) { return ({ type: 'AccessAttribute', base: base, name: name }); }, right); };
    },
    deref: function (p) {
        var attr = null;
        if (p.getMark().name === 'deref_attr') {
            p.shift();
            attr = p.processString();
        }
        var wrap = function (base) {
            return attr ? { type: 'AccessAttribute', base: base, name: attr } : base;
        };
        return function (right) {
            return traversePlain(function (base) {
                return wrap({
                    type: 'Deref',
                    base: base
                });
            }, right);
        };
    },
    array_postfix: function (p) {
        return function (right) { return traverseArray(function (base) { return ({ type: 'ArrayCoerce', base: base }); }, right); };
    }
};
var SELECTOR_BUILDER = {
    group: function (p) {
        p.process(SELECTOR_BUILDER);
        return null;
    },
    everything: function () {
        throw new Error('Invalid selector syntax');
    },
    "this": function () {
        throw new Error('Invalid selector syntax');
    },
    parent: function () {
        throw new Error('Invalid selector syntax');
    },
    dblparent: function (p) {
        throw new Error('Invalid selector syntax');
    },
    traverse: function (p) {
        p.process(SELECTOR_BUILDER);
        while (p.getMark().name !== 'traversal_end') {
            p.process(TRAVERSE_BUILDER);
        }
        p.shift();
        return null;
    },
    this_attr: function (p) {
        p.processString();
        return null;
    },
    neg: function (p) {
        throw new Error('Invalid selector syntax');
    },
    pos: function (p) {
        throw new Error('Invalid selector syntax');
    },
    add: function (p) {
        throw new Error('Invalid selector syntax');
    },
    sub: function (p) {
        throw new Error('Invalid selector syntax');
    },
    mul: function (p) {
        throw new Error('Invalid selector syntax');
    },
    div: function (p) {
        throw new Error('Invalid selector syntax');
    },
    mod: function (p) {
        throw new Error('Invalid selector syntax');
    },
    pow: function (p) {
        throw new Error('Invalid selector syntax');
    },
    comp: function (p) {
        throw new Error('Invalid selector syntax');
    },
    in_range: function (p) {
        throw new Error('Invalid selector syntax');
    },
    str: function (p) {
        throw new Error('Invalid selector syntax');
    },
    integer: function (p) {
        throw new Error('Invalid selector syntax');
    },
    float: function (p) {
        throw new Error('Invalid selector syntax');
    },
    sci: function (p) {
        throw new Error('Invalid selector syntax');
    },
    object: function (p) {
        throw new Error('Invalid selector syntax');
    },
    array: function (p) {
        throw new Error('Invalid selector syntax');
    },
    tuple: function (p) {
        // This should only throw an error until we add support for tuples in selectors.
        throw new Error('Invalid selector syntax');
    },
    func_call: function (p, mark) {
        var func = EXPR_BUILDER.func_call(p, mark);
        if (func.name === 'anywhere' && func.args.length === 1)
            return null;
        throw new Error('Invalid selector syntax');
    },
    pipecall: function (p) {
        throw new Error('Invalid selector syntax');
    },
    pair: function (p) {
        throw new Error('Invalid selector syntax');
    },
    and: function (p) {
        throw new Error('Invalid selector syntax');
    },
    or: function (p) {
        throw new Error('Invalid selector syntax');
    },
    not: function (p) {
        throw new Error('Invalid selector syntax');
    },
    asc: function (p) {
        throw new Error('Invalid selector syntax');
    },
    desc: function (p) {
        throw new Error('Invalid selector syntax');
    },
    param: function (p) {
        throw new Error('Invalid selector syntax');
    }
};
function extractPropertyKey(node) {
    if (node.type === 'AccessAttribute' && !node.base) {
        return node.name;
    }
    if (node.type === 'Deref' ||
        node.type === 'Map' ||
        node.type === 'Projection' ||
        node.type === 'Slice' ||
        node.type === 'Filter' ||
        node.type === 'AccessElement' ||
        node.type === 'ArrayCoerce') {
        return extractPropertyKey(node.base);
    }
    throw new GroqQueryError("Cannot determine property key for type: ".concat(node.type));
}
function validateArity(name, arity, count) {
    if (typeof arity === 'number') {
        if (count !== arity) {
            throw new GroqQueryError("Incorrect number of arguments to function ".concat(name, "(). Expected ").concat(arity, ", got ").concat(count, "."));
        }
    }
    else if (arity) {
        if (!arity(count)) {
            throw new GroqQueryError("Incorrect number of arguments to function ".concat(name, "()."));
        }
    }
}
function argumentShouldBeSelector(namespace, functionName, argCount) {
    var functionsRequiringSelectors = ['changedAny', 'changedOnly'];
    return namespace == 'diff' && argCount == 2 && functionsRequiringSelectors.includes(functionName);
}
var GroqSyntaxError = /** @class */ (function (_super) {
    __extends(GroqSyntaxError, _super);
    function GroqSyntaxError(position) {
        var _this = _super.call(this, "Syntax error in GROQ query at position ".concat(position)) || this;
        _this.name = 'GroqSyntaxError';
        _this.position = position;
        return _this;
    }
    return GroqSyntaxError;
}(Error));
/**
 * Parses a GROQ query and returns a tree structure.
 */
function parse(input, options) {
    if (options === void 0) { options = {}; }
    var result = parse$1(input);
    if (result.type === 'error') {
        throw new GroqSyntaxError(result.position);
    }
    var processor = new MarkProcessor(input, result.marks, options);
    return processor.process(EXPR_BUILDER);
}export{evaluateQuery as evaluate,parse};