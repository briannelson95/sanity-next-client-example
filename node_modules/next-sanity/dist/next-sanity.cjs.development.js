'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

function _interopNamespace(e) {
  if (e && e.__esModule) { return e; } else {
    var n = {};
    if (e) {
      Object.keys(e).forEach(function (k) {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      });
    }
    n['default'] = e;
    return n;
  }
}

var sanityClient = _interopDefault(require('@sanity/client'));
var react = require('react');
var groq = _interopDefault(require('groq'));

function createClient(config) {
  return sanityClient(config);
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

var MockAbortController = /*#__PURE__*/function () {
  function MockAbortController() {
    this._signal = {
      aborted: false
    };
  }

  var _proto = MockAbortController.prototype;

  _proto.abort = function abort() {
    this._signal.aborted = true;
  };

  _createClass(MockAbortController, [{
    key: "signal",
    get: function get() {
      return this._signal;
    }
  }]);

  return MockAbortController;
}();

function getAborter() {
  return typeof AbortController === 'undefined' ? new MockAbortController() : new AbortController();
}

function createCurrentUserHook(_ref) {
  var projectId = _ref.projectId;
  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  return function () {
    return useCurrentUser(projectId);
  };
}
function getCurrentUser(projectId, abort, token) {
  var headers = token ? {
    Authorization: "Bearer " + token
  } : undefined;
  return fetch("https://" + projectId + ".api.sanity.io/v1/users/me", {
    credentials: 'include',
    signal: abort.signal,
    headers: headers
  }).then(function (res) {
    return res.json();
  }).then(function (res) {
    return res != null && res.id ? res : null;
  });
}

function useCurrentUser(projectId) {
  var _useState = react.useState(),
      data = _useState[0],
      setUser = _useState[1];

  var _useState2 = react.useState(),
      error = _useState2[0],
      setError = _useState2[1];

  react.useEffect(function () {
    var aborter = getAborter();
    getCurrentUser(projectId, aborter).then(setUser).catch(function (err) {
      return err.name !== 'AbortError' && setError(err);
    });
    return function () {
      aborter.abort();
    };
  }, [projectId]);
  return {
    data: data,
    error: error,
    loading: data !== null || !error
  };
}

var EMPTY_PARAMS = {}; // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types

function createPreviewSubscriptionHook(_ref) {
  var projectId = _ref.projectId,
      dataset = _ref.dataset,
      token = _ref.token,
      EventSource = _ref.EventSource,
      _ref$documentLimit = _ref.documentLimit,
      documentLimit = _ref$documentLimit === void 0 ? 3000 : _ref$documentLimit;
  // Only construct/setup the store when `getStore()` is called
  var store;
  return function usePreviewSubscription(query, options) {
    if (options === void 0) {
      options = {};
    }

    var _options = options,
        _options$params = _options.params,
        params = _options$params === void 0 ? EMPTY_PARAMS : _options$params,
        initialData = _options.initialData,
        enabled = _options.enabled;
    return useQuerySubscription({
      getStore: getStore,
      projectId: projectId,
      query: query,
      params: params,
      initialData: initialData,
      enabled: enabled ? typeof window !== 'undefined' : false,
      token: token
    });
  };

  function getStore(abort) {
    if (!store) {
      store = new Promise(function (resolve) { resolve(_interopNamespace(require('@sanity/groq-store'))); }).then(function (_ref2) {
        var groqStore = _ref2.groqStore;

        // Skip creating the groq store if we've been unmounted to save memory and reduce gc pressure
        if (abort.signal.aborted) {
          var error = new Error('Cancelling groq store creation'); // This ensures we can skip it in the catch block same way

          error.name = 'AbortError';
          return Promise.reject(error);
        }

        return groqStore({
          projectId: projectId,
          dataset: dataset,
          documentLimit: documentLimit,
          token: token,
          EventSource: EventSource,
          listen: true,
          overlayDrafts: true,
          subscriptionThrottleMs: 10
        });
      });
    }

    return store;
  }
}

function useQuerySubscription(options) {
  var getStore = options.getStore,
      projectId = options.projectId,
      query = options.query,
      initialData = options.initialData,
      _options$enabled = options.enabled,
      enabled = _options$enabled === void 0 ? false : _options$enabled,
      token = options.token;

  var _useState = react.useState(),
      error = _useState[0],
      setError = _useState[1];

  var _useState2 = react.useState(false),
      loading = _useState2[0],
      setLoading = _useState2[1];

  var _useState3 = react.useState(),
      data = _useState3[0],
      setData = _useState3[1];

  var params = useParams(options.params); // Use "deep" dependency comparison because params are often not _referentially_ equal,
  // but contains the same shallow properties, eg `{"slug": "some-slug"}`

  react.useEffect(function () {
    if (!enabled) {
      return;
    }

    setLoading(true);
    var aborter = getAborter();
    var subscription;
    getCurrentUser(projectId, aborter, token).then(function (user) {
      if (user) {
        return;
      } // eslint-disable-next-line no-console


      console.warn('Not authenticated - preview not available');
      throw new Error('Not authenticated - preview not available');
    }).then(function () {
      return getStore(aborter);
    }).then(function (store) {
      subscription = store.subscribe(query, params, function (err, result) {
        if (err) {
          setError(err);
        } else {
          setData(result);
        }
      });
    }).catch(function (err) {
      return err.name === 'AbortError' ? null : setError(err);
    }).finally(function () {
      return setLoading(false);
    }); // eslint-disable-next-line consistent-return

    return function () {
      if (subscription) {
        subscription.unsubscribe();
      }

      aborter.abort();
    };
  }, [getStore, query, params, enabled, projectId, token]);
  return {
    data: typeof data === 'undefined' ? initialData : data,
    loading: loading,
    error: error
  };
} // Return params that are stable with deep equal as long as the key order is the same


function useParams(params) {
  var stringifiedParams = react.useMemo(function () {
    return JSON.stringify(params);
  }, [params]);
  return react.useMemo(function () {
    return JSON.parse(stringifiedParams);
  }, [stringifiedParams]);
}

exports.groq = groq;
exports.createClient = createClient;
exports.createCurrentUserHook = createCurrentUserHook;
exports.createPreviewSubscriptionHook = createPreviewSubscriptionHook;
//# sourceMappingURL=next-sanity.cjs.development.js.map
