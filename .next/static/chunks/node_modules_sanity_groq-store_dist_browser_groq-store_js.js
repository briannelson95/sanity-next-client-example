/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_sanity_groq-store_dist_browser_groq-store_js"],{

/***/ "./node_modules/@sanity/groq-store/dist/browser/groq-store.js":
/*!********************************************************************!*\
  !*** ./node_modules/@sanity/groq-store/dist/browser/groq-store.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var e=__webpack_require__(/*! groq */ \"./node_modules/groq/lib/groq.js\"),r=__webpack_require__(/*! fast-deep-equal */ \"./node_modules/fast-deep-equal/index.js\"),t=__webpack_require__(/*! throttle-debounce */ \"./node_modules/throttle-debounce/cjs/index.js\"),n=__webpack_require__(/*! groq-js */ \"./node_modules/groq-js/dist/1.umd.cjs\"),o=__webpack_require__(/*! mendoza */ \"./node_modules/mendoza/lib/esm/index.js\");function i(e){return e&&\"object\"==typeof e&&\"default\"in e?e:{default:e}}var u=/*#__PURE__*/i(e),s=/*#__PURE__*/i(r);function a(){return a=Object.assign?Object.assign.bind():function(e){for(var r=1;r<arguments.length;r++){var t=arguments[r];for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])}return e},a.apply(this,arguments)}var c,f=function(e,r,t){(function(e){return\"undefined\"!=typeof window&&e.addEventListener===window.EventSource.prototype.addEventListener})(e)&&e.addEventListener(r,t,!1),e.addEventListener(r,t)};function d(e,r,t){var n,o=r.token,i=new e(\"https://\"+r.projectId+\".api.sanity.io/v1/data/listen/\"+r.dataset+\"?query=*&effectFormat=mendoza\",{withCredentials:!0,headers:o?{Authorization:\"Bearer \"+o}:void 0});return f(i,\"welcome\",t.open),f(i,\"mutation\",(n=t.next,function(e){var r;try{r=JSON.parse(e.data)}catch(e){return}n(r)})),f(i,\"channelError\",function(e){var r;i.close();try{r=JSON.parse(e.data)}catch(e){return void t.error(new Error(\"Unknown error parsing listener message\"))}t.error(new Error(r.message||r.error||\"Listener returned HTTP \"+r.statusCode))}),f(i,\"error\",function(e){var r=\"undefined\"!=typeof window&&window.location.origin,n=r?\", and that the CORS-origin (\"+r+\") is allowed\":\"\",o=function(e){return\"object\"==typeof e&&null!==e&&\"message\"in e}(e)?\" (\"+e.message+\")\":\"\";t.error(new Error(\"Error establishing listener - check that the project ID and dataset are correct\"+n+o))}),{unsubscribe:function(){return Promise.resolve(i.close())}}}function v(e){return e._id.startsWith(\"drafts.\")?e._id.slice(7):e._id}function l(e,r){var t=a({},e);return delete t._rev,o.applyPatch(t,r)}function h(){return Promise.resolve()}function m(e,r,t){if(!e.s){if(t instanceof p){if(!t.s)return void(t.o=m.bind(null,e,r));1&r&&(r=t.s),t=t.v}if(t&&t.then)return void t.then(m.bind(null,e,r),m.bind(null,e,2));e.s=r,e.v=t;const n=e.o;n&&n(e)}}var p=/*#__PURE__*/function(){function e(){}return e.prototype.then=function(r,t){var n=new e,o=this.s;if(o){var i=1&o?r:t;if(i){try{m(n,1,i(this.v))}catch(e){m(n,2,e)}return n}return this}return this.o=function(e){try{var o=e.v;1&e.s?m(n,1,r?r(o):o):t?m(n,1,t(o)):m(n,2,o)}catch(e){m(n,2,e)}},n},e}();function w(e){return e instanceof p&&1&e.s}var b=function(e){var r=e.projectId,t=e.dataset,n=e.token,o=e.documentLimit;try{return Promise.resolve(fetch(\"https://\"+r+\".api.sanity.io/v1/data/export/\"+t,{credentials:\"include\",headers:n?{Authorization:\"Bearer \"+n}:void 0})).then(function(e){function r(r){var t,n,i=function(e){if(!e)throw new Error(\"Failed to read body from response\");var r,t=!1;function n(){t=!0,r&&r.cancel()}return new ReadableStream({start:function(o){r=e.getReader();var i=new TextDecoder,u=\"\";r.read().then(function e(s){try{if(s.done)return t?Promise.resolve():0===(u=u.trim()).length?(o.close(),Promise.resolve()):(o.enqueue(JSON.parse(u)),o.close(),Promise.resolve());for(var a=(u+=i.decode(s.value,{stream:!0})).split(\"\\n\"),c=0;c<a.length-1;++c){var f=a[c].trim();if(0!==f.length)try{o.enqueue(JSON.parse(f))}catch(e){return o.error(e),n(),Promise.resolve()}}if(u=a[a.length-1],!r)return Promise.resolve();var d=function(t,n){try{var o=Promise.resolve(r.read()).then(function(r){e(r)})}catch(e){return n(e)}return o&&o.then?o.then(void 0,n):o}(0,function(e){o.error(e)});return Promise.resolve(d&&d.then?d.then(function(){}):void 0)}catch(e){return Promise.reject(e)}}).catch(function(e){return o.error(e)})},cancel:n})}(e.body),u=i.getReader(),s=[],a=function(e,r){var t;do{var n=e();if(n&&n.then){if(!w(n)){t=!0;break}n=n.v}var o=r();if(w(o)&&(o=o.v),!o)return n}while(!o.then);var i=new p,u=m.bind(null,i,2);return(t?n.then(s):o.then(a)).then(void 0,u),i;function s(t){for(n=t;w(o=r())&&(o=o.v),o;){if(o.then)return void o.then(a).then(void 0,u);if((n=e())&&n.then){if(!w(n))return void n.then(s).then(void 0,u);n=n.v}}m(i,1,n)}function a(t){if(t){do{if((n=e())&&n.then){if(!w(n))return void n.then(s).then(void 0,u);n=n.v}if(w(t=r())&&(t=t.v),!t)return void m(i,1,n)}while(!t.then);t.then(a).then(void 0,u)}else m(i,1,n)}}(function(){return Promise.resolve(u.read()).then(function(e){if(function(e){return!!e&&\"error\"in e&&\"object\"==typeof e.error&&null!==e.error&&\"description\"in e.error&&\"string\"==typeof e.error.description&&!(\"_id\"in e)}(n=(t=e).value))throw new Error(\"Error streaming dataset: \"+n.error);if(n&&!n._id.startsWith(\"_.\")&&s.push(n),o&&s.length>o)throw u.cancel(\"Reached document limit\"),new Error(\"Error streaming dataset: Reached limit of \"+o+\" documents\")})},function(){return!t.done});return a&&a.then?a.then(function(e){return s}):s}var t=function(){if(200!==e.status)return Promise.resolve(e.json()).then(function(e){throw new Error(\"Error streaming dataset: \"+(\"object\"==typeof(r=e)&&\"error\"in r&&\"message\"in r?r.message||r.error:\"<unknown error>\"));var r})}();return t&&t.then?t.then(r):r()})}catch(e){return Promise.reject(e)}};Object.defineProperty(exports, \"groq\", ({enumerable:!0,get:function(){return u.default}})),exports.groqStore=function(e){var r;!function(){var e=[\"EventSource\",\"ReadableStream\",\"fetch\"].filter(function(e){return!(e in window)});if(e.length>0)throw new Error(\"Browser not supported. Missing browser APIs: \"+e.join(\", \"))}();var o=null!=(r=e.EventSource)?r:window.EventSource;if(e.token&&o===window.EventSource)throw new Error(\"When`token` option is used, `EventSource` option must also be provided. EventSource cannot be `window.EventSource`, as it does not support passing a token.\");return function(e,r){var o,i=function(e,r){return Promise.resolve(f()).then(function(){var t=n.parse(e,{params:r});return Promise.resolve(n.evaluate(t,{dataset:m,params:r})).then(function(e){return e.get()})})},f=function(){try{return o||(o=function(e,r,t){var n=t.getDocuments,o=t.EventSource,i=e.projectId,u=e.dataset,s=e.overlayDrafts,c=e.documentLimit,f=e.token;if(!e.listen)return{unsubscribe:h,loaded:n({projectId:i,dataset:u,documentLimit:c,token:f}).then(S).then(h)};var m,p,w,b,g,y,E=new Map,P=[],j=new Promise(function(e,r){p=e,w=r});return{unsubscribe:d(o,e,{next:function(e){m?(function(e){if(e.effects&&!e.documentId.startsWith(\"_.\")){var r=E.get(e.documentId)||null;!function(e,r){var t=E.get(e),n=m||[],o=t?n.indexOf(t):-1;-1===o&&r?(n.push(r),E.set(e,r)):r?(n.splice(o,1,r),E.set(e,r)):(n.splice(o,1),E.delete(e))}(e.documentId,l(r,e.effects.apply))}}(e),function(e,r){clearTimeout(y),g!==r.transactionId&&b?(S(b),g=void 0):(g=r.transactionId,b=e.slice()),y=setTimeout(S,25,e.slice())}(m,e)):P.push(e)},open:function(){try{return Promise.resolve(n({projectId:i,dataset:u,documentLimit:c,token:f})).then(function(e){(m=function(e,r){var t=new Map;return r.forEach(function(e){var r=t.get(e.documentId)||[];r.push(e),t.set(e.documentId,r)}),t.forEach(function(r,t){var n=e.find(function(e){return e._id===t});if(n){var o=!1,i=n;r.forEach(function(e){(o=o||e.previousRev===n._rev)&&e.effects&&(i=l(i,e.effects.apply))}),e.splice(e.indexOf(n),1,i)}else console.warn(\"Received mutation for missing document %s\",t)}),e}(e,P)).forEach(function(e){return E.set(e._id,e)}),S(m),p()})}catch(e){return Promise.reject(e)}},error:function(e){return w(e)}}).unsubscribe,loaded:j};function S(e){b=void 0,y=void 0,g=void 0,r(s?function(e){var r=new Map;return e.forEach(function(e){var t=r.get(v(e));e._id.startsWith(\"drafts.\")?r.set(v(e),function(e){return a({},e,{_id:v(e)})}(e)):t||r.set(e._id,e)}),Array.from(r.values())}(e):e)}}(e,function(e){m=e,p()},r)),Promise.resolve(o.loaded).then(function(){})}catch(e){return Promise.reject(e)}},m=[],p=t.throttle(e.subscriptionThrottleMs||50,function(){w.forEach(b)}),w=[];function b(e){return i(e.query,e.params).then(function(r){\"previousResult\"in e&&s.default(e.previousResult,r)||(e.previousResult=r,e.callback(void 0,r))}).catch(function(r){e.callback(r)})}return{query:i,getDocument:function(e){return Promise.resolve(f()).then(function(){return i(u.default(c||(r=[\"*[_id == $id][0]\"],t||(t=r.slice(0)),r.raw=t,c=r)),{id:e});var r,t})},getDocuments:function(e){return Promise.resolve(f()).then(function(){var r=e.map(function(e){return'*[_id == \"'+e+'\"][0]'}).join(\",\\n\");return i(\"[\"+r+\"]\")})},subscribe:function(r,t,n){if(!e.listen)throw new Error(\"Cannot use `subscribe()` without `listen: true`\");var o={query:r,params:t,callback:n};w.push(o);var i=!1;return b(o),{unsubscribe:function(){return i||(i=!0,w.splice(w.indexOf(o),1)),Promise.resolve()}}},close:function(){return p.cancel(),o?o.unsubscribe():Promise.resolve()}}}(e,{EventSource:o,getDocuments:b})};\n//# sourceMappingURL=groq-store.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNhbml0eS9ncm9xLXN0b3JlL2Rpc3QvYnJvd3Nlci9ncm9xLXN0b3JlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLE1BQU0sbUJBQU8sQ0FBQyw2Q0FBTSxJQUFJLG1CQUFPLENBQUMsZ0VBQWlCLElBQUksbUJBQU8sQ0FBQyx3RUFBbUIsSUFBSSxtQkFBTyxDQUFDLHNEQUFTLElBQUksbUJBQU8sQ0FBQyx3REFBUyxFQUFFLGNBQWMsK0NBQStDLFdBQVcsNENBQTRDLGFBQWEsd0RBQXdELFlBQVksbUJBQW1CLEtBQUssbUJBQW1CLHNFQUFzRSxTQUFTLHlCQUF5Qix3QkFBd0IsYUFBYSxxR0FBcUcsMERBQTBELGtCQUFrQiwySEFBMkgsOEJBQThCLDBCQUEwQixRQUFRLEVBQUUsa0VBQWtFLE1BQU0sSUFBSSxxQkFBcUIsU0FBUyxPQUFPLEtBQUssa0NBQWtDLE1BQU0sVUFBVSxJQUFJLHFCQUFxQixTQUFTLHlFQUF5RSwrRUFBK0UsMEJBQTBCLDhIQUE4SCxrREFBa0QsMEJBQTBCLDBHQUEwRyxHQUFHLHVCQUF1QixvQ0FBb0MsY0FBYyx3REFBd0QsZ0JBQWdCLFVBQVUsSUFBSSx1Q0FBdUMsYUFBYSx5QkFBeUIsa0JBQWtCLFNBQVMsbUJBQW1CLDBDQUEwQyxtQkFBbUIsbUVBQW1FLFlBQVksWUFBWSxTQUFTLDhCQUE4QixjQUFjLHNDQUFzQyxxQkFBcUIsTUFBTSxjQUFjLE1BQU0sSUFBSSxpQkFBaUIsU0FBUyxTQUFTLFNBQVMsWUFBWSwwQkFBMEIsSUFBSSxVQUFVLDZDQUE2QyxTQUFTLFVBQVUsR0FBRyxHQUFHLEdBQUcsY0FBYyw2QkFBNkIsa0JBQWtCLDBEQUEwRCxJQUFJLDhFQUE4RSxpQ0FBaUMsMEJBQTBCLFFBQVEsb0JBQW9CLGNBQWMsc0JBQXNCLDJEQUEyRCxXQUFXLGFBQWEsbUJBQW1CLDJCQUEyQixrQkFBa0IsZ0JBQWdCLDJCQUEyQiw0QkFBNEIsSUFBSSxrSkFBa0osZ0NBQWdDLFVBQVUsbUJBQW1CLGFBQWEsS0FBSyxrQkFBa0Isb0JBQW9CLHlCQUF5QixTQUFTLHlDQUF5QywrQ0FBK0Msb0JBQW9CLElBQUksaURBQWlELEtBQUssRUFBRSxTQUFTLFlBQVksb0NBQW9DLGVBQWUsV0FBVyxFQUFFLG9EQUFvRCxVQUFVLFNBQVMsMEJBQTBCLG9CQUFvQixrQkFBa0IsRUFBRSxVQUFVLEVBQUUsOENBQThDLE1BQU0sR0FBRyxVQUFVLGNBQWMsVUFBVSxLQUFLLE1BQU0sTUFBTSxVQUFVLDZCQUE2QixlQUFlLCtCQUErQiwrQ0FBK0MsY0FBYyxRQUFRLG9CQUFvQixFQUFFLCtDQUErQyxvQkFBb0IsOENBQThDLE9BQU8sU0FBUyxjQUFjLE1BQU0sR0FBRyxvQkFBb0IsOENBQThDLE1BQU0sNkNBQTZDLGVBQWUseUJBQXlCLGVBQWUsWUFBWSxrREFBa0QsZUFBZSw4SUFBOEkscUVBQXFFLHVLQUF1SyxFQUFFLFlBQVksY0FBYyxFQUFFLG9DQUFvQyxTQUFTLElBQUksaUJBQWlCLG9FQUFvRSxzSUFBc0ksTUFBTSxFQUFFLEdBQUcsK0JBQStCLEVBQUUsU0FBUywyQkFBMkIsd0NBQXFDLENBQUMsNkJBQTZCLGtCQUFrQixFQUFDLENBQUMsaUJBQWlCLGFBQWEsTUFBTSxZQUFZLGtFQUFrRSxxQkFBcUIsRUFBRSw0RkFBNEYsR0FBRyxtREFBbUQsa05BQWtOLHFCQUFxQixzQkFBc0IsNENBQTRDLGlCQUFpQixTQUFTLEVBQUUscUNBQXFDLG1CQUFtQixvQkFBb0IsZUFBZSxFQUFFLEVBQUUsY0FBYyxJQUFJLDZCQUE2Qiw2R0FBNkcsb0JBQW9CLHdCQUF3Qiw4Q0FBOEMsbUJBQW1CLDJEQUEyRCxRQUFRLEVBQUUsT0FBTyxtQkFBbUIsaUJBQWlCLGVBQWUsOENBQThDLGdDQUFnQyxlQUFlLDJDQUEyQyw0RkFBNEYscUNBQXFDLGtCQUFrQixvSEFBb0gsaUJBQWlCLGlCQUFpQixJQUFJLDBCQUEwQiw4Q0FBOEMsb0JBQW9CLGlCQUFpQixjQUFjLDZCQUE2Qiw4QkFBOEIsZ0NBQWdDLDBCQUEwQix5QkFBeUIsaUJBQWlCLEVBQUUsTUFBTSxhQUFhLHNCQUFzQixtRUFBbUUsNkJBQTZCLGlFQUFpRSxJQUFJLDJCQUEyQixzQkFBc0IsV0FBVyxFQUFFLFNBQVMsMEJBQTBCLG1CQUFtQixhQUFhLHdCQUF3QixjQUFjLDJDQUEyQyxjQUFjLDZCQUE2QixrQkFBa0IsbURBQW1ELFdBQVcsSUFBSSxTQUFTLEVBQUUsdUJBQXVCLHlCQUF5QixRQUFRLGVBQWUsUUFBUSxnREFBZ0QsRUFBRSxTQUFTLDBCQUEwQiwyREFBMkQsYUFBYSxPQUFPLGNBQWMsNENBQTRDLCtGQUErRixvQkFBb0IsY0FBYyxFQUFFLE9BQU8sZ0NBQWdDLDRDQUE0QywrRUFBK0UsS0FBSyxFQUFFLFFBQVEsRUFBRSwwQkFBMEIsNENBQTRDLHdCQUF3Qiw2QkFBNkIsY0FBYyxvQkFBb0IsRUFBRSwyQkFBMkIsZ0ZBQWdGLE9BQU8sNkJBQTZCLFVBQVUsU0FBUyxhQUFhLHVCQUF1Qiw4REFBOEQsa0JBQWtCLHdEQUF3RCxJQUFJLDZCQUE2QjtBQUN6NFEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvZ3JvcS1zdG9yZS9kaXN0L2Jyb3dzZXIvZ3JvcS1zdG9yZS5qcz9iOTExIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBlPXJlcXVpcmUoXCJncm9xXCIpLHI9cmVxdWlyZShcImZhc3QtZGVlcC1lcXVhbFwiKSx0PXJlcXVpcmUoXCJ0aHJvdHRsZS1kZWJvdW5jZVwiKSxuPXJlcXVpcmUoXCJncm9xLWpzXCIpLG89cmVxdWlyZShcIm1lbmRvemFcIik7ZnVuY3Rpb24gaShlKXtyZXR1cm4gZSYmXCJvYmplY3RcIj09dHlwZW9mIGUmJlwiZGVmYXVsdFwiaW4gZT9lOntkZWZhdWx0OmV9fXZhciB1PS8qI19fUFVSRV9fKi9pKGUpLHM9LyojX19QVVJFX18qL2kocik7ZnVuY3Rpb24gYSgpe3JldHVybiBhPU9iamVjdC5hc3NpZ24/T2JqZWN0LmFzc2lnbi5iaW5kKCk6ZnVuY3Rpb24oZSl7Zm9yKHZhciByPTE7cjxhcmd1bWVudHMubGVuZ3RoO3IrKyl7dmFyIHQ9YXJndW1lbnRzW3JdO2Zvcih2YXIgbiBpbiB0KU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG4pJiYoZVtuXT10W25dKX1yZXR1cm4gZX0sYS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dmFyIGMsZj1mdW5jdGlvbihlLHIsdCl7KGZ1bmN0aW9uKGUpe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJmUuYWRkRXZlbnRMaXN0ZW5lcj09PXdpbmRvdy5FdmVudFNvdXJjZS5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcn0pKGUpJiZlLmFkZEV2ZW50TGlzdGVuZXIocix0LCExKSxlLmFkZEV2ZW50TGlzdGVuZXIocix0KX07ZnVuY3Rpb24gZChlLHIsdCl7dmFyIG4sbz1yLnRva2VuLGk9bmV3IGUoXCJodHRwczovL1wiK3IucHJvamVjdElkK1wiLmFwaS5zYW5pdHkuaW8vdjEvZGF0YS9saXN0ZW4vXCIrci5kYXRhc2V0K1wiP3F1ZXJ5PSomZWZmZWN0Rm9ybWF0PW1lbmRvemFcIix7d2l0aENyZWRlbnRpYWxzOiEwLGhlYWRlcnM6bz97QXV0aG9yaXphdGlvbjpcIkJlYXJlciBcIitvfTp2b2lkIDB9KTtyZXR1cm4gZihpLFwid2VsY29tZVwiLHQub3BlbiksZihpLFwibXV0YXRpb25cIiwobj10Lm5leHQsZnVuY3Rpb24oZSl7dmFyIHI7dHJ5e3I9SlNPTi5wYXJzZShlLmRhdGEpfWNhdGNoKGUpe3JldHVybn1uKHIpfSkpLGYoaSxcImNoYW5uZWxFcnJvclwiLGZ1bmN0aW9uKGUpe3ZhciByO2kuY2xvc2UoKTt0cnl7cj1KU09OLnBhcnNlKGUuZGF0YSl9Y2F0Y2goZSl7cmV0dXJuIHZvaWQgdC5lcnJvcihuZXcgRXJyb3IoXCJVbmtub3duIGVycm9yIHBhcnNpbmcgbGlzdGVuZXIgbWVzc2FnZVwiKSl9dC5lcnJvcihuZXcgRXJyb3Ioci5tZXNzYWdlfHxyLmVycm9yfHxcIkxpc3RlbmVyIHJldHVybmVkIEhUVFAgXCIrci5zdGF0dXNDb2RlKSl9KSxmKGksXCJlcnJvclwiLGZ1bmN0aW9uKGUpe3ZhciByPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJndpbmRvdy5sb2NhdGlvbi5vcmlnaW4sbj1yP1wiLCBhbmQgdGhhdCB0aGUgQ09SUy1vcmlnaW4gKFwiK3IrXCIpIGlzIGFsbG93ZWRcIjpcIlwiLG89ZnVuY3Rpb24oZSl7cmV0dXJuXCJvYmplY3RcIj09dHlwZW9mIGUmJm51bGwhPT1lJiZcIm1lc3NhZ2VcImluIGV9KGUpP1wiIChcIitlLm1lc3NhZ2UrXCIpXCI6XCJcIjt0LmVycm9yKG5ldyBFcnJvcihcIkVycm9yIGVzdGFibGlzaGluZyBsaXN0ZW5lciAtIGNoZWNrIHRoYXQgdGhlIHByb2plY3QgSUQgYW5kIGRhdGFzZXQgYXJlIGNvcnJlY3RcIituK28pKX0pLHt1bnN1YnNjcmliZTpmdW5jdGlvbigpe3JldHVybiBQcm9taXNlLnJlc29sdmUoaS5jbG9zZSgpKX19fWZ1bmN0aW9uIHYoZSl7cmV0dXJuIGUuX2lkLnN0YXJ0c1dpdGgoXCJkcmFmdHMuXCIpP2UuX2lkLnNsaWNlKDcpOmUuX2lkfWZ1bmN0aW9uIGwoZSxyKXt2YXIgdD1hKHt9LGUpO3JldHVybiBkZWxldGUgdC5fcmV2LG8uYXBwbHlQYXRjaCh0LHIpfWZ1bmN0aW9uIGgoKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCl9ZnVuY3Rpb24gbShlLHIsdCl7aWYoIWUucyl7aWYodCBpbnN0YW5jZW9mIHApe2lmKCF0LnMpcmV0dXJuIHZvaWQodC5vPW0uYmluZChudWxsLGUscikpOzEmciYmKHI9dC5zKSx0PXQudn1pZih0JiZ0LnRoZW4pcmV0dXJuIHZvaWQgdC50aGVuKG0uYmluZChudWxsLGUsciksbS5iaW5kKG51bGwsZSwyKSk7ZS5zPXIsZS52PXQ7Y29uc3Qgbj1lLm87biYmbihlKX19dmFyIHA9LyojX19QVVJFX18qL2Z1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe31yZXR1cm4gZS5wcm90b3R5cGUudGhlbj1mdW5jdGlvbihyLHQpe3ZhciBuPW5ldyBlLG89dGhpcy5zO2lmKG8pe3ZhciBpPTEmbz9yOnQ7aWYoaSl7dHJ5e20obiwxLGkodGhpcy52KSl9Y2F0Y2goZSl7bShuLDIsZSl9cmV0dXJuIG59cmV0dXJuIHRoaXN9cmV0dXJuIHRoaXMubz1mdW5jdGlvbihlKXt0cnl7dmFyIG89ZS52OzEmZS5zP20obiwxLHI/cihvKTpvKTp0P20obiwxLHQobykpOm0obiwyLG8pfWNhdGNoKGUpe20obiwyLGUpfX0sbn0sZX0oKTtmdW5jdGlvbiB3KGUpe3JldHVybiBlIGluc3RhbmNlb2YgcCYmMSZlLnN9dmFyIGI9ZnVuY3Rpb24oZSl7dmFyIHI9ZS5wcm9qZWN0SWQsdD1lLmRhdGFzZXQsbj1lLnRva2VuLG89ZS5kb2N1bWVudExpbWl0O3RyeXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZldGNoKFwiaHR0cHM6Ly9cIityK1wiLmFwaS5zYW5pdHkuaW8vdjEvZGF0YS9leHBvcnQvXCIrdCx7Y3JlZGVudGlhbHM6XCJpbmNsdWRlXCIsaGVhZGVyczpuP3tBdXRob3JpemF0aW9uOlwiQmVhcmVyIFwiK259OnZvaWQgMH0pKS50aGVuKGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHIocil7dmFyIHQsbixpPWZ1bmN0aW9uKGUpe2lmKCFlKXRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byByZWFkIGJvZHkgZnJvbSByZXNwb25zZVwiKTt2YXIgcix0PSExO2Z1bmN0aW9uIG4oKXt0PSEwLHImJnIuY2FuY2VsKCl9cmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7c3RhcnQ6ZnVuY3Rpb24obyl7cj1lLmdldFJlYWRlcigpO3ZhciBpPW5ldyBUZXh0RGVjb2Rlcix1PVwiXCI7ci5yZWFkKCkudGhlbihmdW5jdGlvbiBlKHMpe3RyeXtpZihzLmRvbmUpcmV0dXJuIHQ/UHJvbWlzZS5yZXNvbHZlKCk6MD09PSh1PXUudHJpbSgpKS5sZW5ndGg/KG8uY2xvc2UoKSxQcm9taXNlLnJlc29sdmUoKSk6KG8uZW5xdWV1ZShKU09OLnBhcnNlKHUpKSxvLmNsb3NlKCksUHJvbWlzZS5yZXNvbHZlKCkpO2Zvcih2YXIgYT0odSs9aS5kZWNvZGUocy52YWx1ZSx7c3RyZWFtOiEwfSkpLnNwbGl0KFwiXFxuXCIpLGM9MDtjPGEubGVuZ3RoLTE7KytjKXt2YXIgZj1hW2NdLnRyaW0oKTtpZigwIT09Zi5sZW5ndGgpdHJ5e28uZW5xdWV1ZShKU09OLnBhcnNlKGYpKX1jYXRjaChlKXtyZXR1cm4gby5lcnJvcihlKSxuKCksUHJvbWlzZS5yZXNvbHZlKCl9fWlmKHU9YVthLmxlbmd0aC0xXSwhcilyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7dmFyIGQ9ZnVuY3Rpb24odCxuKXt0cnl7dmFyIG89UHJvbWlzZS5yZXNvbHZlKHIucmVhZCgpKS50aGVuKGZ1bmN0aW9uKHIpe2Uocil9KX1jYXRjaChlKXtyZXR1cm4gbihlKX1yZXR1cm4gbyYmby50aGVuP28udGhlbih2b2lkIDAsbik6b30oMCxmdW5jdGlvbihlKXtvLmVycm9yKGUpfSk7cmV0dXJuIFByb21pc2UucmVzb2x2ZShkJiZkLnRoZW4/ZC50aGVuKGZ1bmN0aW9uKCl7fSk6dm9pZCAwKX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fSkuY2F0Y2goZnVuY3Rpb24oZSl7cmV0dXJuIG8uZXJyb3IoZSl9KX0sY2FuY2VsOm59KX0oZS5ib2R5KSx1PWkuZ2V0UmVhZGVyKCkscz1bXSxhPWZ1bmN0aW9uKGUscil7dmFyIHQ7ZG97dmFyIG49ZSgpO2lmKG4mJm4udGhlbil7aWYoIXcobikpe3Q9ITA7YnJlYWt9bj1uLnZ9dmFyIG89cigpO2lmKHcobykmJihvPW8udiksIW8pcmV0dXJuIG59d2hpbGUoIW8udGhlbik7dmFyIGk9bmV3IHAsdT1tLmJpbmQobnVsbCxpLDIpO3JldHVybih0P24udGhlbihzKTpvLnRoZW4oYSkpLnRoZW4odm9pZCAwLHUpLGk7ZnVuY3Rpb24gcyh0KXtmb3Iobj10O3cobz1yKCkpJiYobz1vLnYpLG87KXtpZihvLnRoZW4pcmV0dXJuIHZvaWQgby50aGVuKGEpLnRoZW4odm9pZCAwLHUpO2lmKChuPWUoKSkmJm4udGhlbil7aWYoIXcobikpcmV0dXJuIHZvaWQgbi50aGVuKHMpLnRoZW4odm9pZCAwLHUpO249bi52fX1tKGksMSxuKX1mdW5jdGlvbiBhKHQpe2lmKHQpe2Rve2lmKChuPWUoKSkmJm4udGhlbil7aWYoIXcobikpcmV0dXJuIHZvaWQgbi50aGVuKHMpLnRoZW4odm9pZCAwLHUpO249bi52fWlmKHcodD1yKCkpJiYodD10LnYpLCF0KXJldHVybiB2b2lkIG0oaSwxLG4pfXdoaWxlKCF0LnRoZW4pO3QudGhlbihhKS50aGVuKHZvaWQgMCx1KX1lbHNlIG0oaSwxLG4pfX0oZnVuY3Rpb24oKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHUucmVhZCgpKS50aGVuKGZ1bmN0aW9uKGUpe2lmKGZ1bmN0aW9uKGUpe3JldHVybiEhZSYmXCJlcnJvclwiaW4gZSYmXCJvYmplY3RcIj09dHlwZW9mIGUuZXJyb3ImJm51bGwhPT1lLmVycm9yJiZcImRlc2NyaXB0aW9uXCJpbiBlLmVycm9yJiZcInN0cmluZ1wiPT10eXBlb2YgZS5lcnJvci5kZXNjcmlwdGlvbiYmIShcIl9pZFwiaW4gZSl9KG49KHQ9ZSkudmFsdWUpKXRocm93IG5ldyBFcnJvcihcIkVycm9yIHN0cmVhbWluZyBkYXRhc2V0OiBcIituLmVycm9yKTtpZihuJiYhbi5faWQuc3RhcnRzV2l0aChcIl8uXCIpJiZzLnB1c2gobiksbyYmcy5sZW5ndGg+byl0aHJvdyB1LmNhbmNlbChcIlJlYWNoZWQgZG9jdW1lbnQgbGltaXRcIiksbmV3IEVycm9yKFwiRXJyb3Igc3RyZWFtaW5nIGRhdGFzZXQ6IFJlYWNoZWQgbGltaXQgb2YgXCIrbytcIiBkb2N1bWVudHNcIil9KX0sZnVuY3Rpb24oKXtyZXR1cm4hdC5kb25lfSk7cmV0dXJuIGEmJmEudGhlbj9hLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIHN9KTpzfXZhciB0PWZ1bmN0aW9uKCl7aWYoMjAwIT09ZS5zdGF0dXMpcmV0dXJuIFByb21pc2UucmVzb2x2ZShlLmpzb24oKSkudGhlbihmdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBzdHJlYW1pbmcgZGF0YXNldDogXCIrKFwib2JqZWN0XCI9PXR5cGVvZihyPWUpJiZcImVycm9yXCJpbiByJiZcIm1lc3NhZ2VcImluIHI/ci5tZXNzYWdlfHxyLmVycm9yOlwiPHVua25vd24gZXJyb3I+XCIpKTt2YXIgcn0pfSgpO3JldHVybiB0JiZ0LnRoZW4/dC50aGVuKHIpOnIoKX0pfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiZ3JvcVwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB1LmRlZmF1bHR9fSksZXhwb3J0cy5ncm9xU3RvcmU9ZnVuY3Rpb24oZSl7dmFyIHI7IWZ1bmN0aW9uKCl7dmFyIGU9W1wiRXZlbnRTb3VyY2VcIixcIlJlYWRhYmxlU3RyZWFtXCIsXCJmZXRjaFwiXS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIShlIGluIHdpbmRvdyl9KTtpZihlLmxlbmd0aD4wKXRocm93IG5ldyBFcnJvcihcIkJyb3dzZXIgbm90IHN1cHBvcnRlZC4gTWlzc2luZyBicm93c2VyIEFQSXM6IFwiK2Uuam9pbihcIiwgXCIpKX0oKTt2YXIgbz1udWxsIT0ocj1lLkV2ZW50U291cmNlKT9yOndpbmRvdy5FdmVudFNvdXJjZTtpZihlLnRva2VuJiZvPT09d2luZG93LkV2ZW50U291cmNlKXRocm93IG5ldyBFcnJvcihcIldoZW5gdG9rZW5gIG9wdGlvbiBpcyB1c2VkLCBgRXZlbnRTb3VyY2VgIG9wdGlvbiBtdXN0IGFsc28gYmUgcHJvdmlkZWQuIEV2ZW50U291cmNlIGNhbm5vdCBiZSBgd2luZG93LkV2ZW50U291cmNlYCwgYXMgaXQgZG9lcyBub3Qgc3VwcG9ydCBwYXNzaW5nIGEgdG9rZW4uXCIpO3JldHVybiBmdW5jdGlvbihlLHIpe3ZhciBvLGk9ZnVuY3Rpb24oZSxyKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGYoKSkudGhlbihmdW5jdGlvbigpe3ZhciB0PW4ucGFyc2UoZSx7cGFyYW1zOnJ9KTtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG4uZXZhbHVhdGUodCx7ZGF0YXNldDptLHBhcmFtczpyfSkpLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIGUuZ2V0KCl9KX0pfSxmPWZ1bmN0aW9uKCl7dHJ5e3JldHVybiBvfHwobz1mdW5jdGlvbihlLHIsdCl7dmFyIG49dC5nZXREb2N1bWVudHMsbz10LkV2ZW50U291cmNlLGk9ZS5wcm9qZWN0SWQsdT1lLmRhdGFzZXQscz1lLm92ZXJsYXlEcmFmdHMsYz1lLmRvY3VtZW50TGltaXQsZj1lLnRva2VuO2lmKCFlLmxpc3RlbilyZXR1cm57dW5zdWJzY3JpYmU6aCxsb2FkZWQ6bih7cHJvamVjdElkOmksZGF0YXNldDp1LGRvY3VtZW50TGltaXQ6Yyx0b2tlbjpmfSkudGhlbihTKS50aGVuKGgpfTt2YXIgbSxwLHcsYixnLHksRT1uZXcgTWFwLFA9W10saj1uZXcgUHJvbWlzZShmdW5jdGlvbihlLHIpe3A9ZSx3PXJ9KTtyZXR1cm57dW5zdWJzY3JpYmU6ZChvLGUse25leHQ6ZnVuY3Rpb24oZSl7bT8oZnVuY3Rpb24oZSl7aWYoZS5lZmZlY3RzJiYhZS5kb2N1bWVudElkLnN0YXJ0c1dpdGgoXCJfLlwiKSl7dmFyIHI9RS5nZXQoZS5kb2N1bWVudElkKXx8bnVsbDshZnVuY3Rpb24oZSxyKXt2YXIgdD1FLmdldChlKSxuPW18fFtdLG89dD9uLmluZGV4T2YodCk6LTE7LTE9PT1vJiZyPyhuLnB1c2gociksRS5zZXQoZSxyKSk6cj8obi5zcGxpY2UobywxLHIpLEUuc2V0KGUscikpOihuLnNwbGljZShvLDEpLEUuZGVsZXRlKGUpKX0oZS5kb2N1bWVudElkLGwocixlLmVmZmVjdHMuYXBwbHkpKX19KGUpLGZ1bmN0aW9uKGUscil7Y2xlYXJUaW1lb3V0KHkpLGchPT1yLnRyYW5zYWN0aW9uSWQmJmI/KFMoYiksZz12b2lkIDApOihnPXIudHJhbnNhY3Rpb25JZCxiPWUuc2xpY2UoKSkseT1zZXRUaW1lb3V0KFMsMjUsZS5zbGljZSgpKX0obSxlKSk6UC5wdXNoKGUpfSxvcGVuOmZ1bmN0aW9uKCl7dHJ5e3JldHVybiBQcm9taXNlLnJlc29sdmUobih7cHJvamVjdElkOmksZGF0YXNldDp1LGRvY3VtZW50TGltaXQ6Yyx0b2tlbjpmfSkpLnRoZW4oZnVuY3Rpb24oZSl7KG09ZnVuY3Rpb24oZSxyKXt2YXIgdD1uZXcgTWFwO3JldHVybiByLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIHI9dC5nZXQoZS5kb2N1bWVudElkKXx8W107ci5wdXNoKGUpLHQuc2V0KGUuZG9jdW1lbnRJZCxyKX0pLHQuZm9yRWFjaChmdW5jdGlvbihyLHQpe3ZhciBuPWUuZmluZChmdW5jdGlvbihlKXtyZXR1cm4gZS5faWQ9PT10fSk7aWYobil7dmFyIG89ITEsaT1uO3IuZm9yRWFjaChmdW5jdGlvbihlKXsobz1vfHxlLnByZXZpb3VzUmV2PT09bi5fcmV2KSYmZS5lZmZlY3RzJiYoaT1sKGksZS5lZmZlY3RzLmFwcGx5KSl9KSxlLnNwbGljZShlLmluZGV4T2YobiksMSxpKX1lbHNlIGNvbnNvbGUud2FybihcIlJlY2VpdmVkIG11dGF0aW9uIGZvciBtaXNzaW5nIGRvY3VtZW50ICVzXCIsdCl9KSxlfShlLFApKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBFLnNldChlLl9pZCxlKX0pLFMobSkscCgpfSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX0sZXJyb3I6ZnVuY3Rpb24oZSl7cmV0dXJuIHcoZSl9fSkudW5zdWJzY3JpYmUsbG9hZGVkOmp9O2Z1bmN0aW9uIFMoZSl7Yj12b2lkIDAseT12b2lkIDAsZz12b2lkIDAscihzP2Z1bmN0aW9uKGUpe3ZhciByPW5ldyBNYXA7cmV0dXJuIGUuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD1yLmdldCh2KGUpKTtlLl9pZC5zdGFydHNXaXRoKFwiZHJhZnRzLlwiKT9yLnNldCh2KGUpLGZ1bmN0aW9uKGUpe3JldHVybiBhKHt9LGUse19pZDp2KGUpfSl9KGUpKTp0fHxyLnNldChlLl9pZCxlKX0pLEFycmF5LmZyb20oci52YWx1ZXMoKSl9KGUpOmUpfX0oZSxmdW5jdGlvbihlKXttPWUscCgpfSxyKSksUHJvbWlzZS5yZXNvbHZlKG8ubG9hZGVkKS50aGVuKGZ1bmN0aW9uKCl7fSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX0sbT1bXSxwPXQudGhyb3R0bGUoZS5zdWJzY3JpcHRpb25UaHJvdHRsZU1zfHw1MCxmdW5jdGlvbigpe3cuZm9yRWFjaChiKX0pLHc9W107ZnVuY3Rpb24gYihlKXtyZXR1cm4gaShlLnF1ZXJ5LGUucGFyYW1zKS50aGVuKGZ1bmN0aW9uKHIpe1wicHJldmlvdXNSZXN1bHRcImluIGUmJnMuZGVmYXVsdChlLnByZXZpb3VzUmVzdWx0LHIpfHwoZS5wcmV2aW91c1Jlc3VsdD1yLGUuY2FsbGJhY2sodm9pZCAwLHIpKX0pLmNhdGNoKGZ1bmN0aW9uKHIpe2UuY2FsbGJhY2socil9KX1yZXR1cm57cXVlcnk6aSxnZXREb2N1bWVudDpmdW5jdGlvbihlKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGYoKSkudGhlbihmdW5jdGlvbigpe3JldHVybiBpKHUuZGVmYXVsdChjfHwocj1bXCIqW19pZCA9PSAkaWRdWzBdXCJdLHR8fCh0PXIuc2xpY2UoMCkpLHIucmF3PXQsYz1yKSkse2lkOmV9KTt2YXIgcix0fSl9LGdldERvY3VtZW50czpmdW5jdGlvbihlKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGYoKSkudGhlbihmdW5jdGlvbigpe3ZhciByPWUubWFwKGZ1bmN0aW9uKGUpe3JldHVybicqW19pZCA9PSBcIicrZSsnXCJdWzBdJ30pLmpvaW4oXCIsXFxuXCIpO3JldHVybiBpKFwiW1wiK3IrXCJdXCIpfSl9LHN1YnNjcmliZTpmdW5jdGlvbihyLHQsbil7aWYoIWUubGlzdGVuKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1c2UgYHN1YnNjcmliZSgpYCB3aXRob3V0IGBsaXN0ZW46IHRydWVgXCIpO3ZhciBvPXtxdWVyeTpyLHBhcmFtczp0LGNhbGxiYWNrOm59O3cucHVzaChvKTt2YXIgaT0hMTtyZXR1cm4gYihvKSx7dW5zdWJzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm4gaXx8KGk9ITAsdy5zcGxpY2Uody5pbmRleE9mKG8pLDEpKSxQcm9taXNlLnJlc29sdmUoKX19fSxjbG9zZTpmdW5jdGlvbigpe3JldHVybiBwLmNhbmNlbCgpLG8/by51bnN1YnNjcmliZSgpOlByb21pc2UucmVzb2x2ZSgpfX19KGUse0V2ZW50U291cmNlOm8sZ2V0RG9jdW1lbnRzOmJ9KX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncm9xLXN0b3JlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@sanity/groq-store/dist/browser/groq-store.js\n"));

/***/ }),

/***/ "./node_modules/fast-deep-equal/index.js":
/*!***********************************************!*\
  !*** ./node_modules/fast-deep-equal/index.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmFzdC1kZWVwLWVxdWFsL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsVUFBVTtBQUMvQjs7QUFFQSxxQkFBcUIsVUFBVTtBQUMvQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYXN0LWRlZXAtZXF1YWwvaW5kZXguanM/MGJjNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIGRvIG5vdCBlZGl0IC5qcyBmaWxlcyBkaXJlY3RseSAtIGVkaXQgc3JjL2luZGV4LmpzdFxuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAoYSAmJiBiICYmIHR5cGVvZiBhID09ICdvYmplY3QnICYmIHR5cGVvZiBiID09ICdvYmplY3QnKSB7XG4gICAgaWYgKGEuY29uc3RydWN0b3IgIT09IGIuY29uc3RydWN0b3IpIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBsZW5ndGgsIGksIGtleXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgICBpZiAoIWVxdWFsKGFbaV0sIGJbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cblxuXG4gICAgaWYgKGEuY29uc3RydWN0b3IgPT09IFJlZ0V4cCkgcmV0dXJuIGEuc291cmNlID09PSBiLnNvdXJjZSAmJiBhLmZsYWdzID09PSBiLmZsYWdzO1xuICAgIGlmIChhLnZhbHVlT2YgIT09IE9iamVjdC5wcm90b3R5cGUudmFsdWVPZikgcmV0dXJuIGEudmFsdWVPZigpID09PSBiLnZhbHVlT2YoKTtcbiAgICBpZiAoYS50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykgcmV0dXJuIGEudG9TdHJpbmcoKSA9PT0gYi50b1N0cmluZygpO1xuXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwga2V5c1tpXSkpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmICghZXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyB0cnVlIGlmIGJvdGggTmFOLCBmYWxzZSBvdGhlcndpc2VcbiAgcmV0dXJuIGEhPT1hICYmIGIhPT1iO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/fast-deep-equal/index.js\n"));

/***/ }),

/***/ "./node_modules/mendoza/lib/esm/incremental-patcher.js":
/*!*************************************************************!*\
  !*** ./node_modules/mendoza/lib/esm/incremental-patcher.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"applyPatch\": function() { return /* binding */ applyPatch; },\n/* harmony export */   \"getType\": function() { return /* binding */ getType; },\n/* harmony export */   \"rebaseValue\": function() { return /* binding */ rebaseValue; },\n/* harmony export */   \"unwrap\": function() { return /* binding */ unwrap; },\n/* harmony export */   \"wrap\": function() { return /* binding */ wrap; }\n/* harmony export */ });\n/* harmony import */ var _internal_patcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal-patcher */ \"./node_modules/mendoza/lib/esm/internal-patcher.js\");\n/* harmony import */ var _utf8__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utf8 */ \"./node_modules/mendoza/lib/esm/utf8.js\");\n\n\nvar Model = /** @class */ (function () {\n    function Model(meta) {\n        this.meta = meta;\n    }\n    Model.prototype.wrap = function (data) {\n        return this.wrapWithMeta(data, this.meta, this.meta);\n    };\n    Model.prototype.wrapWithMeta = function (data, startMeta, endMeta) {\n        if (endMeta === void 0) { endMeta = this.meta; }\n        return { data: data, startMeta: startMeta, endMeta: endMeta };\n    };\n    Model.prototype.asObject = function (value) {\n        if (!value.content) {\n            var fields = {};\n            for (var _i = 0, _a = Object.entries(value.data); _i < _a.length; _i++) {\n                var _b = _a[_i], key = _b[0], val = _b[1];\n                fields[key] = this.wrapWithMeta(val, value.startMeta);\n            }\n            value.content = { type: 'object', fields: fields };\n        }\n        return value.content;\n    };\n    Model.prototype.asArray = function (value) {\n        var _this = this;\n        if (!value.content) {\n            var elements = value.data.map(function (item) { return _this.wrapWithMeta(item, value.startMeta); });\n            var metas = elements.map(function () { return _this.meta; });\n            value.content = { type: 'array', elements: elements, metas: metas };\n        }\n        return value.content;\n    };\n    Model.prototype.asString = function (value) {\n        if (!value.content) {\n            var str = value.data;\n            var part = {\n                value: str,\n                utf8size: (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8stringSize)(str),\n                uses: [],\n                startMeta: value.startMeta,\n                endMeta: value.endMeta\n            };\n            value.content = this.stringFromParts([part]);\n        }\n        return value.content;\n    };\n    Model.prototype.stringFromParts = function (parts) {\n        var str = {\n            type: 'string',\n            parts: parts\n        };\n        for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {\n            var part = parts_1[_i];\n            part.uses.push(str);\n        }\n        return str;\n    };\n    Model.prototype.objectGetKeys = function (value) {\n        if (value.content) {\n            return Object.keys(value.content.fields);\n        }\n        else {\n            return Object.keys(value.data);\n        }\n    };\n    Model.prototype.objectGetField = function (value, key) {\n        var obj = this.asObject(value);\n        return obj.fields[key];\n    };\n    Model.prototype.arrayGetElement = function (value, idx) {\n        var arr = this.asArray(value);\n        return arr.elements[idx];\n    };\n    Model.prototype.finalize = function (content) {\n        this.updateEndMeta(content);\n        return { content: content, startMeta: this.meta, endMeta: this.meta };\n    };\n    Model.prototype.markChanged = function (value) {\n        return this.wrap(unwrap(value));\n    };\n    Model.prototype.updateEndMeta = function (content) {\n        if (content.type == 'string') {\n            for (var _i = 0, _a = content.parts; _i < _a.length; _i++) {\n                var part = _a[_i];\n                part.endMeta = this.meta;\n            }\n        }\n        else {\n            if (content.type === 'array') {\n                for (var _b = 0, _c = content.elements; _b < _c.length; _b++) {\n                    var val = _c[_b];\n                    if (val.content && val.endMeta !== this.meta) {\n                        this.updateEndMeta(val.content);\n                    }\n                    val.endMeta = this.meta;\n                }\n            }\n            else {\n                for (var _d = 0, _e = Object.values(content.fields); _d < _e.length; _d++) {\n                    var val = _e[_d];\n                    if (val.content && val.endMeta !== this.meta) {\n                        this.updateEndMeta(val.content);\n                    }\n                    val.endMeta = this.meta;\n                }\n            }\n        }\n    };\n    Model.prototype.copyString = function (value) {\n        if (value) {\n            var other = this.asString(value);\n            return this.stringFromParts(other.parts.slice());\n        }\n        else {\n            return {\n                type: 'string',\n                parts: []\n            };\n        }\n    };\n    Model.prototype.copyObject = function (value) {\n        var obj = {\n            type: 'object',\n            fields: {}\n        };\n        if (value) {\n            var other = this.asObject(value);\n            Object.assign(obj.fields, other.fields);\n        }\n        return obj;\n    };\n    Model.prototype.copyArray = function (value) {\n        var arr = value ? this.asArray(value) : null;\n        var elements = arr ? arr.elements : [];\n        var metas = arr ? arr.metas : [];\n        return {\n            type: 'array',\n            elements: elements,\n            metas: metas\n        };\n    };\n    Model.prototype.objectSetField = function (target, key, value) {\n        target.fields[key] = value;\n    };\n    Model.prototype.objectDeleteField = function (target, key) {\n        delete target.fields[key];\n    };\n    Model.prototype.arrayAppendValue = function (target, value) {\n        target.elements.push(value);\n        target.metas.push(this.meta);\n    };\n    Model.prototype.arrayAppendSlice = function (target, source, left, right) {\n        var _a, _b;\n        var arr = this.asArray(source);\n        var samePosition = arr.elements.length === left;\n        (_a = target.elements).push.apply(_a, arr.elements.slice(left, right));\n        if (samePosition) {\n            (_b = target.metas).push.apply(_b, arr.metas.slice(left, right));\n        }\n        else {\n            for (var i = left; i < right; i++) {\n                target.metas.push(this.meta);\n            }\n        }\n    };\n    Model.prototype.stringAppendValue = function (target, value) {\n        var str = this.asString(value);\n        for (var _i = 0, _a = str.parts; _i < _a.length; _i++) {\n            var part = _a[_i];\n            this.stringAppendPart(target, part);\n        }\n    };\n    Model.prototype.stringAppendPart = function (target, part) {\n        target.parts.push(part);\n        part.uses.push(target);\n    };\n    Model.prototype.resolveStringPart = function (str, from, len) {\n        if (len === 0)\n            return from;\n        for (var i = from; i < str.parts.length; i++) {\n            var part = str.parts[i];\n            if (len === part.utf8size) {\n                // Matches perfect!\n                return i + 1;\n            }\n            if (len < part.utf8size) {\n                // It's a part of this chunk. We now need to split it up.\n                this.splitString(part, len);\n                return i + 1;\n            }\n            len -= part.utf8size;\n        }\n        throw new Error('splitting string out of bounds');\n    };\n    Model.prototype.splitString = function (part, idx) {\n        var leftValue;\n        var rightValue;\n        var leftSize = idx;\n        var rightSize = part.utf8size - leftSize;\n        // idx is here in UTF-8 index, not codepoint index.\n        // This means we might to adjust for multi-byte characters.\n        if (part.utf8size !== part.value.length) {\n            var byteCount = 0;\n            for (idx = 0; byteCount < leftSize; idx++) {\n                var code = part.value.codePointAt(idx);\n                var size = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8charSize)(code);\n                if (size === 4)\n                    idx++; // Surrogate pair.\n                byteCount += size;\n            }\n        }\n        leftValue = part.value.slice(0, idx);\n        rightValue = part.value.slice(idx);\n        var newPart = {\n            value: rightValue,\n            utf8size: rightSize,\n            uses: part.uses.slice(),\n            startMeta: part.startMeta,\n            endMeta: part.endMeta\n        };\n        part.value = leftValue;\n        part.utf8size = leftSize;\n        for (var _i = 0, _a = part.uses; _i < _a.length; _i++) {\n            var use = _a[_i];\n            // Insert the new part.\n            var idx_1 = use.parts.indexOf(part);\n            if (idx_1 === -1)\n                throw new Error('bug: mismatch between string parts and use.');\n            use.parts.splice(idx_1 + 1, 0, newPart);\n        }\n    };\n    Model.prototype.stringAppendSlice = function (target, source, left, right) {\n        var str = this.asString(source);\n        var firstPart = this.resolveStringPart(str, 0, left);\n        var lastPart = this.resolveStringPart(str, firstPart, right - left);\n        for (var i = firstPart; i < lastPart; i++) {\n            var part = str.parts[i];\n            this.stringAppendPart(target, part);\n        }\n    };\n    return Model;\n}());\n// Turns a native JavaScript object into a Value with a given origin.\nfunction wrap(data, meta) {\n    return { data: data, startMeta: meta, endMeta: meta };\n}\n// Converts a Value into a native JavaScript type.\nfunction unwrap(value) {\n    if (typeof value.data !== 'undefined')\n        return value.data;\n    var result;\n    var content = value.content;\n    switch (content.type) {\n        case 'string':\n            result = content.parts.map(function (part) { return part.value; }).join('');\n            break;\n        case 'array':\n            result = content.elements.map(function (val) { return unwrap(val); });\n            break;\n        case 'object': {\n            result = {};\n            for (var _i = 0, _a = Object.entries(content.fields); _i < _a.length; _i++) {\n                var _b = _a[_i], key = _b[0], val = _b[1];\n                result[key] = unwrap(val);\n            }\n        }\n    }\n    value.data = result;\n    return result;\n}\n// Returns the type of a Value.\nfunction getType(value) {\n    if (value.content)\n        return value.content.type;\n    if (Array.isArray(value.data))\n        return 'array';\n    if (value.data === null)\n        return 'null';\n    return typeof value.data;\n}\n// Updates the `right` value such that it reuses as much as possible from the `left` value.\nfunction rebaseValue(left, right) {\n    var leftType = getType(left);\n    var rightType = getType(right);\n    if (leftType !== rightType)\n        return right;\n    var leftModel = new Model(left.endMeta);\n    var rightModel = new Model(right.endMeta);\n    switch (leftType) {\n        case 'object': {\n            var leftObj = leftModel.asObject(left);\n            var rightObj = rightModel.asObject(right);\n            // Number of fields which are identical in left and right.\n            var identicalFieldCount = 0;\n            var leftFieldCount = Object.keys(leftObj.fields).length;\n            var rightFieldCount = Object.keys(rightObj.fields).length;\n            for (var _i = 0, _a = Object.entries(rightObj.fields); _i < _a.length; _i++) {\n                var _b = _a[_i], key = _b[0], rightVal = _b[1];\n                var leftVal = leftObj.fields[key];\n                if (leftVal) {\n                    rightObj.fields[key] = rebaseValue(leftVal, rightVal);\n                    if (rightObj.fields[key] === leftVal) {\n                        identicalFieldCount++;\n                    }\n                }\n            }\n            var isIdentical = leftFieldCount === rightFieldCount && leftFieldCount === identicalFieldCount;\n            return isIdentical ? left : right;\n        }\n        case 'array': {\n            var leftArr = leftModel.asArray(left);\n            var rightArr = rightModel.asArray(right);\n            if (leftArr.elements.length !== rightArr.elements.length) {\n                break;\n            }\n            var numRebased = 0;\n            for (var i = 0; i < rightArr.elements.length; i++) {\n                rightArr.elements[i] = rebaseValue(leftArr.elements[i], rightArr.elements[i]);\n                if (rightArr.elements[i] !== leftArr.elements[i]) {\n                    numRebased++;\n                }\n            }\n            return numRebased === 0 ? left : right;\n        }\n        case 'null':\n        case 'boolean':\n        case 'number': {\n            if (unwrap(left) === unwrap(right))\n                return left;\n            break;\n        }\n        case 'string': {\n            var leftRaw = unwrap(left);\n            var rightRaw = unwrap(right);\n            if (leftRaw === rightRaw)\n                return left;\n            var result = rightModel.copyString(null);\n            var prefix = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.commonPrefix)(leftRaw, rightRaw);\n            var suffix = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.commonSuffix)(leftRaw, rightRaw, prefix);\n            var rightLen = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8stringSize)(rightRaw);\n            var leftLen = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8stringSize)(leftRaw);\n            if (0 < prefix) {\n                rightModel.stringAppendSlice(result, left, 0, prefix);\n            }\n            if (prefix < rightLen - suffix) {\n                rightModel.stringAppendSlice(result, right, prefix, rightLen - suffix);\n            }\n            if (leftLen - suffix < leftLen) {\n                rightModel.stringAppendSlice(result, left, leftLen - suffix, leftLen);\n            }\n            var value = rightModel.finalize(result);\n            if (unwrap(value) !== rightRaw)\n                throw new Error('incorrect string rebase');\n            return value;\n        }\n    }\n    return right;\n}\nfunction applyPatch(left, patch, startMeta) {\n    var model = new Model(startMeta);\n    var patcher = new _internal_patcher__WEBPACK_IMPORTED_MODULE_1__.Patcher(model, left, patch);\n    return patcher.process();\n}\n//# sourceMappingURL=incremental-patcher.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL2luY3JlbWVudGFsLXBhdGNoZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUE2QztBQUNxQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxnQkFBZ0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxtREFBbUQ7QUFDL0csbURBQW1ELG9CQUFvQjtBQUN2RSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxREFBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxxQkFBcUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZ0JBQWdCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxnQkFBZ0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxnQkFBZ0I7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsV0FBVztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0JBQXNCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0JBQXNCO0FBQ2hEO0FBQ0EsMkJBQTJCLG1EQUFZO0FBQ3ZDO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxjQUFjO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDTztBQUNQLGFBQWE7QUFDYjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsb0JBQW9CO0FBQzdFO0FBQ0E7QUFDQSwyREFBMkQscUJBQXFCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxnQkFBZ0I7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsZ0JBQWdCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDhCQUE4QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1EQUFZO0FBQ3JDLHlCQUF5QixtREFBWTtBQUNyQywyQkFBMkIscURBQWM7QUFDekMsMEJBQTBCLHFEQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esc0JBQXNCLHNEQUFPO0FBQzdCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL2luY3JlbWVudGFsLXBhdGNoZXIuanM/ZTZmYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQYXRjaGVyIH0gZnJvbSAnLi9pbnRlcm5hbC1wYXRjaGVyJztcbmltcG9ydCB7IHV0ZjhjaGFyU2l6ZSwgdXRmOHN0cmluZ1NpemUsIGNvbW1vblByZWZpeCwgY29tbW9uU3VmZml4IH0gZnJvbSAnLi91dGY4JztcbnZhciBNb2RlbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNb2RlbChtZXRhKSB7XG4gICAgICAgIHRoaXMubWV0YSA9IG1ldGE7XG4gICAgfVxuICAgIE1vZGVsLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcFdpdGhNZXRhKGRhdGEsIHRoaXMubWV0YSwgdGhpcy5tZXRhKTtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS53cmFwV2l0aE1ldGEgPSBmdW5jdGlvbiAoZGF0YSwgc3RhcnRNZXRhLCBlbmRNZXRhKSB7XG4gICAgICAgIGlmIChlbmRNZXRhID09PSB2b2lkIDApIHsgZW5kTWV0YSA9IHRoaXMubWV0YTsgfVxuICAgICAgICByZXR1cm4geyBkYXRhOiBkYXRhLCBzdGFydE1ldGE6IHN0YXJ0TWV0YSwgZW5kTWV0YTogZW5kTWV0YSB9O1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLmFzT2JqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUuY29udGVudCkge1xuICAgICAgICAgICAgdmFyIGZpZWxkcyA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5lbnRyaWVzKHZhbHVlLmRhdGEpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBfYiA9IF9hW19pXSwga2V5ID0gX2JbMF0sIHZhbCA9IF9iWzFdO1xuICAgICAgICAgICAgICAgIGZpZWxkc1trZXldID0gdGhpcy53cmFwV2l0aE1ldGEodmFsLCB2YWx1ZS5zdGFydE1ldGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUuY29udGVudCA9IHsgdHlwZTogJ29iamVjdCcsIGZpZWxkczogZmllbGRzIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlLmNvbnRlbnQ7XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuYXNBcnJheSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXZhbHVlLmNvbnRlbnQpIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IHZhbHVlLmRhdGEubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBfdGhpcy53cmFwV2l0aE1ldGEoaXRlbSwgdmFsdWUuc3RhcnRNZXRhKTsgfSk7XG4gICAgICAgICAgICB2YXIgbWV0YXMgPSBlbGVtZW50cy5tYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMubWV0YTsgfSk7XG4gICAgICAgICAgICB2YWx1ZS5jb250ZW50ID0geyB0eXBlOiAnYXJyYXknLCBlbGVtZW50czogZWxlbWVudHMsIG1ldGFzOiBtZXRhcyB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZS5jb250ZW50O1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLmFzU3RyaW5nID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUuY29udGVudCkge1xuICAgICAgICAgICAgdmFyIHN0ciA9IHZhbHVlLmRhdGE7XG4gICAgICAgICAgICB2YXIgcGFydCA9IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogc3RyLFxuICAgICAgICAgICAgICAgIHV0ZjhzaXplOiB1dGY4c3RyaW5nU2l6ZShzdHIpLFxuICAgICAgICAgICAgICAgIHVzZXM6IFtdLFxuICAgICAgICAgICAgICAgIHN0YXJ0TWV0YTogdmFsdWUuc3RhcnRNZXRhLFxuICAgICAgICAgICAgICAgIGVuZE1ldGE6IHZhbHVlLmVuZE1ldGFcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YWx1ZS5jb250ZW50ID0gdGhpcy5zdHJpbmdGcm9tUGFydHMoW3BhcnRdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWUuY29udGVudDtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5zdHJpbmdGcm9tUGFydHMgPSBmdW5jdGlvbiAocGFydHMpIHtcbiAgICAgICAgdmFyIHN0ciA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgcGFydHM6IHBhcnRzXG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgcGFydHNfMSA9IHBhcnRzOyBfaSA8IHBhcnRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFydCA9IHBhcnRzXzFbX2ldO1xuICAgICAgICAgICAgcGFydC51c2VzLnB1c2goc3RyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLm9iamVjdEdldEtleXMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlLmNvbnRlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZS5jb250ZW50LmZpZWxkcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUuZGF0YSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5vYmplY3RHZXRGaWVsZCA9IGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgIHZhciBvYmogPSB0aGlzLmFzT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG9iai5maWVsZHNba2V5XTtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5hcnJheUdldEVsZW1lbnQgPSBmdW5jdGlvbiAodmFsdWUsIGlkeCkge1xuICAgICAgICB2YXIgYXJyID0gdGhpcy5hc0FycmF5KHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGFyci5lbGVtZW50c1tpZHhdO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy51cGRhdGVFbmRNZXRhKGNvbnRlbnQpO1xuICAgICAgICByZXR1cm4geyBjb250ZW50OiBjb250ZW50LCBzdGFydE1ldGE6IHRoaXMubWV0YSwgZW5kTWV0YTogdGhpcy5tZXRhIH07XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUubWFya0NoYW5nZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcCh1bndyYXAodmFsdWUpKTtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS51cGRhdGVFbmRNZXRhID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICAgICAgaWYgKGNvbnRlbnQudHlwZSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGNvbnRlbnQucGFydHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgcGFydC5lbmRNZXRhID0gdGhpcy5tZXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNvbnRlbnQudHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBjb250ZW50LmVsZW1lbnRzOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gX2NbX2JdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsLmNvbnRlbnQgJiYgdmFsLmVuZE1ldGEgIT09IHRoaXMubWV0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVFbmRNZXRhKHZhbC5jb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YWwuZW5kTWV0YSA9IHRoaXMubWV0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfZCA9IDAsIF9lID0gT2JqZWN0LnZhbHVlcyhjb250ZW50LmZpZWxkcyk7IF9kIDwgX2UubGVuZ3RoOyBfZCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBfZVtfZF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwuY29udGVudCAmJiB2YWwuZW5kTWV0YSAhPT0gdGhpcy5tZXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUVuZE1ldGEodmFsLmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhbC5lbmRNZXRhID0gdGhpcy5tZXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLmNvcHlTdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSB0aGlzLmFzU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmluZ0Zyb21QYXJ0cyhvdGhlci5wYXJ0cy5zbGljZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgcGFydHM6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuY29weU9iamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgb2JqID0ge1xuICAgICAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgICAgICBmaWVsZHM6IHt9XG4gICAgICAgIH07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIG90aGVyID0gdGhpcy5hc09iamVjdCh2YWx1ZSk7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG9iai5maWVsZHMsIG90aGVyLmZpZWxkcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5jb3B5QXJyYXkgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGFyciA9IHZhbHVlID8gdGhpcy5hc0FycmF5KHZhbHVlKSA6IG51bGw7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IGFyciA/IGFyci5lbGVtZW50cyA6IFtdO1xuICAgICAgICB2YXIgbWV0YXMgPSBhcnIgPyBhcnIubWV0YXMgOiBbXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgICAgICBlbGVtZW50czogZWxlbWVudHMsXG4gICAgICAgICAgICBtZXRhczogbWV0YXNcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5vYmplY3RTZXRGaWVsZCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGFyZ2V0LmZpZWxkc1trZXldID0gdmFsdWU7XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUub2JqZWN0RGVsZXRlRmllbGQgPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgZGVsZXRlIHRhcmdldC5maWVsZHNba2V5XTtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5hcnJheUFwcGVuZFZhbHVlID0gZnVuY3Rpb24gKHRhcmdldCwgdmFsdWUpIHtcbiAgICAgICAgdGFyZ2V0LmVsZW1lbnRzLnB1c2godmFsdWUpO1xuICAgICAgICB0YXJnZXQubWV0YXMucHVzaCh0aGlzLm1ldGEpO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLmFycmF5QXBwZW5kU2xpY2UgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHZhciBhcnIgPSB0aGlzLmFzQXJyYXkoc291cmNlKTtcbiAgICAgICAgdmFyIHNhbWVQb3NpdGlvbiA9IGFyci5lbGVtZW50cy5sZW5ndGggPT09IGxlZnQ7XG4gICAgICAgIChfYSA9IHRhcmdldC5lbGVtZW50cykucHVzaC5hcHBseShfYSwgYXJyLmVsZW1lbnRzLnNsaWNlKGxlZnQsIHJpZ2h0KSk7XG4gICAgICAgIGlmIChzYW1lUG9zaXRpb24pIHtcbiAgICAgICAgICAgIChfYiA9IHRhcmdldC5tZXRhcykucHVzaC5hcHBseShfYiwgYXJyLm1ldGFzLnNsaWNlKGxlZnQsIHJpZ2h0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gbGVmdDsgaSA8IHJpZ2h0OyBpKyspIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQubWV0YXMucHVzaCh0aGlzLm1ldGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuc3RyaW5nQXBwZW5kVmFsdWUgPSBmdW5jdGlvbiAodGFyZ2V0LCB2YWx1ZSkge1xuICAgICAgICB2YXIgc3RyID0gdGhpcy5hc1N0cmluZyh2YWx1ZSk7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBzdHIucGFydHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFydCA9IF9hW19pXTtcbiAgICAgICAgICAgIHRoaXMuc3RyaW5nQXBwZW5kUGFydCh0YXJnZXQsIHBhcnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuc3RyaW5nQXBwZW5kUGFydCA9IGZ1bmN0aW9uICh0YXJnZXQsIHBhcnQpIHtcbiAgICAgICAgdGFyZ2V0LnBhcnRzLnB1c2gocGFydCk7XG4gICAgICAgIHBhcnQudXNlcy5wdXNoKHRhcmdldCk7XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUucmVzb2x2ZVN0cmluZ1BhcnQgPSBmdW5jdGlvbiAoc3RyLCBmcm9tLCBsZW4pIHtcbiAgICAgICAgaWYgKGxlbiA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBmcm9tO1xuICAgICAgICBmb3IgKHZhciBpID0gZnJvbTsgaSA8IHN0ci5wYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBhcnQgPSBzdHIucGFydHNbaV07XG4gICAgICAgICAgICBpZiAobGVuID09PSBwYXJ0LnV0ZjhzaXplKSB7XG4gICAgICAgICAgICAgICAgLy8gTWF0Y2hlcyBwZXJmZWN0IVxuICAgICAgICAgICAgICAgIHJldHVybiBpICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZW4gPCBwYXJ0LnV0ZjhzaXplKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQncyBhIHBhcnQgb2YgdGhpcyBjaHVuay4gV2Ugbm93IG5lZWQgdG8gc3BsaXQgaXQgdXAuXG4gICAgICAgICAgICAgICAgdGhpcy5zcGxpdFN0cmluZyhwYXJ0LCBsZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybiBpICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxlbiAtPSBwYXJ0LnV0ZjhzaXplO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3BsaXR0aW5nIHN0cmluZyBvdXQgb2YgYm91bmRzJyk7XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuc3BsaXRTdHJpbmcgPSBmdW5jdGlvbiAocGFydCwgaWR4KSB7XG4gICAgICAgIHZhciBsZWZ0VmFsdWU7XG4gICAgICAgIHZhciByaWdodFZhbHVlO1xuICAgICAgICB2YXIgbGVmdFNpemUgPSBpZHg7XG4gICAgICAgIHZhciByaWdodFNpemUgPSBwYXJ0LnV0ZjhzaXplIC0gbGVmdFNpemU7XG4gICAgICAgIC8vIGlkeCBpcyBoZXJlIGluIFVURi04IGluZGV4LCBub3QgY29kZXBvaW50IGluZGV4LlxuICAgICAgICAvLyBUaGlzIG1lYW5zIHdlIG1pZ2h0IHRvIGFkanVzdCBmb3IgbXVsdGktYnl0ZSBjaGFyYWN0ZXJzLlxuICAgICAgICBpZiAocGFydC51dGY4c2l6ZSAhPT0gcGFydC52YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBieXRlQ291bnQgPSAwO1xuICAgICAgICAgICAgZm9yIChpZHggPSAwOyBieXRlQ291bnQgPCBsZWZ0U2l6ZTsgaWR4KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY29kZSA9IHBhcnQudmFsdWUuY29kZVBvaW50QXQoaWR4KTtcbiAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IHV0ZjhjaGFyU2l6ZShjb2RlKTtcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZSA9PT0gNClcbiAgICAgICAgICAgICAgICAgICAgaWR4Kys7IC8vIFN1cnJvZ2F0ZSBwYWlyLlxuICAgICAgICAgICAgICAgIGJ5dGVDb3VudCArPSBzaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxlZnRWYWx1ZSA9IHBhcnQudmFsdWUuc2xpY2UoMCwgaWR4KTtcbiAgICAgICAgcmlnaHRWYWx1ZSA9IHBhcnQudmFsdWUuc2xpY2UoaWR4KTtcbiAgICAgICAgdmFyIG5ld1BhcnQgPSB7XG4gICAgICAgICAgICB2YWx1ZTogcmlnaHRWYWx1ZSxcbiAgICAgICAgICAgIHV0ZjhzaXplOiByaWdodFNpemUsXG4gICAgICAgICAgICB1c2VzOiBwYXJ0LnVzZXMuc2xpY2UoKSxcbiAgICAgICAgICAgIHN0YXJ0TWV0YTogcGFydC5zdGFydE1ldGEsXG4gICAgICAgICAgICBlbmRNZXRhOiBwYXJ0LmVuZE1ldGFcbiAgICAgICAgfTtcbiAgICAgICAgcGFydC52YWx1ZSA9IGxlZnRWYWx1ZTtcbiAgICAgICAgcGFydC51dGY4c2l6ZSA9IGxlZnRTaXplO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gcGFydC51c2VzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHVzZSA9IF9hW19pXTtcbiAgICAgICAgICAgIC8vIEluc2VydCB0aGUgbmV3IHBhcnQuXG4gICAgICAgICAgICB2YXIgaWR4XzEgPSB1c2UucGFydHMuaW5kZXhPZihwYXJ0KTtcbiAgICAgICAgICAgIGlmIChpZHhfMSA9PT0gLTEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdidWc6IG1pc21hdGNoIGJldHdlZW4gc3RyaW5nIHBhcnRzIGFuZCB1c2UuJyk7XG4gICAgICAgICAgICB1c2UucGFydHMuc3BsaWNlKGlkeF8xICsgMSwgMCwgbmV3UGFydCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5zdHJpbmdBcHBlbmRTbGljZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgdmFyIHN0ciA9IHRoaXMuYXNTdHJpbmcoc291cmNlKTtcbiAgICAgICAgdmFyIGZpcnN0UGFydCA9IHRoaXMucmVzb2x2ZVN0cmluZ1BhcnQoc3RyLCAwLCBsZWZ0KTtcbiAgICAgICAgdmFyIGxhc3RQYXJ0ID0gdGhpcy5yZXNvbHZlU3RyaW5nUGFydChzdHIsIGZpcnN0UGFydCwgcmlnaHQgLSBsZWZ0KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IGZpcnN0UGFydDsgaSA8IGxhc3RQYXJ0OyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gc3RyLnBhcnRzW2ldO1xuICAgICAgICAgICAgdGhpcy5zdHJpbmdBcHBlbmRQYXJ0KHRhcmdldCwgcGFydCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBNb2RlbDtcbn0oKSk7XG4vLyBUdXJucyBhIG5hdGl2ZSBKYXZhU2NyaXB0IG9iamVjdCBpbnRvIGEgVmFsdWUgd2l0aCBhIGdpdmVuIG9yaWdpbi5cbmV4cG9ydCBmdW5jdGlvbiB3cmFwKGRhdGEsIG1ldGEpIHtcbiAgICByZXR1cm4geyBkYXRhOiBkYXRhLCBzdGFydE1ldGE6IG1ldGEsIGVuZE1ldGE6IG1ldGEgfTtcbn1cbi8vIENvbnZlcnRzIGEgVmFsdWUgaW50byBhIG5hdGl2ZSBKYXZhU2NyaXB0IHR5cGUuXG5leHBvcnQgZnVuY3Rpb24gdW53cmFwKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZS5kYXRhICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmV0dXJuIHZhbHVlLmRhdGE7XG4gICAgdmFyIHJlc3VsdDtcbiAgICB2YXIgY29udGVudCA9IHZhbHVlLmNvbnRlbnQ7XG4gICAgc3dpdGNoIChjb250ZW50LnR5cGUpIHtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIHJlc3VsdCA9IGNvbnRlbnQucGFydHMubWFwKGZ1bmN0aW9uIChwYXJ0KSB7IHJldHVybiBwYXJ0LnZhbHVlOyB9KS5qb2luKCcnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdhcnJheSc6XG4gICAgICAgICAgICByZXN1bHQgPSBjb250ZW50LmVsZW1lbnRzLm1hcChmdW5jdGlvbiAodmFsKSB7IHJldHVybiB1bndyYXAodmFsKTsgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnb2JqZWN0Jzoge1xuICAgICAgICAgICAgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmVudHJpZXMoY29udGVudC5maWVsZHMpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBfYiA9IF9hW19pXSwga2V5ID0gX2JbMF0sIHZhbCA9IF9iWzFdO1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdW53cmFwKHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFsdWUuZGF0YSA9IHJlc3VsdDtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gUmV0dXJucyB0aGUgdHlwZSBvZiBhIFZhbHVlLlxuZXhwb3J0IGZ1bmN0aW9uIGdldFR5cGUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUuY29udGVudClcbiAgICAgICAgcmV0dXJuIHZhbHVlLmNvbnRlbnQudHlwZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZS5kYXRhKSlcbiAgICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgaWYgKHZhbHVlLmRhdGEgPT09IG51bGwpXG4gICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZS5kYXRhO1xufVxuLy8gVXBkYXRlcyB0aGUgYHJpZ2h0YCB2YWx1ZSBzdWNoIHRoYXQgaXQgcmV1c2VzIGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgYGxlZnRgIHZhbHVlLlxuZXhwb3J0IGZ1bmN0aW9uIHJlYmFzZVZhbHVlKGxlZnQsIHJpZ2h0KSB7XG4gICAgdmFyIGxlZnRUeXBlID0gZ2V0VHlwZShsZWZ0KTtcbiAgICB2YXIgcmlnaHRUeXBlID0gZ2V0VHlwZShyaWdodCk7XG4gICAgaWYgKGxlZnRUeXBlICE9PSByaWdodFR5cGUpXG4gICAgICAgIHJldHVybiByaWdodDtcbiAgICB2YXIgbGVmdE1vZGVsID0gbmV3IE1vZGVsKGxlZnQuZW5kTWV0YSk7XG4gICAgdmFyIHJpZ2h0TW9kZWwgPSBuZXcgTW9kZWwocmlnaHQuZW5kTWV0YSk7XG4gICAgc3dpdGNoIChsZWZ0VHlwZSkge1xuICAgICAgICBjYXNlICdvYmplY3QnOiB7XG4gICAgICAgICAgICB2YXIgbGVmdE9iaiA9IGxlZnRNb2RlbC5hc09iamVjdChsZWZ0KTtcbiAgICAgICAgICAgIHZhciByaWdodE9iaiA9IHJpZ2h0TW9kZWwuYXNPYmplY3QocmlnaHQpO1xuICAgICAgICAgICAgLy8gTnVtYmVyIG9mIGZpZWxkcyB3aGljaCBhcmUgaWRlbnRpY2FsIGluIGxlZnQgYW5kIHJpZ2h0LlxuICAgICAgICAgICAgdmFyIGlkZW50aWNhbEZpZWxkQ291bnQgPSAwO1xuICAgICAgICAgICAgdmFyIGxlZnRGaWVsZENvdW50ID0gT2JqZWN0LmtleXMobGVmdE9iai5maWVsZHMpLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciByaWdodEZpZWxkQ291bnQgPSBPYmplY3Qua2V5cyhyaWdodE9iai5maWVsZHMpLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3QuZW50cmllcyhyaWdodE9iai5maWVsZHMpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBfYiA9IF9hW19pXSwga2V5ID0gX2JbMF0sIHJpZ2h0VmFsID0gX2JbMV07XG4gICAgICAgICAgICAgICAgdmFyIGxlZnRWYWwgPSBsZWZ0T2JqLmZpZWxkc1trZXldO1xuICAgICAgICAgICAgICAgIGlmIChsZWZ0VmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0T2JqLmZpZWxkc1trZXldID0gcmViYXNlVmFsdWUobGVmdFZhbCwgcmlnaHRWYWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmlnaHRPYmouZmllbGRzW2tleV0gPT09IGxlZnRWYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWNhbEZpZWxkQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpc0lkZW50aWNhbCA9IGxlZnRGaWVsZENvdW50ID09PSByaWdodEZpZWxkQ291bnQgJiYgbGVmdEZpZWxkQ291bnQgPT09IGlkZW50aWNhbEZpZWxkQ291bnQ7XG4gICAgICAgICAgICByZXR1cm4gaXNJZGVudGljYWwgPyBsZWZ0IDogcmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnYXJyYXknOiB7XG4gICAgICAgICAgICB2YXIgbGVmdEFyciA9IGxlZnRNb2RlbC5hc0FycmF5KGxlZnQpO1xuICAgICAgICAgICAgdmFyIHJpZ2h0QXJyID0gcmlnaHRNb2RlbC5hc0FycmF5KHJpZ2h0KTtcbiAgICAgICAgICAgIGlmIChsZWZ0QXJyLmVsZW1lbnRzLmxlbmd0aCAhPT0gcmlnaHRBcnIuZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbnVtUmViYXNlZCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJpZ2h0QXJyLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmlnaHRBcnIuZWxlbWVudHNbaV0gPSByZWJhc2VWYWx1ZShsZWZ0QXJyLmVsZW1lbnRzW2ldLCByaWdodEFyci5lbGVtZW50c1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0QXJyLmVsZW1lbnRzW2ldICE9PSBsZWZ0QXJyLmVsZW1lbnRzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIG51bVJlYmFzZWQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVtUmViYXNlZCA9PT0gMCA/IGxlZnQgOiByaWdodDtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdudWxsJzpcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIGNhc2UgJ251bWJlcic6IHtcbiAgICAgICAgICAgIGlmICh1bndyYXAobGVmdCkgPT09IHVud3JhcChyaWdodCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdzdHJpbmcnOiB7XG4gICAgICAgICAgICB2YXIgbGVmdFJhdyA9IHVud3JhcChsZWZ0KTtcbiAgICAgICAgICAgIHZhciByaWdodFJhdyA9IHVud3JhcChyaWdodCk7XG4gICAgICAgICAgICBpZiAobGVmdFJhdyA9PT0gcmlnaHRSYXcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmlnaHRNb2RlbC5jb3B5U3RyaW5nKG51bGwpO1xuICAgICAgICAgICAgdmFyIHByZWZpeCA9IGNvbW1vblByZWZpeChsZWZ0UmF3LCByaWdodFJhdyk7XG4gICAgICAgICAgICB2YXIgc3VmZml4ID0gY29tbW9uU3VmZml4KGxlZnRSYXcsIHJpZ2h0UmF3LCBwcmVmaXgpO1xuICAgICAgICAgICAgdmFyIHJpZ2h0TGVuID0gdXRmOHN0cmluZ1NpemUocmlnaHRSYXcpO1xuICAgICAgICAgICAgdmFyIGxlZnRMZW4gPSB1dGY4c3RyaW5nU2l6ZShsZWZ0UmF3KTtcbiAgICAgICAgICAgIGlmICgwIDwgcHJlZml4KSB7XG4gICAgICAgICAgICAgICAgcmlnaHRNb2RlbC5zdHJpbmdBcHBlbmRTbGljZShyZXN1bHQsIGxlZnQsIDAsIHByZWZpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJlZml4IDwgcmlnaHRMZW4gLSBzdWZmaXgpIHtcbiAgICAgICAgICAgICAgICByaWdodE1vZGVsLnN0cmluZ0FwcGVuZFNsaWNlKHJlc3VsdCwgcmlnaHQsIHByZWZpeCwgcmlnaHRMZW4gLSBzdWZmaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlZnRMZW4gLSBzdWZmaXggPCBsZWZ0TGVuKSB7XG4gICAgICAgICAgICAgICAgcmlnaHRNb2RlbC5zdHJpbmdBcHBlbmRTbGljZShyZXN1bHQsIGxlZnQsIGxlZnRMZW4gLSBzdWZmaXgsIGxlZnRMZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhbHVlID0gcmlnaHRNb2RlbC5maW5hbGl6ZShyZXN1bHQpO1xuICAgICAgICAgICAgaWYgKHVud3JhcCh2YWx1ZSkgIT09IHJpZ2h0UmF3KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW5jb3JyZWN0IHN0cmluZyByZWJhc2UnKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmlnaHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gYXBwbHlQYXRjaChsZWZ0LCBwYXRjaCwgc3RhcnRNZXRhKSB7XG4gICAgdmFyIG1vZGVsID0gbmV3IE1vZGVsKHN0YXJ0TWV0YSk7XG4gICAgdmFyIHBhdGNoZXIgPSBuZXcgUGF0Y2hlcihtb2RlbCwgbGVmdCwgcGF0Y2gpO1xuICAgIHJldHVybiBwYXRjaGVyLnByb2Nlc3MoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluY3JlbWVudGFsLXBhdGNoZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/mendoza/lib/esm/incremental-patcher.js\n"));

/***/ }),

/***/ "./node_modules/mendoza/lib/esm/index.js":
/*!***********************************************!*\
  !*** ./node_modules/mendoza/lib/esm/index.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"applyPatch\": function() { return /* reexport safe */ _simple_patcher__WEBPACK_IMPORTED_MODULE_1__.applyPatch; },\n/* harmony export */   \"incremental\": function() { return /* reexport module object */ _incremental_patcher__WEBPACK_IMPORTED_MODULE_0__; }\n/* harmony export */ });\n/* harmony import */ var _incremental_patcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./incremental-patcher */ \"./node_modules/mendoza/lib/esm/incremental-patcher.js\");\n/* harmony import */ var _simple_patcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./simple-patcher */ \"./node_modules/mendoza/lib/esm/simple-patcher.js\");\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBdUQ7QUFDZjtBQUNNO0FBQzlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tZW5kb3phL2xpYi9lc20vaW5kZXguanM/NGE1NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBpbmNyZW1lbnRhbF8xIGZyb20gJy4vaW5jcmVtZW50YWwtcGF0Y2hlcic7XG5leHBvcnQgeyBpbmNyZW1lbnRhbF8xIGFzIGluY3JlbWVudGFsIH07XG5leHBvcnQgeyBhcHBseVBhdGNoIH0gZnJvbSAnLi9zaW1wbGUtcGF0Y2hlcic7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mendoza/lib/esm/index.js\n"));

/***/ }),

/***/ "./node_modules/mendoza/lib/esm/internal-patcher.js":
/*!**********************************************************!*\
  !*** ./node_modules/mendoza/lib/esm/internal-patcher.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Patcher\": function() { return /* binding */ Patcher; }\n/* harmony export */ });\nvar OPS = [\n    'Value',\n    'Copy',\n    'Blank',\n    'ReturnIntoArray',\n    'ReturnIntoObject',\n    'ReturnIntoObjectSameKey',\n    'PushField',\n    'PushElement',\n    'PushParent',\n    'Pop',\n    'PushFieldCopy',\n    'PushFieldBlank',\n    'PushElementCopy',\n    'PushElementBlank',\n    'ReturnIntoObjectPop',\n    'ReturnIntoObjectSameKeyPop',\n    'ReturnIntoArrayPop',\n    'ObjectSetFieldValue',\n    'ObjectCopyField',\n    'ObjectDeleteField',\n    'ArrayAppendValue',\n    'ArrayAppendSlice',\n    'StringAppendString',\n    'StringAppendSlice'\n];\nvar Patcher = /** @class */ (function () {\n    function Patcher(model, root, patch) {\n        this.i = 0;\n        this.inputStack = [];\n        this.outputStack = [];\n        this.model = model;\n        this.root = root;\n        this.patch = patch;\n    }\n    Patcher.prototype.read = function () {\n        return this.patch[this.i++];\n    };\n    Patcher.prototype.process = function () {\n        this.inputStack.push({ value: this.root });\n        this.outputStack.push({ value: this.root });\n        for (; this.i < this.patch.length;) {\n            var opcode = this.read();\n            var op = OPS[opcode];\n            if (!op)\n                throw new Error(\"Unknown opcode: \" + opcode);\n            var processor = \"process\" + op;\n            this[processor].apply(this);\n        }\n        var entry = this.outputStack.pop();\n        return this.finalizeOutput(entry);\n    };\n    Patcher.prototype.inputEntry = function () {\n        return this.inputStack[this.inputStack.length - 1];\n    };\n    Patcher.prototype.inputKey = function (entry, idx) {\n        if (!entry.keys) {\n            entry.keys = this.model.objectGetKeys(entry.value).sort();\n        }\n        return entry.keys[idx];\n    };\n    Patcher.prototype.outputEntry = function () {\n        return this.outputStack[this.outputStack.length - 1];\n    };\n    Patcher.prototype.outputArray = function () {\n        var entry = this.outputEntry();\n        if (!entry.writeValue) {\n            entry.writeValue = this.model.copyArray(entry.value);\n        }\n        return entry.writeValue;\n    };\n    Patcher.prototype.outputObject = function () {\n        var entry = this.outputEntry();\n        if (!entry.writeValue) {\n            entry.writeValue = this.model.copyObject(entry.value);\n        }\n        return entry.writeValue;\n    };\n    Patcher.prototype.outputString = function () {\n        var entry = this.outputEntry();\n        if (!entry.writeValue) {\n            entry.writeValue = this.model.copyString(entry.value);\n        }\n        return entry.writeValue;\n    };\n    Patcher.prototype.finalizeOutput = function (entry) {\n        if (entry.writeValue) {\n            return this.model.finalize(entry.writeValue);\n        }\n        else {\n            return entry.value;\n        }\n    };\n    // Processors:\n    Patcher.prototype.processValue = function () {\n        var value = this.model.wrap(this.read());\n        this.outputStack.push({ value: value });\n    };\n    Patcher.prototype.processCopy = function () {\n        var input = this.inputEntry();\n        this.outputStack.push({ value: input.value });\n    };\n    Patcher.prototype.processBlank = function () {\n        this.outputStack.push({ value: null });\n    };\n    Patcher.prototype.processReturnIntoArray = function () {\n        var entry = this.outputStack.pop();\n        var result = this.finalizeOutput(entry);\n        var arr = this.outputArray();\n        this.model.arrayAppendValue(arr, result);\n    };\n    Patcher.prototype.processReturnIntoObject = function () {\n        var key = this.read();\n        var entry = this.outputStack.pop();\n        var result = this.finalizeOutput(entry);\n        result = this.model.markChanged(result);\n        var obj = this.outputObject();\n        this.model.objectSetField(obj, key, result);\n    };\n    Patcher.prototype.processReturnIntoObjectSameKey = function () {\n        var input = this.inputEntry();\n        var entry = this.outputStack.pop();\n        var result = this.finalizeOutput(entry);\n        var obj = this.outputObject();\n        this.model.objectSetField(obj, input.key, result);\n    };\n    Patcher.prototype.processPushField = function () {\n        var idx = this.read();\n        var entry = this.inputEntry();\n        var key = this.inputKey(entry, idx);\n        var value = this.model.objectGetField(entry.value, key);\n        this.inputStack.push({ value: value, key: key });\n    };\n    Patcher.prototype.processPushElement = function () {\n        var idx = this.read();\n        var entry = this.inputEntry();\n        var value = this.model.arrayGetElement(entry.value, idx);\n        this.inputStack.push({ value: value });\n    };\n    Patcher.prototype.processPop = function () {\n        this.inputStack.pop();\n    };\n    Patcher.prototype.processPushFieldCopy = function () {\n        this.processPushField();\n        this.processCopy();\n    };\n    Patcher.prototype.processPushFieldBlank = function () {\n        this.processPushField();\n        this.processBlank();\n    };\n    Patcher.prototype.processPushElementCopy = function () {\n        this.processPushElement();\n        this.processCopy();\n    };\n    Patcher.prototype.processPushElementBlank = function () {\n        this.processPushElement();\n        this.processBlank();\n    };\n    Patcher.prototype.processReturnIntoObjectPop = function () {\n        this.processReturnIntoObject();\n        this.processPop();\n    };\n    Patcher.prototype.processReturnIntoObjectSameKeyPop = function () {\n        this.processReturnIntoObjectSameKey();\n        this.processPop();\n    };\n    Patcher.prototype.processReturnIntoArrayPop = function () {\n        this.processReturnIntoArray();\n        this.processPop();\n    };\n    Patcher.prototype.processObjectSetFieldValue = function () {\n        this.processValue();\n        this.processReturnIntoObject();\n    };\n    Patcher.prototype.processObjectCopyField = function () {\n        this.processPushField();\n        this.processCopy();\n        this.processReturnIntoObjectSameKey();\n        this.processPop();\n    };\n    Patcher.prototype.processObjectDeleteField = function () {\n        var idx = this.read();\n        var entry = this.inputEntry();\n        var key = this.inputKey(entry, idx);\n        var obj = this.outputObject();\n        this.model.objectDeleteField(obj, key);\n    };\n    Patcher.prototype.processArrayAppendValue = function () {\n        var value = this.model.wrap(this.read());\n        var arr = this.outputArray();\n        this.model.arrayAppendValue(arr, value);\n    };\n    Patcher.prototype.processArrayAppendSlice = function () {\n        var left = this.read();\n        var right = this.read();\n        var str = this.outputArray();\n        var val = this.inputEntry().value;\n        this.model.arrayAppendSlice(str, val, left, right);\n    };\n    Patcher.prototype.processStringAppendString = function () {\n        var value = this.model.wrap(this.read());\n        var str = this.outputString();\n        this.model.stringAppendValue(str, value);\n    };\n    Patcher.prototype.processStringAppendSlice = function () {\n        var left = this.read();\n        var right = this.read();\n        var str = this.outputString();\n        var val = this.inputEntry().value;\n        this.model.stringAppendSlice(str, val, left, right);\n    };\n    return Patcher;\n}());\n\n//# sourceMappingURL=internal-patcher.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL2ludGVybmFsLXBhdGNoZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrQkFBa0I7QUFDakQsZ0NBQWdDLGtCQUFrQjtBQUNsRCxlQUFlLDJCQUEyQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msb0JBQW9CO0FBQ3BEO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isd0JBQXdCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsY0FBYztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNrQjtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL2ludGVybmFsLXBhdGNoZXIuanM/YjYyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgT1BTID0gW1xuICAgICdWYWx1ZScsXG4gICAgJ0NvcHknLFxuICAgICdCbGFuaycsXG4gICAgJ1JldHVybkludG9BcnJheScsXG4gICAgJ1JldHVybkludG9PYmplY3QnLFxuICAgICdSZXR1cm5JbnRvT2JqZWN0U2FtZUtleScsXG4gICAgJ1B1c2hGaWVsZCcsXG4gICAgJ1B1c2hFbGVtZW50JyxcbiAgICAnUHVzaFBhcmVudCcsXG4gICAgJ1BvcCcsXG4gICAgJ1B1c2hGaWVsZENvcHknLFxuICAgICdQdXNoRmllbGRCbGFuaycsXG4gICAgJ1B1c2hFbGVtZW50Q29weScsXG4gICAgJ1B1c2hFbGVtZW50QmxhbmsnLFxuICAgICdSZXR1cm5JbnRvT2JqZWN0UG9wJyxcbiAgICAnUmV0dXJuSW50b09iamVjdFNhbWVLZXlQb3AnLFxuICAgICdSZXR1cm5JbnRvQXJyYXlQb3AnLFxuICAgICdPYmplY3RTZXRGaWVsZFZhbHVlJyxcbiAgICAnT2JqZWN0Q29weUZpZWxkJyxcbiAgICAnT2JqZWN0RGVsZXRlRmllbGQnLFxuICAgICdBcnJheUFwcGVuZFZhbHVlJyxcbiAgICAnQXJyYXlBcHBlbmRTbGljZScsXG4gICAgJ1N0cmluZ0FwcGVuZFN0cmluZycsXG4gICAgJ1N0cmluZ0FwcGVuZFNsaWNlJ1xuXTtcbnZhciBQYXRjaGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhdGNoZXIobW9kZWwsIHJvb3QsIHBhdGNoKSB7XG4gICAgICAgIHRoaXMuaSA9IDA7XG4gICAgICAgIHRoaXMuaW5wdXRTdGFjayA9IFtdO1xuICAgICAgICB0aGlzLm91dHB1dFN0YWNrID0gW107XG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICAgICAgdGhpcy5wYXRjaCA9IHBhdGNoO1xuICAgIH1cbiAgICBQYXRjaGVyLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXRjaFt0aGlzLmkrK107XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlucHV0U3RhY2sucHVzaCh7IHZhbHVlOiB0aGlzLnJvb3QgfSk7XG4gICAgICAgIHRoaXMub3V0cHV0U3RhY2sucHVzaCh7IHZhbHVlOiB0aGlzLnJvb3QgfSk7XG4gICAgICAgIGZvciAoOyB0aGlzLmkgPCB0aGlzLnBhdGNoLmxlbmd0aDspIHtcbiAgICAgICAgICAgIHZhciBvcGNvZGUgPSB0aGlzLnJlYWQoKTtcbiAgICAgICAgICAgIHZhciBvcCA9IE9QU1tvcGNvZGVdO1xuICAgICAgICAgICAgaWYgKCFvcClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9wY29kZTogXCIgKyBvcGNvZGUpO1xuICAgICAgICAgICAgdmFyIHByb2Nlc3NvciA9IFwicHJvY2Vzc1wiICsgb3A7XG4gICAgICAgICAgICB0aGlzW3Byb2Nlc3Nvcl0uYXBwbHkodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5vdXRwdXRTdGFjay5wb3AoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemVPdXRwdXQoZW50cnkpO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUuaW5wdXRFbnRyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXRTdGFja1t0aGlzLmlucHV0U3RhY2subGVuZ3RoIC0gMV07XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5pbnB1dEtleSA9IGZ1bmN0aW9uIChlbnRyeSwgaWR4KSB7XG4gICAgICAgIGlmICghZW50cnkua2V5cykge1xuICAgICAgICAgICAgZW50cnkua2V5cyA9IHRoaXMubW9kZWwub2JqZWN0R2V0S2V5cyhlbnRyeS52YWx1ZSkuc29ydCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnRyeS5rZXlzW2lkeF07XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5vdXRwdXRFbnRyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3V0cHV0U3RhY2tbdGhpcy5vdXRwdXRTdGFjay5sZW5ndGggLSAxXTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLm91dHB1dEFycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLm91dHB1dEVudHJ5KCk7XG4gICAgICAgIGlmICghZW50cnkud3JpdGVWYWx1ZSkge1xuICAgICAgICAgICAgZW50cnkud3JpdGVWYWx1ZSA9IHRoaXMubW9kZWwuY29weUFycmF5KGVudHJ5LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW50cnkud3JpdGVWYWx1ZTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLm91dHB1dE9iamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5vdXRwdXRFbnRyeSgpO1xuICAgICAgICBpZiAoIWVudHJ5LndyaXRlVmFsdWUpIHtcbiAgICAgICAgICAgIGVudHJ5LndyaXRlVmFsdWUgPSB0aGlzLm1vZGVsLmNvcHlPYmplY3QoZW50cnkudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnRyeS53cml0ZVZhbHVlO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUub3V0cHV0U3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLm91dHB1dEVudHJ5KCk7XG4gICAgICAgIGlmICghZW50cnkud3JpdGVWYWx1ZSkge1xuICAgICAgICAgICAgZW50cnkud3JpdGVWYWx1ZSA9IHRoaXMubW9kZWwuY29weVN0cmluZyhlbnRyeS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudHJ5LndyaXRlVmFsdWU7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5maW5hbGl6ZU91dHB1dCA9IGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICBpZiAoZW50cnkud3JpdGVWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuZmluYWxpemUoZW50cnkud3JpdGVWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZW50cnkudmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFByb2Nlc3NvcnM6XG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1ZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLm1vZGVsLndyYXAodGhpcy5yZWFkKCkpO1xuICAgICAgICB0aGlzLm91dHB1dFN0YWNrLnB1c2goeyB2YWx1ZTogdmFsdWUgfSk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzQ29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dEVudHJ5KCk7XG4gICAgICAgIHRoaXMub3V0cHV0U3RhY2sucHVzaCh7IHZhbHVlOiBpbnB1dC52YWx1ZSB9KTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NCbGFuayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vdXRwdXRTdGFjay5wdXNoKHsgdmFsdWU6IG51bGwgfSk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUmV0dXJuSW50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLm91dHB1dFN0YWNrLnBvcCgpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5maW5hbGl6ZU91dHB1dChlbnRyeSk7XG4gICAgICAgIHZhciBhcnIgPSB0aGlzLm91dHB1dEFycmF5KCk7XG4gICAgICAgIHRoaXMubW9kZWwuYXJyYXlBcHBlbmRWYWx1ZShhcnIsIHJlc3VsdCk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUmV0dXJuSW50b09iamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGtleSA9IHRoaXMucmVhZCgpO1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLm91dHB1dFN0YWNrLnBvcCgpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5maW5hbGl6ZU91dHB1dChlbnRyeSk7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMubW9kZWwubWFya0NoYW5nZWQocmVzdWx0KTtcbiAgICAgICAgdmFyIG9iaiA9IHRoaXMub3V0cHV0T2JqZWN0KCk7XG4gICAgICAgIHRoaXMubW9kZWwub2JqZWN0U2V0RmllbGQob2JqLCBrZXksIHJlc3VsdCk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUmV0dXJuSW50b09iamVjdFNhbWVLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXRFbnRyeSgpO1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLm91dHB1dFN0YWNrLnBvcCgpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5maW5hbGl6ZU91dHB1dChlbnRyeSk7XG4gICAgICAgIHZhciBvYmogPSB0aGlzLm91dHB1dE9iamVjdCgpO1xuICAgICAgICB0aGlzLm1vZGVsLm9iamVjdFNldEZpZWxkKG9iaiwgaW5wdXQua2V5LCByZXN1bHQpO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1B1c2hGaWVsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMucmVhZCgpO1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLmlucHV0RW50cnkoKTtcbiAgICAgICAgdmFyIGtleSA9IHRoaXMuaW5wdXRLZXkoZW50cnksIGlkeCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMubW9kZWwub2JqZWN0R2V0RmllbGQoZW50cnkudmFsdWUsIGtleSk7XG4gICAgICAgIHRoaXMuaW5wdXRTdGFjay5wdXNoKHsgdmFsdWU6IHZhbHVlLCBrZXk6IGtleSB9KTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NQdXNoRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMucmVhZCgpO1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLmlucHV0RW50cnkoKTtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5tb2RlbC5hcnJheUdldEVsZW1lbnQoZW50cnkudmFsdWUsIGlkeCk7XG4gICAgICAgIHRoaXMuaW5wdXRTdGFjay5wdXNoKHsgdmFsdWU6IHZhbHVlIH0pO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1BvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbnB1dFN0YWNrLnBvcCgpO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1B1c2hGaWVsZENvcHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc1B1c2hGaWVsZCgpO1xuICAgICAgICB0aGlzLnByb2Nlc3NDb3B5KCk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUHVzaEZpZWxkQmxhbmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc1B1c2hGaWVsZCgpO1xuICAgICAgICB0aGlzLnByb2Nlc3NCbGFuaygpO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1B1c2hFbGVtZW50Q29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzUHVzaEVsZW1lbnQoKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzQ29weSgpO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1B1c2hFbGVtZW50QmxhbmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc1B1c2hFbGVtZW50KCk7XG4gICAgICAgIHRoaXMucHJvY2Vzc0JsYW5rKCk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUmV0dXJuSW50b09iamVjdFBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzUmV0dXJuSW50b09iamVjdCgpO1xuICAgICAgICB0aGlzLnByb2Nlc3NQb3AoKTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NSZXR1cm5JbnRvT2JqZWN0U2FtZUtleVBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzUmV0dXJuSW50b09iamVjdFNhbWVLZXkoKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzUG9wKCk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUmV0dXJuSW50b0FycmF5UG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnByb2Nlc3NSZXR1cm5JbnRvQXJyYXkoKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzUG9wKCk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzT2JqZWN0U2V0RmllbGRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzVmFsdWUoKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzUmV0dXJuSW50b09iamVjdCgpO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc09iamVjdENvcHlGaWVsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzUHVzaEZpZWxkKCk7XG4gICAgICAgIHRoaXMucHJvY2Vzc0NvcHkoKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzUmV0dXJuSW50b09iamVjdFNhbWVLZXkoKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzUG9wKCk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzT2JqZWN0RGVsZXRlRmllbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpZHggPSB0aGlzLnJlYWQoKTtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5pbnB1dEVudHJ5KCk7XG4gICAgICAgIHZhciBrZXkgPSB0aGlzLmlucHV0S2V5KGVudHJ5LCBpZHgpO1xuICAgICAgICB2YXIgb2JqID0gdGhpcy5vdXRwdXRPYmplY3QoKTtcbiAgICAgICAgdGhpcy5tb2RlbC5vYmplY3REZWxldGVGaWVsZChvYmosIGtleSk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzQXJyYXlBcHBlbmRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5tb2RlbC53cmFwKHRoaXMucmVhZCgpKTtcbiAgICAgICAgdmFyIGFyciA9IHRoaXMub3V0cHV0QXJyYXkoKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hcnJheUFwcGVuZFZhbHVlKGFyciwgdmFsdWUpO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc0FycmF5QXBwZW5kU2xpY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gdGhpcy5yZWFkKCk7XG4gICAgICAgIHZhciByaWdodCA9IHRoaXMucmVhZCgpO1xuICAgICAgICB2YXIgc3RyID0gdGhpcy5vdXRwdXRBcnJheSgpO1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5pbnB1dEVudHJ5KCkudmFsdWU7XG4gICAgICAgIHRoaXMubW9kZWwuYXJyYXlBcHBlbmRTbGljZShzdHIsIHZhbCwgbGVmdCwgcmlnaHQpO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1N0cmluZ0FwcGVuZFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5tb2RlbC53cmFwKHRoaXMucmVhZCgpKTtcbiAgICAgICAgdmFyIHN0ciA9IHRoaXMub3V0cHV0U3RyaW5nKCk7XG4gICAgICAgIHRoaXMubW9kZWwuc3RyaW5nQXBwZW5kVmFsdWUoc3RyLCB2YWx1ZSk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzU3RyaW5nQXBwZW5kU2xpY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gdGhpcy5yZWFkKCk7XG4gICAgICAgIHZhciByaWdodCA9IHRoaXMucmVhZCgpO1xuICAgICAgICB2YXIgc3RyID0gdGhpcy5vdXRwdXRTdHJpbmcoKTtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuaW5wdXRFbnRyeSgpLnZhbHVlO1xuICAgICAgICB0aGlzLm1vZGVsLnN0cmluZ0FwcGVuZFNsaWNlKHN0ciwgdmFsLCBsZWZ0LCByaWdodCk7XG4gICAgfTtcbiAgICByZXR1cm4gUGF0Y2hlcjtcbn0oKSk7XG5leHBvcnQgeyBQYXRjaGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcm5hbC1wYXRjaGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/mendoza/lib/esm/internal-patcher.js\n"));

/***/ }),

/***/ "./node_modules/mendoza/lib/esm/simple-patcher.js":
/*!********************************************************!*\
  !*** ./node_modules/mendoza/lib/esm/simple-patcher.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"applyPatch\": function() { return /* binding */ applyPatch; }\n/* harmony export */ });\n/* harmony import */ var _internal_patcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal-patcher */ \"./node_modules/mendoza/lib/esm/internal-patcher.js\");\n/* harmony import */ var _utf8__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utf8 */ \"./node_modules/mendoza/lib/esm/utf8.js\");\n\n\nvar Model = {\n    wrap: function (data) {\n        return data;\n    },\n    finalize: function (b) {\n        if (Array.isArray(b)) {\n            return b;\n        }\n        else {\n            return b.data;\n        }\n    },\n    markChanged: function (value) {\n        return value;\n    },\n    objectGetKeys: function (value) {\n        return Object.keys(value);\n    },\n    objectGetField: function (value, key) {\n        return value[key];\n    },\n    arrayGetElement: function (value, idx) {\n        return value[idx];\n    },\n    copyObject: function (value) {\n        var res = {\n            type: 'object',\n            data: {}\n        };\n        if (value !== null) {\n            for (var _i = 0, _a = Object.entries(value); _i < _a.length; _i++) {\n                var _b = _a[_i], key = _b[0], val = _b[1];\n                res.data[key] = val;\n            }\n        }\n        return res;\n    },\n    copyArray: function (value) {\n        if (value === null)\n            return [];\n        return value.slice();\n    },\n    copyString: function (value) {\n        return {\n            type: 'string',\n            data: value === null ? '' : value\n        };\n    },\n    objectSetField: function (target, key, value) {\n        target.data[key] = value;\n    },\n    objectDeleteField: function (target, key) {\n        delete target.data[key];\n    },\n    arrayAppendValue: function (target, value) {\n        target.push(value);\n    },\n    arrayAppendSlice: function (target, source, left, right) {\n        target.push.apply(target, source.slice(left, right));\n    },\n    stringAppendSlice: function (target, source, left, right) {\n        var sourceString = source;\n        var leftPos = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8resolveIndex)(sourceString, left);\n        var rightPos = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8resolveIndex)(sourceString, right, leftPos);\n        target.data += sourceString.slice(leftPos, rightPos);\n    },\n    stringAppendValue: function (target, value) {\n        target.data += value;\n    }\n};\n// Applies a patch on a JavaScript object.\nfunction applyPatch(left, patch) {\n    var root = left; // No need to wrap because the representation is the same.\n    var patcher = new _internal_patcher__WEBPACK_IMPORTED_MODULE_1__.Patcher(Model, root, patch);\n    return patcher.process();\n}\n//# sourceMappingURL=simple-patcher.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL3NpbXBsZS1wYXRjaGVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE2QztBQUNIO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxnQkFBZ0I7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNCQUFzQix1REFBZ0I7QUFDdEMsdUJBQXVCLHVEQUFnQjtBQUN2QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxxQkFBcUI7QUFDckIsc0JBQXNCLHNEQUFPO0FBQzdCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL3NpbXBsZS1wYXRjaGVyLmpzPzY5YjkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGF0Y2hlciB9IGZyb20gJy4vaW50ZXJuYWwtcGF0Y2hlcic7XG5pbXBvcnQgeyB1dGY4cmVzb2x2ZUluZGV4IH0gZnJvbSAnLi91dGY4JztcbnZhciBNb2RlbCA9IHtcbiAgICB3cmFwOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoYikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYi5kYXRhO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBtYXJrQ2hhbmdlZDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIG9iamVjdEdldEtleXM6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpO1xuICAgIH0sXG4gICAgb2JqZWN0R2V0RmllbGQ6IGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVtrZXldO1xuICAgIH0sXG4gICAgYXJyYXlHZXRFbGVtZW50OiBmdW5jdGlvbiAodmFsdWUsIGlkeCkge1xuICAgICAgICByZXR1cm4gdmFsdWVbaWR4XTtcbiAgICB9LFxuICAgIGNvcHlPYmplY3Q6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzID0ge1xuICAgICAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgICAgICBkYXRhOiB7fVxuICAgICAgICB9O1xuICAgICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3QuZW50cmllcyh2YWx1ZSk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iID0gX2FbX2ldLCBrZXkgPSBfYlswXSwgdmFsID0gX2JbMV07XG4gICAgICAgICAgICAgICAgcmVzLmRhdGFba2V5XSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG4gICAgY29weUFycmF5OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICByZXR1cm4gdmFsdWUuc2xpY2UoKTtcbiAgICB9LFxuICAgIGNvcHlTdHJpbmc6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICBkYXRhOiB2YWx1ZSA9PT0gbnVsbCA/ICcnIDogdmFsdWVcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIG9iamVjdFNldEZpZWxkOiBmdW5jdGlvbiAodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIHRhcmdldC5kYXRhW2tleV0gPSB2YWx1ZTtcbiAgICB9LFxuICAgIG9iamVjdERlbGV0ZUZpZWxkOiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgZGVsZXRlIHRhcmdldC5kYXRhW2tleV07XG4gICAgfSxcbiAgICBhcnJheUFwcGVuZFZhbHVlOiBmdW5jdGlvbiAodGFyZ2V0LCB2YWx1ZSkge1xuICAgICAgICB0YXJnZXQucHVzaCh2YWx1ZSk7XG4gICAgfSxcbiAgICBhcnJheUFwcGVuZFNsaWNlOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHRhcmdldC5wdXNoLmFwcGx5KHRhcmdldCwgc291cmNlLnNsaWNlKGxlZnQsIHJpZ2h0KSk7XG4gICAgfSxcbiAgICBzdHJpbmdBcHBlbmRTbGljZTogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlLCBsZWZ0LCByaWdodCkge1xuICAgICAgICB2YXIgc291cmNlU3RyaW5nID0gc291cmNlO1xuICAgICAgICB2YXIgbGVmdFBvcyA9IHV0ZjhyZXNvbHZlSW5kZXgoc291cmNlU3RyaW5nLCBsZWZ0KTtcbiAgICAgICAgdmFyIHJpZ2h0UG9zID0gdXRmOHJlc29sdmVJbmRleChzb3VyY2VTdHJpbmcsIHJpZ2h0LCBsZWZ0UG9zKTtcbiAgICAgICAgdGFyZ2V0LmRhdGEgKz0gc291cmNlU3RyaW5nLnNsaWNlKGxlZnRQb3MsIHJpZ2h0UG9zKTtcbiAgICB9LFxuICAgIHN0cmluZ0FwcGVuZFZhbHVlOiBmdW5jdGlvbiAodGFyZ2V0LCB2YWx1ZSkge1xuICAgICAgICB0YXJnZXQuZGF0YSArPSB2YWx1ZTtcbiAgICB9XG59O1xuLy8gQXBwbGllcyBhIHBhdGNoIG9uIGEgSmF2YVNjcmlwdCBvYmplY3QuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlQYXRjaChsZWZ0LCBwYXRjaCkge1xuICAgIHZhciByb290ID0gbGVmdDsgLy8gTm8gbmVlZCB0byB3cmFwIGJlY2F1c2UgdGhlIHJlcHJlc2VudGF0aW9uIGlzIHRoZSBzYW1lLlxuICAgIHZhciBwYXRjaGVyID0gbmV3IFBhdGNoZXIoTW9kZWwsIHJvb3QsIHBhdGNoKTtcbiAgICByZXR1cm4gcGF0Y2hlci5wcm9jZXNzKCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaW1wbGUtcGF0Y2hlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mendoza/lib/esm/simple-patcher.js\n"));

/***/ }),

/***/ "./node_modules/mendoza/lib/esm/utf8.js":
/*!**********************************************!*\
  !*** ./node_modules/mendoza/lib/esm/utf8.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"commonPrefix\": function() { return /* binding */ commonPrefix; },\n/* harmony export */   \"commonSuffix\": function() { return /* binding */ commonSuffix; },\n/* harmony export */   \"utf8charSize\": function() { return /* binding */ utf8charSize; },\n/* harmony export */   \"utf8resolveIndex\": function() { return /* binding */ utf8resolveIndex; },\n/* harmony export */   \"utf8stringSize\": function() { return /* binding */ utf8stringSize; }\n/* harmony export */ });\nfunction utf8charSize(code) {\n    if (code >> 16) {\n        return 4;\n    }\n    else if (code >> 11) {\n        return 3;\n    }\n    else if (code >> 7) {\n        return 2;\n    }\n    else {\n        return 1;\n    }\n}\nfunction utf8stringSize(str) {\n    var b = 0;\n    for (var i = 0; i < str.length; i++) {\n        var code = str.codePointAt(i);\n        var size = utf8charSize(code);\n        if (size == 4)\n            i++;\n        b += size;\n    }\n    return b;\n}\n/** Converts an UTF-8 byte index into a UCS-2 index. */\nfunction utf8resolveIndex(str, idx, start) {\n    if (start === void 0) { start = 0; }\n    var byteCount = start;\n    var ucsIdx = 0;\n    for (ucsIdx = start; byteCount < idx; ucsIdx++) {\n        var code = str.codePointAt(ucsIdx);\n        var size = utf8charSize(code);\n        if (size === 4)\n            ucsIdx++; // Surrogate pair.\n        byteCount += size;\n    }\n    return ucsIdx;\n}\nfunction commonPrefix(str, str2) {\n    var len = Math.min(str.length, str2.length);\n    var b = 0;\n    for (var i = 0; i < len;) {\n        var aPoint = str.codePointAt(i);\n        var bPoint = str2.codePointAt(i);\n        if (aPoint !== bPoint)\n            return b;\n        var size = utf8charSize(aPoint);\n        b += size;\n        i += size === 4 ? 2 : 1;\n    }\n    return b;\n}\nfunction commonSuffix(str, str2, prefix) {\n    if (prefix === void 0) { prefix = 0; }\n    var len = Math.min(str.length, str2.length) - prefix;\n    var b = 0;\n    for (var i = 0; i < len;) {\n        var aPoint = str.codePointAt(str.length - 1 - i);\n        var bPoint = str2.codePointAt(str2.length - 1 - i);\n        if (aPoint !== bPoint)\n            return b;\n        var size = utf8charSize(aPoint);\n        b += size;\n        i += size === 4 ? 2 : 1;\n    }\n    return b;\n}\n//# sourceMappingURL=utf8.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL3V0ZjguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLHlCQUF5QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL3V0ZjguanM/ZWM4MCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gdXRmOGNoYXJTaXplKGNvZGUpIHtcbiAgICBpZiAoY29kZSA+PiAxNikge1xuICAgICAgICByZXR1cm4gNDtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZSA+PiAxMSkge1xuICAgICAgICByZXR1cm4gMztcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZSA+PiA3KSB7XG4gICAgICAgIHJldHVybiAyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhzdHJpbmdTaXplKHN0cikge1xuICAgIHZhciBiID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29kZSA9IHN0ci5jb2RlUG9pbnRBdChpKTtcbiAgICAgICAgdmFyIHNpemUgPSB1dGY4Y2hhclNpemUoY29kZSk7XG4gICAgICAgIGlmIChzaXplID09IDQpXG4gICAgICAgICAgICBpKys7XG4gICAgICAgIGIgKz0gc2l6ZTtcbiAgICB9XG4gICAgcmV0dXJuIGI7XG59XG4vKiogQ29udmVydHMgYW4gVVRGLTggYnl0ZSBpbmRleCBpbnRvIGEgVUNTLTIgaW5kZXguICovXG5leHBvcnQgZnVuY3Rpb24gdXRmOHJlc29sdmVJbmRleChzdHIsIGlkeCwgc3RhcnQpIHtcbiAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCkgeyBzdGFydCA9IDA7IH1cbiAgICB2YXIgYnl0ZUNvdW50ID0gc3RhcnQ7XG4gICAgdmFyIHVjc0lkeCA9IDA7XG4gICAgZm9yICh1Y3NJZHggPSBzdGFydDsgYnl0ZUNvdW50IDwgaWR4OyB1Y3NJZHgrKykge1xuICAgICAgICB2YXIgY29kZSA9IHN0ci5jb2RlUG9pbnRBdCh1Y3NJZHgpO1xuICAgICAgICB2YXIgc2l6ZSA9IHV0ZjhjaGFyU2l6ZShjb2RlKTtcbiAgICAgICAgaWYgKHNpemUgPT09IDQpXG4gICAgICAgICAgICB1Y3NJZHgrKzsgLy8gU3Vycm9nYXRlIHBhaXIuXG4gICAgICAgIGJ5dGVDb3VudCArPSBzaXplO1xuICAgIH1cbiAgICByZXR1cm4gdWNzSWR4O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbW1vblByZWZpeChzdHIsIHN0cjIpIHtcbiAgICB2YXIgbGVuID0gTWF0aC5taW4oc3RyLmxlbmd0aCwgc3RyMi5sZW5ndGgpO1xuICAgIHZhciBiID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjspIHtcbiAgICAgICAgdmFyIGFQb2ludCA9IHN0ci5jb2RlUG9pbnRBdChpKTtcbiAgICAgICAgdmFyIGJQb2ludCA9IHN0cjIuY29kZVBvaW50QXQoaSk7XG4gICAgICAgIGlmIChhUG9pbnQgIT09IGJQb2ludClcbiAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICB2YXIgc2l6ZSA9IHV0ZjhjaGFyU2l6ZShhUG9pbnQpO1xuICAgICAgICBiICs9IHNpemU7XG4gICAgICAgIGkgKz0gc2l6ZSA9PT0gNCA/IDIgOiAxO1xuICAgIH1cbiAgICByZXR1cm4gYjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb21tb25TdWZmaXgoc3RyLCBzdHIyLCBwcmVmaXgpIHtcbiAgICBpZiAocHJlZml4ID09PSB2b2lkIDApIHsgcHJlZml4ID0gMDsgfVxuICAgIHZhciBsZW4gPSBNYXRoLm1pbihzdHIubGVuZ3RoLCBzdHIyLmxlbmd0aCkgLSBwcmVmaXg7XG4gICAgdmFyIGIgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgICB2YXIgYVBvaW50ID0gc3RyLmNvZGVQb2ludEF0KHN0ci5sZW5ndGggLSAxIC0gaSk7XG4gICAgICAgIHZhciBiUG9pbnQgPSBzdHIyLmNvZGVQb2ludEF0KHN0cjIubGVuZ3RoIC0gMSAtIGkpO1xuICAgICAgICBpZiAoYVBvaW50ICE9PSBiUG9pbnQpXG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgdmFyIHNpemUgPSB1dGY4Y2hhclNpemUoYVBvaW50KTtcbiAgICAgICAgYiArPSBzaXplO1xuICAgICAgICBpICs9IHNpemUgPT09IDQgPyAyIDogMTtcbiAgICB9XG4gICAgcmV0dXJuIGI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGY4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/mendoza/lib/esm/utf8.js\n"));

/***/ }),

/***/ "./node_modules/groq-js/dist/1.umd.cjs":
/*!*********************************************!*\
  !*** ./node_modules/groq-js/dist/1.umd.cjs ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("(function(g,f){ true?f(exports):0;})(this,(function(exports){'use strict';/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}var MarkProcessor = /** @class */ (function () {\n    function MarkProcessor(string, marks, parseOptions) {\n        this.allowBoost = false;\n        this.string = string;\n        this.marks = marks;\n        this.index = 0;\n        this.parseOptions = parseOptions;\n    }\n    MarkProcessor.prototype.hasMark = function (pos) {\n        if (pos === void 0) { pos = 0; }\n        return this.index + pos < this.marks.length;\n    };\n    MarkProcessor.prototype.getMark = function (pos) {\n        if (pos === void 0) { pos = 0; }\n        return this.marks[this.index + pos];\n    };\n    MarkProcessor.prototype.shift = function () {\n        this.index += 1;\n    };\n    MarkProcessor.prototype.process = function (visitor) {\n        var mark = this.marks[this.index];\n        this.shift();\n        var func = visitor[mark.name];\n        if (!func) {\n            throw new Error(\"Unknown handler: \".concat(mark.name));\n        }\n        return func.call(visitor, this, mark);\n    };\n    MarkProcessor.prototype.processString = function () {\n        this.shift();\n        return this.processStringEnd();\n    };\n    MarkProcessor.prototype.processStringEnd = function () {\n        var prev = this.marks[this.index - 1];\n        var curr = this.marks[this.index];\n        this.shift();\n        return this.string.slice(prev.position, curr.position);\n    };\n    MarkProcessor.prototype.slice = function (len) {\n        var pos = this.marks[this.index].position;\n        return this.string.slice(pos, pos + len);\n    };\n    return MarkProcessor;\n}());var RFC3339_REGEX = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|([-+]\\d{2}:\\d{2}))$/;\nfunction parseRFC3339(str) {\n    if (RFC3339_REGEX.test(str)) {\n        return new Date(str);\n    }\n    return null;\n}\nfunction formatRFC3339(d) {\n    var year = addLeadingZero(d.getUTCFullYear(), 4);\n    var month = addLeadingZero(d.getUTCMonth() + 1, 2);\n    var day = addLeadingZero(d.getUTCDate(), 2);\n    var hour = addLeadingZero(d.getUTCHours(), 2);\n    var minute = addLeadingZero(d.getUTCMinutes(), 2);\n    var second = addLeadingZero(d.getUTCSeconds(), 2);\n    var fractionalSecond = '';\n    var millis = d.getMilliseconds();\n    if (millis != 0) {\n        fractionalSecond = \".\".concat(addLeadingZero(millis, 3));\n    }\n    return \"\".concat(year, \"-\").concat(month, \"-\").concat(day, \"T\").concat(hour, \":\").concat(minute, \":\").concat(second).concat(fractionalSecond, \"Z\");\n}\nfunction addLeadingZero(num, targetLength) {\n    var str = num.toString();\n    while (str.length < targetLength) {\n        str = \"0\".concat(str);\n    }\n    return str;\n}function escapeRegExp(string) {\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\nfunction pathRegExp(pattern) {\n    var re = [];\n    for (var _i = 0, _a = pattern.split('.'); _i < _a.length; _i++) {\n        var part = _a[_i];\n        if (part === '*') {\n            re.push('[^.]+');\n        }\n        else if (part === '**') {\n            re.push('.*');\n        }\n        else {\n            re.push(escapeRegExp(part));\n        }\n    }\n    return new RegExp(\"^\".concat(re.join('.'), \"$\"));\n}\nvar Path = /** @class */ (function () {\n    function Path(pattern) {\n        this.pattern = pattern;\n        this.patternRe = pathRegExp(pattern);\n    }\n    Path.prototype.matches = function (str) {\n        return this.patternRe.test(str);\n    };\n    Path.prototype.toJSON = function () {\n        return this.pattern;\n    };\n    return Path;\n}());var StreamValue = /** @class */ (function () {\n    function StreamValue(generator) {\n        this.type = 'stream';\n        this.generator = generator;\n        this.ticker = null;\n        this.isDone = false;\n        this.data = [];\n    }\n    // eslint-disable-next-line class-methods-use-this\n    StreamValue.prototype.isArray = function () {\n        return true;\n    };\n    StreamValue.prototype.get = function () {\n        var e_1, _a;\n        return __awaiter(this, void 0, void 0, function () {\n            var result, _b, _c, value, _d, _e, e_1_1;\n            return __generator(this, function (_f) {\n                switch (_f.label) {\n                    case 0:\n                        result = [];\n                        _f.label = 1;\n                    case 1:\n                        _f.trys.push([1, 7, 8, 13]);\n                        _b = __asyncValues(this);\n                        _f.label = 2;\n                    case 2: return [4 /*yield*/, _b.next()];\n                    case 3:\n                        if (!(_c = _f.sent(), !_c.done)) return [3 /*break*/, 6];\n                        value = _c.value;\n                        _e = (_d = result).push;\n                        return [4 /*yield*/, value.get()];\n                    case 4:\n                        _e.apply(_d, [_f.sent()]);\n                        _f.label = 5;\n                    case 5: return [3 /*break*/, 2];\n                    case 6: return [3 /*break*/, 13];\n                    case 7:\n                        e_1_1 = _f.sent();\n                        e_1 = { error: e_1_1 };\n                        return [3 /*break*/, 13];\n                    case 8:\n                        _f.trys.push([8, , 11, 12]);\n                        if (!(_c && !_c.done && (_a = _b[\"return\"]))) return [3 /*break*/, 10];\n                        return [4 /*yield*/, _a.call(_b)];\n                    case 9:\n                        _f.sent();\n                        _f.label = 10;\n                    case 10: return [3 /*break*/, 12];\n                    case 11:\n                        if (e_1) throw e_1.error;\n                        return [7 /*endfinally*/];\n                    case 12: return [7 /*endfinally*/];\n                    case 13: return [2 /*return*/, result];\n                }\n            });\n        });\n    };\n    StreamValue.prototype[Symbol.asyncIterator] = function () {\n        return __asyncGenerator(this, arguments, function _a() {\n            var i;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        i = 0;\n                        _b.label = 1;\n                    case 1:\n                        _b.label = 2;\n                    case 2:\n                        if (!(i < this.data.length)) return [3 /*break*/, 6];\n                        return [4 /*yield*/, __await(this.data[i])];\n                    case 3: return [4 /*yield*/, _b.sent()];\n                    case 4:\n                        _b.sent();\n                        _b.label = 5;\n                    case 5:\n                        i++;\n                        return [3 /*break*/, 2];\n                    case 6:\n                        if (!this.isDone) return [3 /*break*/, 8];\n                        return [4 /*yield*/, __await(void 0)];\n                    case 7: return [2 /*return*/, _b.sent()];\n                    case 8: return [4 /*yield*/, __await(this._nextTick())];\n                    case 9:\n                        _b.sent();\n                        return [3 /*break*/, 1];\n                    case 10: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    StreamValue.prototype._nextTick = function () {\n        var _this = this;\n        if (this.ticker) {\n            return this.ticker;\n        }\n        var currentResolver;\n        var setupTicker = function () {\n            _this.ticker = new Promise(function (resolve) {\n                currentResolver = resolve;\n            });\n        };\n        var tick = function () {\n            currentResolver();\n            setupTicker();\n        };\n        var fetch = function () { return __awaiter(_this, void 0, void 0, function () {\n            var _a, _b, value, e_2_1;\n            var e_2, _c;\n            return __generator(this, function (_d) {\n                switch (_d.label) {\n                    case 0:\n                        _d.trys.push([0, 5, 6, 11]);\n                        _a = __asyncValues(this.generator());\n                        _d.label = 1;\n                    case 1: return [4 /*yield*/, _a.next()];\n                    case 2:\n                        if (!(_b = _d.sent(), !_b.done)) return [3 /*break*/, 4];\n                        value = _b.value;\n                        this.data.push(value);\n                        tick();\n                        _d.label = 3;\n                    case 3: return [3 /*break*/, 1];\n                    case 4: return [3 /*break*/, 11];\n                    case 5:\n                        e_2_1 = _d.sent();\n                        e_2 = { error: e_2_1 };\n                        return [3 /*break*/, 11];\n                    case 6:\n                        _d.trys.push([6, , 9, 10]);\n                        if (!(_b && !_b.done && (_c = _a[\"return\"]))) return [3 /*break*/, 8];\n                        return [4 /*yield*/, _c.call(_a)];\n                    case 7:\n                        _d.sent();\n                        _d.label = 8;\n                    case 8: return [3 /*break*/, 10];\n                    case 9:\n                        if (e_2) throw e_2.error;\n                        return [7 /*endfinally*/];\n                    case 10: return [7 /*endfinally*/];\n                    case 11:\n                        this.isDone = true;\n                        tick();\n                        return [2 /*return*/];\n                }\n            });\n        }); };\n        setupTicker();\n        fetch();\n        return this.ticker;\n    };\n    return StreamValue;\n}());var StaticValue = /** @class */ (function () {\n    function StaticValue(data, type) {\n        this.data = data;\n        this.type = type;\n    }\n    StaticValue.prototype.isArray = function () {\n        return this.type === 'array';\n    };\n    // eslint-disable-next-line require-await\n    StaticValue.prototype.get = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, this.data];\n            });\n        });\n    };\n    StaticValue.prototype[Symbol.asyncIterator] = function () {\n        if (Array.isArray(this.data)) {\n            return (function (data) {\n                var _i, data_1, element;\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            _i = 0, data_1 = data;\n                            _a.label = 1;\n                        case 1:\n                            if (!(_i < data_1.length)) return [3 /*break*/, 4];\n                            element = data_1[_i];\n                            return [4 /*yield*/, fromJS(element)];\n                        case 2:\n                            _a.sent();\n                            _a.label = 3;\n                        case 3:\n                            _i++;\n                            return [3 /*break*/, 1];\n                        case 4: return [2 /*return*/];\n                    }\n                });\n            })(this.data);\n        }\n        throw new Error(\"Cannot iterate over: \".concat(this.type));\n    };\n    return StaticValue;\n}());\nvar NULL_VALUE = new StaticValue(null, 'null');\nvar TRUE_VALUE = new StaticValue(true, 'boolean');\nvar FALSE_VALUE = new StaticValue(false, 'boolean');\nvar DateTime = /** @class */ (function () {\n    function DateTime(date) {\n        this.date = date;\n    }\n    DateTime.parseToValue = function (str) {\n        var date = parseRFC3339(str);\n        if (date) {\n            return new StaticValue(new DateTime(date), 'datetime');\n        }\n        return NULL_VALUE;\n    };\n    DateTime.prototype.equals = function (other) {\n        return this.date.getTime() == other.date.getTime();\n    };\n    DateTime.prototype.add = function (secs) {\n        var copy = new Date(this.date.getTime());\n        copy.setTime(copy.getTime() + secs * 1000);\n        return new DateTime(copy);\n    };\n    DateTime.prototype.difference = function (other) {\n        return (this.date.getTime() - other.date.getTime()) / 1000;\n    };\n    DateTime.prototype.compareTo = function (other) {\n        return this.date.getTime() - other.date.getTime();\n    };\n    DateTime.prototype.toString = function () {\n        return formatRFC3339(this.date);\n    };\n    DateTime.prototype.toJSON = function () {\n        return this.toString();\n    };\n    return DateTime;\n}());\nfunction fromNumber(num) {\n    if (Number.isFinite(num)) {\n        return new StaticValue(num, 'number');\n    }\n    return NULL_VALUE;\n}\nfunction fromString(str) {\n    return new StaticValue(str, 'string');\n}\nfunction fromDateTime(dt) {\n    return new StaticValue(dt, 'datetime');\n}\nfunction fromPath(path) {\n    return new StaticValue(path, 'path');\n}\nfunction isIterator(obj) {\n    return obj && typeof obj.next === 'function';\n}\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction fromJS(val) {\n    if (isIterator(val)) {\n        return new StreamValue(function () {\n            return __asyncGenerator(this, arguments, function () {\n                var val_1, val_1_1, value, e_1_1;\n                var e_1, _a;\n                return __generator(this, function (_b) {\n                    switch (_b.label) {\n                        case 0:\n                            _b.trys.push([0, 7, 8, 13]);\n                            val_1 = __asyncValues(val);\n                            _b.label = 1;\n                        case 1: return [4 /*yield*/, __await(val_1.next())];\n                        case 2:\n                            if (!(val_1_1 = _b.sent(), !val_1_1.done)) return [3 /*break*/, 6];\n                            value = val_1_1.value;\n                            return [4 /*yield*/, __await(fromJS(value))];\n                        case 3: return [4 /*yield*/, _b.sent()];\n                        case 4:\n                            _b.sent();\n                            _b.label = 5;\n                        case 5: return [3 /*break*/, 1];\n                        case 6: return [3 /*break*/, 13];\n                        case 7:\n                            e_1_1 = _b.sent();\n                            e_1 = { error: e_1_1 };\n                            return [3 /*break*/, 13];\n                        case 8:\n                            _b.trys.push([8, , 11, 12]);\n                            if (!(val_1_1 && !val_1_1.done && (_a = val_1[\"return\"]))) return [3 /*break*/, 10];\n                            return [4 /*yield*/, __await(_a.call(val_1))];\n                        case 9:\n                            _b.sent();\n                            _b.label = 10;\n                        case 10: return [3 /*break*/, 12];\n                        case 11:\n                            if (e_1) throw e_1.error;\n                            return [7 /*endfinally*/];\n                        case 12: return [7 /*endfinally*/];\n                        case 13: return [2 /*return*/];\n                    }\n                });\n            });\n        });\n    }\n    else if (val === null || val === undefined) {\n        return NULL_VALUE;\n    }\n    return new StaticValue(val, getType(val));\n}\n/**\n * Returns the type of the value.\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction getType(data) {\n    if (data === null || typeof data === 'undefined') {\n        return 'null';\n    }\n    if (Array.isArray(data)) {\n        return 'array';\n    }\n    if (data instanceof Path) {\n        return 'path';\n    }\n    if (data instanceof DateTime) {\n        return 'datetime';\n    }\n    return typeof data;\n}var TYPE_ORDER = {\n    datetime: 1,\n    number: 2,\n    string: 3,\n    boolean: 4\n};\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction partialCompare(a, b) {\n    var aType = getType(a);\n    var bType = getType(b);\n    if (aType !== bType) {\n        return null;\n    }\n    switch (aType) {\n        case 'number':\n        case 'boolean':\n            return a - b;\n        case 'string':\n            if (a < b)\n                return -1;\n            if (a > b)\n                return 1;\n            return 0;\n        case 'datetime':\n            return a.compareTo(b);\n        default:\n            return null;\n    }\n}\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction totalCompare(a, b) {\n    var aType = getType(a);\n    var bType = getType(b);\n    var aTypeOrder = TYPE_ORDER[aType] || 100;\n    var bTypeOrder = TYPE_ORDER[bType] || 100;\n    if (aTypeOrder !== bTypeOrder) {\n        return aTypeOrder - bTypeOrder;\n    }\n    var result = partialCompare(a, b);\n    if (result === null) {\n        result = 0;\n    }\n    return result;\n}var CHARS = /([^!@#$%^&*(),\\\\/?\";:{}|[\\]+<>\\s-])+/g;\nvar CHARS_WITH_WILDCARD = /([^!@#$%^&(),\\\\/?\";:{}|[\\]+<>\\s-])+/g;\nvar EDGE_CHARS = /(\\b\\.+|\\.+\\b)/g;\nvar MAX_TERM_LENGTH = 1024;\nfunction matchText(tokens, patterns) {\n    if (tokens.length === 0 || patterns.length === 0) {\n        return false;\n    }\n    return patterns.every(function (pattern) { return pattern(tokens); });\n}\nfunction matchTokenize(text) {\n    return text.replace(EDGE_CHARS, '').match(CHARS) || [];\n}\nfunction matchAnalyzePattern(text) {\n    var termsRe = matchPatternRegex(text);\n    return termsRe.map(function (re) { return function (tokens) { return tokens.some(function (token) { return re.test(token); }); }; });\n}\nfunction matchPatternRegex(text) {\n    var terms = text.replace(EDGE_CHARS, '').match(CHARS_WITH_WILDCARD) || [];\n    return terms.map(function (term) { return new RegExp(\"^\".concat(term.slice(0, MAX_TERM_LENGTH).replace(/\\*/g, '.*'), \"$\"), 'i'); });\n}\nfunction gatherText(value, cb) {\n    var value_1, value_1_1;\n    var e_1, _a;\n    return __awaiter(this, void 0, void 0, function () {\n        var success, part, e_1_1;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    if (value.type === 'string') {\n                        cb(value.data);\n                        return [2 /*return*/, true];\n                    }\n                    if (!value.isArray()) return [3 /*break*/, 13];\n                    success = true;\n                    _b.label = 1;\n                case 1:\n                    _b.trys.push([1, 6, 7, 12]);\n                    value_1 = __asyncValues(value);\n                    _b.label = 2;\n                case 2: return [4 /*yield*/, value_1.next()];\n                case 3:\n                    if (!(value_1_1 = _b.sent(), !value_1_1.done)) return [3 /*break*/, 5];\n                    part = value_1_1.value;\n                    if (part.type === 'string') {\n                        cb(part.data);\n                    }\n                    else {\n                        success = false;\n                    }\n                    _b.label = 4;\n                case 4: return [3 /*break*/, 2];\n                case 5: return [3 /*break*/, 12];\n                case 6:\n                    e_1_1 = _b.sent();\n                    e_1 = { error: e_1_1 };\n                    return [3 /*break*/, 12];\n                case 7:\n                    _b.trys.push([7, , 10, 11]);\n                    if (!(value_1_1 && !value_1_1.done && (_a = value_1[\"return\"]))) return [3 /*break*/, 9];\n                    return [4 /*yield*/, _a.call(value_1)];\n                case 8:\n                    _b.sent();\n                    _b.label = 9;\n                case 9: return [3 /*break*/, 11];\n                case 10:\n                    if (e_1) throw e_1.error;\n                    return [7 /*endfinally*/];\n                case 11: return [7 /*endfinally*/];\n                case 12: return [2 /*return*/, success];\n                case 13: return [2 /*return*/, false];\n            }\n        });\n    });\n}// BM25 similarity constants\nvar BM25k = 1.2;\nfunction evaluateScore(node, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var innerScore, boost, _a, leftScore, rightScore, leftScore, rightScore, res;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    if (node.type === 'OpCall' && node.op === 'match') {\n                        return [2 /*return*/, evaluateMatchScore(node.left, node.right, scope, execute)];\n                    }\n                    if (!(node.type === 'FuncCall' && node.name === 'boost')) return [3 /*break*/, 3];\n                    return [4 /*yield*/, evaluateScore(node.args[0], scope, execute)];\n                case 1:\n                    innerScore = _b.sent();\n                    return [4 /*yield*/, execute(node.args[1], scope)];\n                case 2:\n                    boost = _b.sent();\n                    if (boost.type === 'number' && innerScore > 0) {\n                        return [2 /*return*/, innerScore + boost.data];\n                    }\n                    return [2 /*return*/, 0];\n                case 3:\n                    _a = node.type;\n                    switch (_a) {\n                        case 'Or': return [3 /*break*/, 4];\n                        case 'And': return [3 /*break*/, 7];\n                    }\n                    return [3 /*break*/, 10];\n                case 4: return [4 /*yield*/, evaluateScore(node.left, scope, execute)];\n                case 5:\n                    leftScore = _b.sent();\n                    return [4 /*yield*/, evaluateScore(node.right, scope, execute)];\n                case 6:\n                    rightScore = _b.sent();\n                    return [2 /*return*/, leftScore + rightScore];\n                case 7: return [4 /*yield*/, evaluateScore(node.left, scope, execute)];\n                case 8:\n                    leftScore = _b.sent();\n                    return [4 /*yield*/, evaluateScore(node.right, scope, execute)];\n                case 9:\n                    rightScore = _b.sent();\n                    if (leftScore === 0 || rightScore === 0)\n                        return [2 /*return*/, 0];\n                    return [2 /*return*/, leftScore + rightScore];\n                case 10: return [4 /*yield*/, execute(node, scope)];\n                case 11:\n                    res = _b.sent();\n                    return [2 /*return*/, res.type === 'boolean' && res.data === true ? 1 : 0];\n            }\n        });\n    });\n}\nfunction evaluateMatchScore(left, right, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var text, pattern, tokens, terms, didSucceed, score, _loop_1, _i, terms_1, re;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(left, scope)];\n                case 1:\n                    text = _a.sent();\n                    return [4 /*yield*/, execute(right, scope)];\n                case 2:\n                    pattern = _a.sent();\n                    tokens = [];\n                    terms = [];\n                    return [4 /*yield*/, gatherText(text, function (part) {\n                            tokens = tokens.concat(matchTokenize(part));\n                        })];\n                case 3:\n                    _a.sent();\n                    return [4 /*yield*/, gatherText(pattern, function (part) {\n                            terms = terms.concat(matchPatternRegex(part));\n                        })];\n                case 4:\n                    didSucceed = _a.sent();\n                    if (!didSucceed) {\n                        return [2 /*return*/, 0];\n                    }\n                    if (tokens.length === 0 || terms.length === 0) {\n                        return [2 /*return*/, 0];\n                    }\n                    score = 0;\n                    _loop_1 = function (re) {\n                        var freq = tokens.reduce(function (c, token) { return c + (re.test(token) ? 1 : 0); }, 0);\n                        score += (freq * (BM25k + 1)) / (freq + BM25k);\n                    };\n                    for (_i = 0, terms_1 = terms; _i < terms_1.length; _i++) {\n                        re = terms_1[_i];\n                        _loop_1(re);\n                    }\n                    return [2 /*return*/, score];\n            }\n        });\n    });\n}function portableTextContent(value) {\n    return __awaiter(this, void 0, void 0, function () {\n        var texts;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (!(value.type === 'object')) return [3 /*break*/, 1];\n                    return [2 /*return*/, blockText(value.data)];\n                case 1:\n                    if (!value.isArray()) return [3 /*break*/, 3];\n                    return [4 /*yield*/, arrayText(value)];\n                case 2:\n                    texts = _a.sent();\n                    if (texts.length > 0) {\n                        return [2 /*return*/, texts.join('\\n\\n')];\n                    }\n                    _a.label = 3;\n                case 3: return [2 /*return*/, null];\n            }\n        });\n    });\n}\nfunction arrayText(value, result) {\n    var value_1, value_1_1;\n    var e_1, _a;\n    if (result === void 0) { result = []; }\n    return __awaiter(this, void 0, void 0, function () {\n        var block, text, e_1_1;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    _b.trys.push([0, 7, 8, 13]);\n                    value_1 = __asyncValues(value);\n                    _b.label = 1;\n                case 1: return [4 /*yield*/, value_1.next()];\n                case 2:\n                    if (!(value_1_1 = _b.sent(), !value_1_1.done)) return [3 /*break*/, 6];\n                    block = value_1_1.value;\n                    if (!(block.type === 'object')) return [3 /*break*/, 3];\n                    text = blockText(block.data);\n                    if (text !== null)\n                        result.push(text);\n                    return [3 /*break*/, 5];\n                case 3:\n                    if (!block.isArray()) return [3 /*break*/, 5];\n                    return [4 /*yield*/, arrayText(block, result)];\n                case 4:\n                    _b.sent();\n                    _b.label = 5;\n                case 5: return [3 /*break*/, 1];\n                case 6: return [3 /*break*/, 13];\n                case 7:\n                    e_1_1 = _b.sent();\n                    e_1 = { error: e_1_1 };\n                    return [3 /*break*/, 13];\n                case 8:\n                    _b.trys.push([8, , 11, 12]);\n                    if (!(value_1_1 && !value_1_1.done && (_a = value_1[\"return\"]))) return [3 /*break*/, 10];\n                    return [4 /*yield*/, _a.call(value_1)];\n                case 9:\n                    _b.sent();\n                    _b.label = 10;\n                case 10: return [3 /*break*/, 12];\n                case 11:\n                    if (e_1) throw e_1.error;\n                    return [7 /*endfinally*/];\n                case 12: return [7 /*endfinally*/];\n                case 13: return [2 /*return*/, result];\n            }\n        });\n    });\n}\nfunction blockText(obj) {\n    if (typeof obj._type !== 'string')\n        return null;\n    var children = obj.children;\n    if (!Array.isArray(children))\n        return null;\n    var result = '';\n    for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {\n        var child = children_1[_i];\n        if (child &&\n            typeof child === 'object' &&\n            typeof child._type === 'string' &&\n            child._type === 'span' &&\n            typeof child.text === 'string') {\n            result += child.text;\n        }\n    }\n    return result;\n}function hasReference(value, pathSet) {\n    switch (getType(value)) {\n        case 'array':\n            for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {\n                var v = value_1[_i];\n                if (hasReference(v, pathSet)) {\n                    return true;\n                }\n            }\n            break;\n        case 'object':\n            if (value._ref) {\n                return pathSet.has(value._ref);\n            }\n            for (var _a = 0, _b = Object.values(value); _a < _b.length; _a++) {\n                var v = _b[_a];\n                if (hasReference(v, pathSet)) {\n                    return true;\n                }\n            }\n            break;\n    }\n    return false;\n}\nfunction countUTF8(str) {\n    var count = 0;\n    for (var i = 0; i < str.length; i++) {\n        var code = str.charCodeAt(i);\n        if (code >= 0xd800 && code <= 0xdbff) {\n            // High surrogate. Don't count this.\n            // By only counting the low surrogate we will correctly\n            // count the number of UTF-8 code points.\n            continue;\n        }\n        count++;\n    }\n    return count;\n}\nvar global = {};\nglobal.anywhere = function anywhere() {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            throw new Error('not implemented');\n        });\n    });\n};\nglobal.anywhere.arity = 1;\nglobal.coalesce = function coalesce(args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var _i, args_1, arg, value;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _i = 0, args_1 = args;\n                    _a.label = 1;\n                case 1:\n                    if (!(_i < args_1.length)) return [3 /*break*/, 4];\n                    arg = args_1[_i];\n                    return [4 /*yield*/, execute(arg, scope)];\n                case 2:\n                    value = _a.sent();\n                    if (value.type !== 'null') {\n                        return [2 /*return*/, value];\n                    }\n                    _a.label = 3;\n                case 3:\n                    _i++;\n                    return [3 /*break*/, 1];\n                case 4: return [2 /*return*/, NULL_VALUE];\n            }\n        });\n    });\n};\nglobal.count = function count(args, scope, execute) {\n    var e_1, _a;\n    return __awaiter(this, void 0, void 0, function () {\n        var inner, num, inner_1, inner_1_1, e_1_1;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    inner = _b.sent();\n                    if (!inner.isArray()) {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    num = 0;\n                    _b.label = 2;\n                case 2:\n                    _b.trys.push([2, 7, 8, 13]);\n                    inner_1 = __asyncValues(inner);\n                    _b.label = 3;\n                case 3: return [4 /*yield*/, inner_1.next()];\n                case 4:\n                    if (!(inner_1_1 = _b.sent(), !inner_1_1.done)) return [3 /*break*/, 6];\n                    inner_1_1.value;\n                    num++;\n                    _b.label = 5;\n                case 5: return [3 /*break*/, 3];\n                case 6: return [3 /*break*/, 13];\n                case 7:\n                    e_1_1 = _b.sent();\n                    e_1 = { error: e_1_1 };\n                    return [3 /*break*/, 13];\n                case 8:\n                    _b.trys.push([8, , 11, 12]);\n                    if (!(inner_1_1 && !inner_1_1.done && (_a = inner_1[\"return\"]))) return [3 /*break*/, 10];\n                    return [4 /*yield*/, _a.call(inner_1)];\n                case 9:\n                    _b.sent();\n                    _b.label = 10;\n                case 10: return [3 /*break*/, 12];\n                case 11:\n                    if (e_1) throw e_1.error;\n                    return [7 /*endfinally*/];\n                case 12: return [7 /*endfinally*/];\n                case 13: return [2 /*return*/, fromNumber(num)];\n            }\n        });\n    });\n};\nglobal.count.arity = 1;\nglobal.dateTime = function dateTime(args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var val;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    val = _a.sent();\n                    if (val.type === 'datetime') {\n                        return [2 /*return*/, val];\n                    }\n                    if (val.type !== 'string') {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    return [2 /*return*/, DateTime.parseToValue(val.data)];\n            }\n        });\n    });\n};\nglobal.dateTime.arity = 1;\nglobal.defined = function defined(args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var inner;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    inner = _a.sent();\n                    return [2 /*return*/, inner.type === 'null' ? FALSE_VALUE : TRUE_VALUE];\n            }\n        });\n    });\n};\nglobal.defined.arity = 1;\n// eslint-disable-next-line require-await\nglobal.identity = function identity(args, scope) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            return [2 /*return*/, fromString(scope.context.identity)];\n        });\n    });\n};\nglobal.identity.arity = 0;\nglobal.length = function length(args, scope, execute) {\n    var e_2, _a;\n    return __awaiter(this, void 0, void 0, function () {\n        var inner, num, inner_2, inner_2_1, e_2_1;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    inner = _b.sent();\n                    if (inner.type === 'string') {\n                        return [2 /*return*/, fromNumber(countUTF8(inner.data))];\n                    }\n                    if (!inner.isArray()) return [3 /*break*/, 14];\n                    num = 0;\n                    _b.label = 2;\n                case 2:\n                    _b.trys.push([2, 7, 8, 13]);\n                    inner_2 = __asyncValues(inner);\n                    _b.label = 3;\n                case 3: return [4 /*yield*/, inner_2.next()];\n                case 4:\n                    if (!(inner_2_1 = _b.sent(), !inner_2_1.done)) return [3 /*break*/, 6];\n                    inner_2_1.value;\n                    num++;\n                    _b.label = 5;\n                case 5: return [3 /*break*/, 3];\n                case 6: return [3 /*break*/, 13];\n                case 7:\n                    e_2_1 = _b.sent();\n                    e_2 = { error: e_2_1 };\n                    return [3 /*break*/, 13];\n                case 8:\n                    _b.trys.push([8, , 11, 12]);\n                    if (!(inner_2_1 && !inner_2_1.done && (_a = inner_2[\"return\"]))) return [3 /*break*/, 10];\n                    return [4 /*yield*/, _a.call(inner_2)];\n                case 9:\n                    _b.sent();\n                    _b.label = 10;\n                case 10: return [3 /*break*/, 12];\n                case 11:\n                    if (e_2) throw e_2.error;\n                    return [7 /*endfinally*/];\n                case 12: return [7 /*endfinally*/];\n                case 13: return [2 /*return*/, fromNumber(num)];\n                case 14: return [2 /*return*/, NULL_VALUE];\n            }\n        });\n    });\n};\nglobal.length.arity = 1;\nglobal.path = function path(args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var inner;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    inner = _a.sent();\n                    if (inner.type !== 'string') {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    return [2 /*return*/, fromPath(new Path(inner.data))];\n            }\n        });\n    });\n};\nglobal.path.arity = 1;\nglobal.string = function string(args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var value;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    value = _a.sent();\n                    switch (value.type) {\n                        case 'number':\n                        case 'string':\n                        case 'boolean':\n                        case 'datetime':\n                            return [2 /*return*/, fromString(\"\".concat(value.data))];\n                        default:\n                            return [2 /*return*/, NULL_VALUE];\n                    }\n                    return [2 /*return*/];\n            }\n        });\n    });\n};\nglobal.string.arity = 1;\nglobal.references = function references(args, scope, execute) {\n    var e_3, _a;\n    return __awaiter(this, void 0, void 0, function () {\n        var pathSet, _i, args_2, arg, path, path_1, path_1_1, elem, e_3_1, scopeValue;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    pathSet = new Set();\n                    _i = 0, args_2 = args;\n                    _b.label = 1;\n                case 1:\n                    if (!(_i < args_2.length)) return [3 /*break*/, 16];\n                    arg = args_2[_i];\n                    return [4 /*yield*/, execute(arg, scope)];\n                case 2:\n                    path = _b.sent();\n                    if (!(path.type === 'string')) return [3 /*break*/, 3];\n                    pathSet.add(path.data);\n                    return [3 /*break*/, 15];\n                case 3:\n                    if (!path.isArray()) return [3 /*break*/, 15];\n                    _b.label = 4;\n                case 4:\n                    _b.trys.push([4, 9, 10, 15]);\n                    path_1 = (e_3 = void 0, __asyncValues(path));\n                    _b.label = 5;\n                case 5: return [4 /*yield*/, path_1.next()];\n                case 6:\n                    if (!(path_1_1 = _b.sent(), !path_1_1.done)) return [3 /*break*/, 8];\n                    elem = path_1_1.value;\n                    if (elem.type === 'string') {\n                        pathSet.add(elem.data);\n                    }\n                    _b.label = 7;\n                case 7: return [3 /*break*/, 5];\n                case 8: return [3 /*break*/, 15];\n                case 9:\n                    e_3_1 = _b.sent();\n                    e_3 = { error: e_3_1 };\n                    return [3 /*break*/, 15];\n                case 10:\n                    _b.trys.push([10, , 13, 14]);\n                    if (!(path_1_1 && !path_1_1.done && (_a = path_1[\"return\"]))) return [3 /*break*/, 12];\n                    return [4 /*yield*/, _a.call(path_1)];\n                case 11:\n                    _b.sent();\n                    _b.label = 12;\n                case 12: return [3 /*break*/, 14];\n                case 13:\n                    if (e_3) throw e_3.error;\n                    return [7 /*endfinally*/];\n                case 14: return [7 /*endfinally*/];\n                case 15:\n                    _i++;\n                    return [3 /*break*/, 1];\n                case 16:\n                    if (pathSet.size === 0) {\n                        return [2 /*return*/, FALSE_VALUE];\n                    }\n                    return [4 /*yield*/, scope.value.get()];\n                case 17:\n                    scopeValue = _b.sent();\n                    return [2 /*return*/, hasReference(scopeValue, pathSet) ? TRUE_VALUE : FALSE_VALUE];\n            }\n        });\n    });\n};\nglobal.references.arity = function (c) { return c >= 1; };\nglobal.round = function round(args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var value, num, prec, precValue;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    value = _a.sent();\n                    if (value.type !== 'number') {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    num = value.data;\n                    prec = 0;\n                    if (!(args.length === 2)) return [3 /*break*/, 3];\n                    return [4 /*yield*/, execute(args[1], scope)];\n                case 2:\n                    precValue = _a.sent();\n                    if (precValue.type !== 'number' || precValue.data < 0 || !Number.isInteger(precValue.data)) {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    prec = precValue.data;\n                    _a.label = 3;\n                case 3:\n                    if (prec === 0) {\n                        if (num < 0) {\n                            // JavaScript's round() function will always rounds towards positive infinity (-3.5 -> -3).\n                            // The behavior we're interested in is to \"round half away from zero\".\n                            return [2 /*return*/, fromNumber(-Math.round(-num))];\n                        }\n                        return [2 /*return*/, fromNumber(Math.round(num))];\n                    }\n                    return [2 /*return*/, fromNumber(Number(num.toFixed(prec)))];\n            }\n        });\n    });\n};\nglobal.round.arity = function (count) { return count >= 1 && count <= 2; };\n// eslint-disable-next-line require-await\nglobal.now = function now(args, scope) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            return [2 /*return*/, fromString(scope.context.timestamp.toISOString())];\n        });\n    });\n};\nglobal.now.arity = 0;\n// eslint-disable-next-line require-await\nglobal.boost = function boost() {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            // This should be handled by the scoring function.\n            throw new Error('unexpected boost call');\n        });\n    });\n};\nglobal.boost.arity = 2;\nvar string = {};\nstring.lower = function (args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var value;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    value = _a.sent();\n                    if (value.type !== 'string') {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    return [2 /*return*/, fromString(value.data.toLowerCase())];\n            }\n        });\n    });\n};\nstring.lower.arity = 1;\nstring.upper = function (args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var value;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    value = _a.sent();\n                    if (value.type !== 'string') {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    return [2 /*return*/, fromString(value.data.toUpperCase())];\n            }\n        });\n    });\n};\nstring.upper.arity = 1;\nglobal.lower = string.lower;\nglobal.upper = string.upper;\nvar pt = {};\npt.text = function (args, scope, execute) {\n    return __awaiter(this, void 0, void 0, function () {\n        var value, text;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, execute(args[0], scope)];\n                case 1:\n                    value = _a.sent();\n                    return [4 /*yield*/, portableTextContent(value)];\n                case 2:\n                    text = _a.sent();\n                    if (text === null) {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    return [2 /*return*/, fromString(text)];\n            }\n        });\n    });\n};\npt.text.arity = 1;\nvar sanity = {};\n// eslint-disable-next-line require-await\nsanity.projectId = function (args, scope) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            if (scope.context.sanity) {\n                return [2 /*return*/, fromString(scope.context.sanity.projectId)];\n            }\n            return [2 /*return*/, NULL_VALUE];\n        });\n    });\n};\n// eslint-disable-next-line require-await\nsanity.dataset = function (args, scope) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            if (scope.context.sanity) {\n                return [2 /*return*/, fromString(scope.context.sanity.dataset)];\n            }\n            return [2 /*return*/, NULL_VALUE];\n        });\n    });\n};\nvar pipeFunctions = {};\npipeFunctions.order = function order(base, args, scope, execute) {\n    var base_1, base_1_1;\n    var e_4, _a;\n    return __awaiter(this, void 0, void 0, function () {\n        var mappers, directions, n, _i, args_3, mapper, direction, aux, idx, value, newScope, tuple, i, result, _b, _c, e_4_1;\n        return __generator(this, function (_d) {\n            switch (_d.label) {\n                case 0: \n                // eslint-disable-next-line max-len\n                // This is a workaround for https://github.com/rpetrich/babel-plugin-transform-async-to-promises/issues/59\n                return [4 /*yield*/, true];\n                case 1:\n                    // eslint-disable-next-line max-len\n                    // This is a workaround for https://github.com/rpetrich/babel-plugin-transform-async-to-promises/issues/59\n                    _d.sent();\n                    if (!base.isArray()) {\n                        return [2 /*return*/, NULL_VALUE];\n                    }\n                    mappers = [];\n                    directions = [];\n                    n = 0;\n                    for (_i = 0, args_3 = args; _i < args_3.length; _i++) {\n                        mapper = args_3[_i];\n                        direction = 'asc';\n                        if (mapper.type === 'Desc') {\n                            direction = 'desc';\n                            mapper = mapper.base;\n                        }\n                        else if (mapper.type === 'Asc') {\n                            mapper = mapper.base;\n                        }\n                        mappers.push(mapper);\n                        directions.push(direction);\n                        n++;\n                    }\n                    aux = [];\n                    idx = 0;\n                    _d.label = 2;\n                case 2:\n                    _d.trys.push([2, 13, 14, 19]);\n                    base_1 = __asyncValues(base);\n                    _d.label = 3;\n                case 3: return [4 /*yield*/, base_1.next()];\n                case 4:\n                    if (!(base_1_1 = _d.sent(), !base_1_1.done)) return [3 /*break*/, 12];\n                    value = base_1_1.value;\n                    newScope = scope.createNested(value);\n                    return [4 /*yield*/, value.get()];\n                case 5:\n                    tuple = [_d.sent(), idx];\n                    i = 0;\n                    _d.label = 6;\n                case 6:\n                    if (!(i < n)) return [3 /*break*/, 10];\n                    return [4 /*yield*/, execute(mappers[i], newScope)];\n                case 7:\n                    result = _d.sent();\n                    _c = (_b = tuple).push;\n                    return [4 /*yield*/, result.get()];\n                case 8:\n                    _c.apply(_b, [_d.sent()]);\n                    _d.label = 9;\n                case 9:\n                    i++;\n                    return [3 /*break*/, 6];\n                case 10:\n                    aux.push(tuple);\n                    idx++;\n                    _d.label = 11;\n                case 11: return [3 /*break*/, 3];\n                case 12: return [3 /*break*/, 19];\n                case 13:\n                    e_4_1 = _d.sent();\n                    e_4 = { error: e_4_1 };\n                    return [3 /*break*/, 19];\n                case 14:\n                    _d.trys.push([14, , 17, 18]);\n                    if (!(base_1_1 && !base_1_1.done && (_a = base_1[\"return\"]))) return [3 /*break*/, 16];\n                    return [4 /*yield*/, _a.call(base_1)];\n                case 15:\n                    _d.sent();\n                    _d.label = 16;\n                case 16: return [3 /*break*/, 18];\n                case 17:\n                    if (e_4) throw e_4.error;\n                    return [7 /*endfinally*/];\n                case 18: return [7 /*endfinally*/];\n                case 19:\n                    aux.sort(function (aTuple, bTuple) {\n                        for (var i = 0; i < n; i++) {\n                            var c = totalCompare(aTuple[i + 2], bTuple[i + 2]);\n                            if (directions[i] === 'desc') {\n                                c = -c;\n                            }\n                            if (c !== 0) {\n                                return c;\n                            }\n                        }\n                        // Fallback to sorting on the original index for stable sorting.\n                        return aTuple[1] - bTuple[1];\n                    });\n                    return [2 /*return*/, fromJS(aux.map(function (v) { return v[0]; }))];\n            }\n        });\n    });\n};\npipeFunctions.order.arity = function (count) { return count >= 1; };\n// eslint-disable-next-line require-await\npipeFunctions.score = function score(base, args, scope, execute) {\n    var base_2, base_2_1;\n    var e_5, _a;\n    return __awaiter(this, void 0, void 0, function () {\n        var unknown, scored, value, _b, _c, newScope, valueScore, _i, args_4, arg, _d, newObject, e_5_1;\n        return __generator(this, function (_e) {\n            switch (_e.label) {\n                case 0:\n                    if (!base.isArray())\n                        return [2 /*return*/, NULL_VALUE\n                            // Anything that isn't an object should be sorted first.\n                        ];\n                    unknown = [];\n                    scored = [];\n                    _e.label = 1;\n                case 1:\n                    _e.trys.push([1, 12, 13, 18]);\n                    base_2 = __asyncValues(base);\n                    _e.label = 2;\n                case 2: return [4 /*yield*/, base_2.next()];\n                case 3:\n                    if (!(base_2_1 = _e.sent(), !base_2_1.done)) return [3 /*break*/, 11];\n                    value = base_2_1.value;\n                    if (!(value.type !== 'object')) return [3 /*break*/, 5];\n                    _c = (_b = unknown).push;\n                    return [4 /*yield*/, value.get()];\n                case 4:\n                    _c.apply(_b, [_e.sent()]);\n                    return [3 /*break*/, 10];\n                case 5:\n                    newScope = scope.createNested(value);\n                    valueScore = typeof value.data._score === 'number' ? value.data._score : 0;\n                    _i = 0, args_4 = args;\n                    _e.label = 6;\n                case 6:\n                    if (!(_i < args_4.length)) return [3 /*break*/, 9];\n                    arg = args_4[_i];\n                    _d = valueScore;\n                    return [4 /*yield*/, evaluateScore(arg, newScope, execute)];\n                case 7:\n                    valueScore = _d + _e.sent();\n                    _e.label = 8;\n                case 8:\n                    _i++;\n                    return [3 /*break*/, 6];\n                case 9:\n                    newObject = Object.assign({}, value.data, { _score: valueScore });\n                    scored.push(newObject);\n                    _e.label = 10;\n                case 10: return [3 /*break*/, 2];\n                case 11: return [3 /*break*/, 18];\n                case 12:\n                    e_5_1 = _e.sent();\n                    e_5 = { error: e_5_1 };\n                    return [3 /*break*/, 18];\n                case 13:\n                    _e.trys.push([13, , 16, 17]);\n                    if (!(base_2_1 && !base_2_1.done && (_a = base_2[\"return\"]))) return [3 /*break*/, 15];\n                    return [4 /*yield*/, _a.call(base_2)];\n                case 14:\n                    _e.sent();\n                    _e.label = 15;\n                case 15: return [3 /*break*/, 17];\n                case 16:\n                    if (e_5) throw e_5.error;\n                    return [7 /*endfinally*/];\n                case 17: return [7 /*endfinally*/];\n                case 18:\n                    scored.sort(function (a, b) { return b._score - a._score; });\n                    return [2 /*return*/, fromJS(scored)];\n            }\n        });\n    });\n};\npipeFunctions.score.arity = function (count) { return count >= 1; };\nvar delta = {};\ndelta.operation = function (args, scope) {\n    return __awaiter(this, void 0, void 0, function () {\n        var hasBefore, hasAfter;\n        return __generator(this, function (_a) {\n            hasBefore = scope.context.before !== null;\n            hasAfter = scope.context.after !== null;\n            if (hasBefore && hasAfter) {\n                return [2 /*return*/, fromString('update')];\n            }\n            if (hasAfter) {\n                return [2 /*return*/, fromString('create')];\n            }\n            if (hasBefore) {\n                return [2 /*return*/, fromString('delete')];\n            }\n            return [2 /*return*/, NULL_VALUE];\n        });\n    });\n};\ndelta.changedAny = function () {\n    throw new Error('not implemented');\n};\ndelta.changedAny.arity = 1;\ndelta.changedAny.mode = 'delta';\ndelta.changedOnly = function () {\n    throw new Error('not implemented');\n};\ndelta.changedOnly.arity = 1;\ndelta.changedOnly.mode = 'delta';\nvar diff = {};\ndiff.changedAny = function () {\n    throw new Error('not implemented');\n};\ndiff.changedAny.arity = 3;\ndiff.changedOnly = function () {\n    throw new Error('not implemented');\n};\ndiff.changedOnly.arity = 3;\nvar namespaces = {\n    global: global,\n    string: string,\n    pt: pt,\n    delta: delta,\n    diff: diff,\n    sanity: sanity\n};const WS = /^([\\t\\n\\v\\f\\r \\u0085\\u00A0]|(\\/\\/[^\\n]*\\n))+/;\nconst NUM = /^\\d+/;\nconst IDENT = /^[a-zA-Z_][a-zA-Z_0-9]*/;\n\n// Precedence levels for binary operators:\nconst PREC_PAIR = 1;\nconst PREC_OR = 2;\nconst PREC_AND = 3;\nconst PREC_COMP = 4;\nconst PREC_ORDER = 4;\nconst PREC_ADD = 6;\nconst PREC_SUB = 6;\nconst PREC_MUL = 7;\nconst PREC_DIV = 7;\nconst PREC_MOD = 7;\nconst PREC_POW = 8;\n\n// Precedence levels for prefix operators:\nconst PREC_POS = 10;\nconst PREC_NOT = 10;\nconst PREC_NEG = 8;\n\nfunction parse$1(str) {\n  let pos = 0;\n  pos = skipWS(str, pos);\n  let result = parseExpr(str, pos, 0);\n  if (result.type === 'error') return result\n  pos = skipWS(str, result.position);\n  if (pos !== str.length) {\n    if (result.failPosition) {\n      pos = result.failPosition - 1;\n    }\n    return {type: 'error', position: pos}\n  }\n  delete result.position;\n  delete result.failPosition;\n  return result\n}\n\nfunction parseExpr(str, pos, level) {\n  // In this function we parse precedence \"manually\" by having two variables:\n  //\n  // `level` is the minimum precedence level we want to parse at. If this is\n  // e.g. 7 then this function will not parse `3 + 4` (since addition is at 6),\n  // but instead just return `1` and leave ` + 5` remaining. We use this so that\n  // while handling the RHS of the multiplication in `1 + 2 * 3 + 4` we only parse `3`.\n  //\n  // `lhsLevel` is the precedence level of the currently parsed expression on\n  // the left-hand side. This is mainly used to handle non-associcativeness.\n\n  // This means that you'll see code like:\n  // - `if (level > PREC_XXX) break`: Operator is at this precedence level.\n  // - `if (lhsLevel < PREC_XXX) break`: Operator is left-associative.\n  // - `if (lhsLevel <= PREC_XXX) break`: Operator is right/non-associative.\n  // - `parseExpr(str, pos, PREC_XXX + 1)`: Operator is left/non-assoicate.\n  // - `parseExpr(str, pos, PREC_XXX)`: Operator is right-assoicate.\n\n  let startPos = pos;\n  let token = str[pos];\n  let marks;\n\n  switch (token) {\n    case '+': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_POS);\n      if (rhs.type === 'error') return rhs\n      marks = [{name: 'pos', position: startPos}].concat(rhs.marks);\n      pos = rhs.position;\n      break\n    }\n    case '-': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NEG);\n      if (rhs.type === 'error') return rhs\n      marks = [{name: 'neg', position: startPos}].concat(rhs.marks);\n      pos = rhs.position;\n      break\n    }\n    case '(': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), 0);\n      if (rhs.type === 'error') return rhs\n      pos = skipWS(str, rhs.position);\n      switch (str[pos]) {\n        case ',': {\n          // Tuples\n          marks = [{name: 'tuple', position: startPos}].concat(rhs.marks);\n          pos = skipWS(str, pos + 1);\n          while (true) {\n            rhs = parseExpr(str, pos, 0);\n            if (rhs.type === 'error') return rhs\n            pos = skipWS(str, rhs.position);\n            if (str[pos] !== ',') break\n            pos = skipWS(str, pos + 1);\n          }\n          if (str[pos] !== ')') return {type: 'error', position: pos}\n          pos++;\n          marks.push({name: 'tuple_end', position: pos});\n          break\n        }\n        case ')': {\n          pos++;\n          marks = [{name: 'group', position: startPos}].concat(rhs.marks);\n          break\n        }\n        default:\n          return {type: 'error', position: pos}\n      }\n      break\n    }\n    case '!': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NOT);\n      if (rhs.type === 'error') return rhs\n      marks = [{name: 'not', position: startPos}].concat(rhs.marks);\n      pos = rhs.position;\n      break\n    }\n    case '{': {\n      let result = parseObject(str, pos);\n      if (result.type === 'error') return result\n      marks = result.marks;\n      pos = result.position;\n      break\n    }\n    case '[':\n      marks = [{name: 'array', position: pos}];\n      pos = skipWS(str, pos + 1);\n\n      if (str[pos] !== ']') {\n        while (true) {\n          if (str.slice(pos, pos + 3) === '...') {\n            marks.push({name: 'array_splat', position: pos});\n            pos = skipWS(str, pos + 3);\n          }\n\n          let res = parseExpr(str, pos, 0);\n          if (res.type === 'error') return res\n          marks = marks.concat(res.marks);\n          pos = res.position;\n          pos = skipWS(str, pos);\n          if (str[pos] !== ',') break\n          pos = skipWS(str, pos + 1);\n          if (str[pos] === ']') break\n        }\n      }\n\n      if (str[pos] === ']') {\n        pos++;\n        marks.push({name: 'array_end', position: pos});\n      } else {\n        return {type: 'error', position: pos}\n      }\n\n      break\n    case \"'\":\n    case '\"': {\n      let result = parseString(str, pos);\n      if (result.type === 'error') return result\n      marks = result.marks;\n      pos = result.position;\n      break\n    }\n    case '^': {\n      pos++;\n      marks = [];\n      while (str[pos] === '.' && str[pos + 1] === '^') {\n        marks.push({name: 'dblparent', position: startPos});\n        pos += 2;\n      }\n      marks.push({name: 'parent', position: startPos});\n      break\n    }\n    case '@':\n      marks = [{name: 'this', position: startPos}];\n      pos++;\n      break\n    case '*':\n      marks = [{name: 'everything', position: startPos}];\n      pos++;\n      break\n    case '$': {\n      let identLen = parseRegex(str, pos + 1, IDENT);\n      if (identLen) {\n        pos += 1 + identLen;\n        marks = [\n          {name: 'param', position: startPos},\n          {name: 'ident', position: startPos + 1},\n          {name: 'ident_end', position: pos},\n        ];\n      }\n      break\n    }\n    default: {\n      let numLen = parseRegex(str, pos, NUM);\n      if (numLen) {\n        pos += numLen;\n        let name = 'integer';\n\n        if (str[pos] === '.') {\n          let fracLen = parseRegex(str, pos + 1, NUM);\n          if (fracLen) {\n            name = 'float';\n            pos += 1 + fracLen;\n          }\n        }\n\n        if (str[pos] === 'e' || str[pos] === 'E') {\n          name = 'sci';\n          pos++;\n          if (str[pos] === '+' || str[pos] === '-') {\n            pos++;\n          }\n          let expLen = parseRegex(str, pos, NUM);\n          if (!expLen) return {type: 'error', position: pos}\n          pos += expLen;\n        }\n\n        marks = [\n          {name, position: startPos},\n          {name: name + '_end', position: pos},\n        ];\n\n        break\n      }\n\n      let identLen = parseRegex(str, pos, IDENT);\n      if (identLen) {\n        pos += identLen;\n        switch (str[pos]) {\n          case ':':\n          case '(': {\n            let result = parseFuncCall(str, startPos, pos);\n            if (result.type === 'error') return result\n            marks = result.marks;\n            pos = result.position;\n            break\n          }\n          default: {\n            marks = [\n              {name: 'this_attr', position: startPos},\n              {name: 'ident', position: startPos},\n              {name: 'ident_end', position: pos},\n            ];\n          }\n        }\n\n        break\n      }\n    }\n  }\n\n  if (!marks) {\n    return {type: 'error', position: pos}\n  }\n\n  let lhsLevel = 12;\n  let trav;\n\n  loop: while (true) {\n    let innerPos = skipWS(str, pos);\n    if (innerPos === str.length) {\n      pos = innerPos;\n      break\n    }\n\n    trav = parseTraversal(str, innerPos);\n    if (trav.type === 'success') {\n      marks.unshift({name: 'traverse', position: startPos});\n      while (trav.type === 'success') {\n        marks = marks.concat(trav.marks);\n        pos = trav.position;\n        trav = parseTraversal(str, skipWS(str, pos));\n      }\n      marks.push({name: 'traversal_end', position: pos});\n      continue\n    }\n\n    let token = str[innerPos];\n    switch (token) {\n      case '=': {\n        let nextToken = str[innerPos + 1];\n        switch (nextToken) {\n          case '>': {\n            // =>\n            if (level > PREC_PAIR || lhsLevel <= PREC_PAIR) break loop\n            let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_PAIR);\n            if (rhs.type === 'error') return rhs\n            marks = marks.concat(rhs.marks);\n            marks.unshift({name: 'pair', position: startPos});\n            pos = rhs.position;\n            lhsLevel = PREC_PAIR;\n            break\n          }\n          case '=': {\n            // ==\n            if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n            let rhs = parseExpr(str, skipWS(str, innerPos + 2), 5);\n            if (rhs.type === 'error') return rhs\n            marks.unshift({name: 'comp', position: startPos});\n            marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 2});\n            marks = marks.concat(rhs.marks);\n            pos = rhs.position;\n            lhsLevel = PREC_COMP;\n            break\n          }\n          default:\n            break loop\n        }\n        break\n      }\n      case '+': {\n        if (level > PREC_ADD || lhsLevel < PREC_ADD) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_ADD + 1);\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks);\n        marks.unshift({name: 'add', position: startPos});\n        pos = rhs.position;\n        lhsLevel = PREC_ADD;\n        break\n      }\n      case '-': {\n        if (level > PREC_SUB || lhsLevel < PREC_SUB) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_SUB + 1);\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks);\n        marks.unshift({name: 'sub', position: startPos});\n        pos = rhs.position;\n        lhsLevel = PREC_SUB;\n        break\n      }\n      case '*': {\n        if (str[innerPos + 1] === '*') {\n          // **\n          if (level > PREC_POW || lhsLevel <= PREC_POW) break loop\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_POW);\n          if (rhs.type === 'error') return rhs\n          marks = marks.concat(rhs.marks);\n          marks.unshift({name: 'pow', position: startPos});\n          pos = rhs.position;\n          lhsLevel = PREC_POW;\n          break\n        }\n\n        // *\n        if (level > PREC_MUL || lhsLevel < PREC_MUL) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MUL + 1);\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks);\n        marks.unshift({name: 'mul', position: startPos});\n        pos = rhs.position;\n        lhsLevel = PREC_MUL;\n        break\n      }\n      case '/': {\n        if (level > PREC_DIV || lhsLevel < PREC_DIV) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_DIV + 1);\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks);\n        marks.unshift({name: 'div', position: startPos});\n        pos = rhs.position;\n        lhsLevel = PREC_DIV;\n        break\n      }\n      case '%': {\n        if (level > PREC_MOD || lhsLevel < PREC_MOD) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MOD + 1);\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks);\n        marks.unshift({name: 'mod', position: startPos});\n        pos = rhs.position;\n        lhsLevel = PREC_MOD;\n        break\n      }\n      case '<':\n      case '>': {\n        if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n        let nextPos = innerPos + 1;\n        if (str[nextPos] === '=') {\n          nextPos++;\n        }\n        let rhs = parseExpr(str, skipWS(str, nextPos), PREC_COMP + 1);\n        if (rhs.type === 'error') return rhs\n        marks.unshift({name: 'comp', position: startPos});\n        marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: nextPos});\n        marks = marks.concat(rhs.marks);\n        pos = rhs.position;\n        lhsLevel = PREC_COMP;\n        break\n      }\n      case '|': {\n        if (str[innerPos + 1] === '|') {\n          // ||\n          if (level > PREC_OR || lhsLevel < PREC_OR) break loop\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_OR + 1);\n          if (rhs.type === 'error') return rhs\n          marks = marks.concat(rhs.marks);\n          marks.unshift({name: 'or', position: startPos});\n          pos = rhs.position;\n          lhsLevel = PREC_OR;\n        } else {\n          if (level > 11 || lhsLevel < 11) break loop\n          // pipe call\n          let identPos = skipWS(str, innerPos + 1);\n          let identLen = parseRegex(str, identPos, IDENT);\n          if (!identLen) return {type: 'error', position: identPos}\n          pos = identPos + identLen;\n          if (str[pos] === '(' || str[pos] === ':') {\n            let result = parseFuncCall(str, identPos, pos);\n            if (result.type === 'error') return result\n            marks = marks.concat(result.marks);\n            marks.unshift({name: 'pipecall', position: startPos});\n            pos = result.position;\n            lhsLevel = 11;\n          }\n        }\n        break\n      }\n      case '&': {\n        // &&\n        if (str[innerPos + 1] != '&') break loop\n        if (level > PREC_AND || lhsLevel < PREC_AND) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_AND + 1);\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks);\n        marks.unshift({name: 'and', position: startPos});\n        pos = rhs.position;\n        lhsLevel = PREC_AND;\n        break\n      }\n      case '!': {\n        // !=\n        if (str[innerPos + 1] !== '=') break loop\n        if (level > PREC_COMP || lhsLevel < PREC_COMP) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_COMP + 1);\n        if (rhs.type === 'error') return rhs\n        marks.unshift({name: 'comp', position: startPos});\n        marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 2});\n        marks = marks.concat(rhs.marks);\n        pos = rhs.position;\n        lhsLevel = PREC_COMP;\n        break\n      }\n      case 'd': {\n        // asc\n        if (str.slice(innerPos, innerPos + 4) !== 'desc') break loop\n        if (level > PREC_ORDER || lhsLevel < PREC_ORDER) break loop\n        marks.unshift({name: 'desc', position: startPos});\n        pos = innerPos + 4;\n        lhsLevel = PREC_ORDER;\n        break\n      }\n      case 'a': {\n        // asc\n        if (str.slice(innerPos, innerPos + 3) !== 'asc') break loop\n        if (level > PREC_ORDER || lhsLevel < PREC_ORDER) break loop\n        marks.unshift({name: 'asc', position: startPos});\n        pos = innerPos + 3;\n        lhsLevel = PREC_ORDER;\n        break\n      }\n      default: {\n        let ident = parseRegexStr(str, innerPos, IDENT);\n        switch (ident) {\n          case 'in': {\n            if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n\n            pos = skipWS(str, innerPos + 2);\n\n            let isGroup = false;\n\n            if (str[pos] === '(') {\n              isGroup = true;\n              pos = skipWS(str, pos + 1);\n            }\n\n            let rangePos = pos;\n            let result = parseExpr(str, pos, PREC_COMP + 1);\n            if (result.type === 'error') return result\n\n            pos = skipWS(str, result.position);\n\n            if (str[pos] === '.' && str[pos + 1] === '.') {\n              // LHS in RANGE\n              let type = 'inc_range';\n              if (str[pos + 2] === '.') {\n                type = 'exc_range';\n                pos = skipWS(str, pos + 3);\n              } else {\n                pos = skipWS(str, pos + 2);\n              }\n\n              let rhs = parseExpr(str, pos, PREC_COMP + 1);\n              if (rhs.type === 'error') return rhs\n              marks.unshift({name: 'in_range', position: startPos});\n              marks = marks.concat({name: type, position: rangePos}, result.marks, rhs.marks);\n              pos = rhs.position;\n            } else {\n              // LHS in RHS\n              marks.unshift({name: 'comp', position: startPos});\n              marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 2});\n              marks = marks.concat(result.marks);\n            }\n\n            if (isGroup) {\n              pos = skipWS(str, pos);\n              if (str[pos] !== ')') return {type: 'error', position: pos}\n              pos++;\n            }\n\n            lhsLevel = PREC_COMP;\n            break\n          }\n          case 'match': {\n            // match operator\n            if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n            let rhs = parseExpr(str, skipWS(str, innerPos + 5), PREC_COMP + 1);\n            if (rhs.type === 'error') return rhs\n            marks.unshift({name: 'comp', position: startPos});\n            marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 5});\n            marks = marks.concat(rhs.marks);\n            pos = rhs.position;\n            lhsLevel = 4;\n            break\n          }\n          default: {\n            break loop\n          }\n        }\n      }\n    }\n  }\n\n  let failPosition = trav?.type === 'error' && trav.position;\n\n  return {type: 'success', marks, position: pos, failPosition}\n}\n\nfunction parseTraversal(str, pos) {\n  let startPos = pos;\n  switch (str[pos]) {\n    case '.': {\n      pos = skipWS(str, pos + 1);\n      let identStart = pos;\n      let identLen = parseRegex(str, pos, IDENT);\n      if (!identLen) return {type: 'error', position: pos}\n      pos += identLen;\n\n      return {\n        type: 'success',\n        marks: [\n          {name: 'attr_access', position: startPos},\n          {name: 'ident', position: identStart},\n          {name: 'ident_end', position: pos},\n        ],\n        position: pos,\n      }\n    }\n    case '-':\n      if (str[pos + 1] !== '>') return {type: 'error', position: pos}\n      // ->\n\n      let marks = [{name: 'deref', position: startPos}];\n      pos += 2;\n\n      let identPos = skipWS(str, pos);\n      let identLen = parseRegex(str, identPos, IDENT);\n      if (identLen) {\n        pos = identPos + identLen;\n        marks.push(\n          {name: 'deref_attr', position: identPos},\n          {name: 'ident', position: identPos},\n          {name: 'ident_end', position: pos}\n        );\n      }\n\n      return {\n        type: 'success',\n        marks,\n        position: pos,\n      }\n    case '[': {\n      pos = skipWS(str, pos + 1);\n\n      if (str[pos] === ']') {\n        return {\n          type: 'success',\n          marks: [{name: 'array_postfix', position: startPos}],\n          position: pos + 1,\n        }\n      }\n\n      let rangePos = pos;\n      let result = parseExpr(str, pos, 0);\n      if (result.type === 'error') return result\n\n      pos = skipWS(str, result.position);\n\n      if (str[pos] === '.' && str[pos + 1] === '.') {\n        let type = 'inc_range';\n        if (str[pos + 2] === '.') {\n          type = 'exc_range';\n          pos += 3;\n        } else {\n          pos += 2;\n        }\n\n        pos = skipWS(str, pos);\n        let rhs = parseExpr(str, pos, 0);\n        if (rhs.type === 'error') return rhs\n        pos = skipWS(str, rhs.position);\n        if (str[pos] !== ']') return {type: 'error', position: pos}\n\n        return {\n          type: 'success',\n          marks: [\n            {name: 'slice', position: startPos},\n            {name: type, position: rangePos},\n          ].concat(result.marks, rhs.marks),\n          position: pos + 1,\n        }\n      }\n\n      if (str[pos] !== ']') return {type: 'error', position: pos}\n\n      return {\n        type: 'success',\n        marks: [{name: 'square_bracket', position: startPos}].concat(result.marks),\n        position: pos + 1,\n      }\n    }\n    case '|': {\n      pos = skipWS(str, pos + 1);\n      if (str[pos] === '{') {\n        let result = parseObject(str, pos);\n        if (result.type === 'error') return result\n        result.marks.unshift({name: 'projection', position: startPos});\n        return result\n      }\n      break\n    }\n    case '{': {\n      let result = parseObject(str, pos);\n      if (result.type === 'error') return result\n      result.marks.unshift({name: 'projection', position: startPos});\n      return result\n    }\n  }\n\n  return {type: 'error', position: pos}\n}\n\nfunction parseFuncCall(str, startPos, pos) {\n  let marks = [];\n\n  marks.push({name: 'func_call', position: startPos});\n\n  if (str[pos] === ':' && str[pos + 1] === ':') {\n    marks.push({name: 'namespace', position: startPos});\n    marks.push({name: 'ident', position: startPos}, {name: 'ident_end', position: pos});\n    pos = skipWS(str, pos + 2);\n    let nameLen = parseRegex(str, pos, IDENT);\n    if (!nameLen) return {type: 'error', position: pos}\n    marks.push({name: 'ident', position: pos}, {name: 'ident_end', position: pos + nameLen});\n    pos = skipWS(str, pos + nameLen);\n    if (str[pos] !== '(') return {type: 'error', position: pos}\n    pos++;\n  } else {\n    marks.push({name: 'ident', position: startPos}, {name: 'ident_end', position: pos});\n    pos = skipWS(str, pos + 1);\n  }\n\n  let lastPos = pos;\n\n  if (str[pos] !== ')') {\n    while (true) {\n      let result = parseExpr(str, pos, 0);\n      if (result.type === 'error') return result\n      marks = marks.concat(result.marks);\n      lastPos = result.position;\n      pos = skipWS(str, result.position);\n      if (str[pos] !== ',') break\n      pos = skipWS(str, pos + 1);\n      // Also allow trailing commas\n      if (str[pos] === ')') break\n    }\n  }\n\n  if (str[pos] !== ')') {\n    return {type: 'error', position: pos}\n  }\n\n  // NOTE: a bit arbitrary the func_args_end points comes before the whitespace.\n  marks.push({name: 'func_args_end', position: lastPos});\n\n  return {\n    type: 'success',\n    marks,\n    position: pos + 1,\n  }\n}\n\nfunction parseObject(str, pos) {\n  let marks = [{name: 'object', position: pos}];\n  pos = skipWS(str, pos + 1);\n\n  while (str[pos] !== '}') {\n    let pairPos = pos;\n\n    if (str.slice(pos, pos + 3) === '...') {\n      pos = skipWS(str, pos + 3);\n      if (str[pos] !== '}' && str[pos] !== ',') {\n        let expr = parseExpr(str, pos, 0);\n        if (expr.type === 'error') return expr\n        marks.push({name: 'object_splat', position: pairPos});\n        marks = marks.concat(expr.marks);\n        pos = expr.position;\n      } else {\n        marks.push({name: 'object_splat_this', position: pairPos});\n      }\n    } else {\n      let expr = parseExpr(str, pos, 0);\n      if (expr.type === 'error') return expr\n      let nextPos = skipWS(str, expr.position);\n      if (expr.marks[0].name === 'str' && str[nextPos] === ':') {\n        let value = parseExpr(str, skipWS(str, nextPos + 1), 0);\n        if (value.type === 'error') return value\n        marks.push({name: 'object_pair', position: pairPos});\n        marks = marks.concat(expr.marks, value.marks);\n        pos = value.position;\n      } else {\n        marks = marks.concat({name: 'object_expr', position: pos}, expr.marks);\n        pos = expr.position;\n      }\n    }\n    pos = skipWS(str, pos);\n    if (str[pos] !== ',') break\n    pos = skipWS(str, pos + 1);\n  }\n\n  if (str[pos] !== '}') {\n    return {type: 'error', position: pos}\n  }\n\n  pos++;\n  marks.push({name: 'object_end', position: pos});\n  return {type: 'success', marks, position: pos}\n}\n\nfunction parseString(str, pos) {\n  let token = str[pos];\n  pos = pos + 1;\n  const marks = [{name: 'str', position: pos}];\n  str: for (; ; pos++) {\n    if (pos > str.length) return {type: 'error', position: pos}\n\n    switch (str[pos]) {\n      case token: {\n        marks.push({name: 'str_end', position: pos});\n        pos++;\n        break str\n      }\n      case '\\\\': {\n        marks.push({name: 'str_pause', position: pos});\n        if (str[pos + 1] === 'u') {\n          if (str[pos + 2] === '{') {\n            marks.push({name: 'unicode_hex', position: pos + 3});\n            pos = str.indexOf('}', pos + 3);\n            marks.push({name: 'unicode_hex_end', position: pos});\n          } else {\n            marks.push({name: 'unicode_hex', position: pos + 2});\n            marks.push({name: 'unicode_hex_end', position: pos + 6});\n            pos += 5;\n          }\n        } else {\n          marks.push({name: 'single_escape', position: pos + 1});\n          pos += 1;\n        }\n        marks.push({name: 'str_start', position: pos + 1});\n      }\n    }\n  }\n\n  return {type: 'success', marks, position: pos}\n}\n\nfunction skipWS(str, pos) {\n  return pos + parseRegex(str, pos, WS)\n}\n\n/**\n * Parses a regex at a position and returns the number of characters that was matched.\n */\nfunction parseRegex(str, pos, re) {\n  let m = re.exec(str.slice(pos));\n  return m ? m[0].length : 0\n}\n\n/**\n * Parses a regex at a position and returns matched string.\n */\nfunction parseRegexStr(str, pos, re) {\n  let m = re.exec(str.slice(pos));\n  return m ? m[0] : null\n}/**\n * Join combines two traversals, returning a mapper which is the result of first\n * applying `a` and then applying `b`.\n */\nfunction join(a, b) {\n    return function (base) { return b(a(base)); };\n}\n/**\n * Map returns a new mapper which will the inner mappe to each element of the array.\n */\nfunction map(inner) {\n    return function (base) { return ({ type: 'Map', base: base, expr: inner({ type: 'This' }) }); };\n}\nfunction flatMap(inner) {\n    return function (base) { return ({ type: 'FlatMap', base: base, expr: inner({ type: 'This' }) }); };\n}\nfunction traverseArray(build, right) {\n    if (!right) {\n        return {\n            type: 'a-a',\n            build: build\n        };\n    }\n    switch (right.type) {\n        case 'a-a':\n            return {\n                type: 'a-a',\n                build: join(build, right.build)\n            };\n        case 'a-b':\n            return {\n                type: 'a-b',\n                build: join(build, right.build)\n            };\n        case 'b-b':\n            return {\n                type: 'a-a',\n                build: join(build, map(right.build))\n            };\n        case 'b-a':\n            return {\n                type: 'a-a',\n                build: join(build, flatMap(right.build))\n            };\n        default:\n            throw new Error(\"unknown type: \".concat(right.type));\n    }\n}\nfunction traversePlain(mapper, right) {\n    if (!right) {\n        return {\n            type: 'b-b',\n            build: mapper\n        };\n    }\n    switch (right.type) {\n        case 'a-a':\n        case 'b-a':\n            return {\n                type: 'b-a',\n                build: join(mapper, right.build)\n            };\n        case 'a-b':\n        case 'b-b':\n            return {\n                type: 'b-b',\n                build: join(mapper, right.build)\n            };\n        default:\n            throw new Error(\"unknown type: \".concat(right.type));\n    }\n}\nfunction traverseElement(mapper, right) {\n    if (!right) {\n        return {\n            type: 'a-b',\n            build: mapper\n        };\n    }\n    switch (right.type) {\n        case 'a-a':\n        case 'b-a':\n            return {\n                type: 'a-a',\n                build: join(mapper, right.build)\n            };\n        case 'a-b':\n        case 'b-b':\n            return {\n                type: 'a-b',\n                build: join(mapper, right.build)\n            };\n        default:\n            throw new Error(\"unknown type: \".concat(right.type));\n    }\n}\nfunction traverseProjection(mapper, right) {\n    if (!right) {\n        return {\n            type: 'b-b',\n            build: mapper\n        };\n    }\n    switch (right.type) {\n        case 'a-a':\n            return {\n                type: 'a-a',\n                build: join(map(mapper), right.build)\n            };\n        case 'a-b':\n            return {\n                type: 'a-b',\n                build: join(map(mapper), right.build)\n            };\n        case 'b-a':\n            return {\n                type: 'b-a',\n                build: join(mapper, right.build)\n            };\n        case 'b-b':\n            return {\n                type: 'b-b',\n                build: join(mapper, right.build)\n            };\n        default:\n            throw new Error(\"unknown type: \".concat(right.type));\n    }\n}var isEqual = equality;\nfunction equality(a, b) {\n    if ((a.type === 'string' && b.type === 'string') ||\n        (a.type === 'boolean' && b.type === 'boolean') ||\n        (a.type === 'null' && b.type === 'null') ||\n        (a.type === 'number' && b.type === 'number')) {\n        return a.data === b.data;\n    }\n    if (a.type === 'datetime' && b.type === 'datetime') {\n        return a.data.equals(b.data);\n    }\n    return false;\n}var operators = {\n    '==': function eq(left, right) {\n        return isEqual(left, right) ? TRUE_VALUE : FALSE_VALUE;\n    },\n    '!=': function neq(left, right) {\n        return isEqual(left, right) ? FALSE_VALUE : TRUE_VALUE;\n    },\n    '>': function gt(left, right) {\n        if (left.type === 'stream' || right.type === 'stream')\n            return NULL_VALUE;\n        var result = partialCompare(left.data, right.data);\n        if (result === null) {\n            return NULL_VALUE;\n        }\n        return result > 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    '>=': function gte(left, right) {\n        if (left.type === 'stream' || right.type === 'stream')\n            return NULL_VALUE;\n        var result = partialCompare(left.data, right.data);\n        if (result === null) {\n            return NULL_VALUE;\n        }\n        return result >= 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    '<': function lt(left, right) {\n        if (left.type === 'stream' || right.type === 'stream')\n            return NULL_VALUE;\n        var result = partialCompare(left.data, right.data);\n        if (result === null) {\n            return NULL_VALUE;\n        }\n        return result < 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    '<=': function lte(left, right) {\n        if (left.type === 'stream' || right.type === 'stream')\n            return NULL_VALUE;\n        var result = partialCompare(left.data, right.data);\n        if (result === null) {\n            return NULL_VALUE;\n        }\n        return result <= 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    // eslint-disable-next-line func-name-matching\n    \"in\": function inop(left, right) {\n        var right_1, right_1_1;\n        var e_1, _a;\n        return __awaiter(this, void 0, void 0, function () {\n            var b, e_1_1;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (right.type === 'path') {\n                            if (left.type !== 'string') {\n                                return [2 /*return*/, NULL_VALUE];\n                            }\n                            return [2 /*return*/, right.data.matches(left.data) ? TRUE_VALUE : FALSE_VALUE];\n                        }\n                        if (!right.isArray()) return [3 /*break*/, 13];\n                        _b.label = 1;\n                    case 1:\n                        _b.trys.push([1, 6, 7, 12]);\n                        right_1 = __asyncValues(right);\n                        _b.label = 2;\n                    case 2: return [4 /*yield*/, right_1.next()];\n                    case 3:\n                        if (!(right_1_1 = _b.sent(), !right_1_1.done)) return [3 /*break*/, 5];\n                        b = right_1_1.value;\n                        if (isEqual(left, b)) {\n                            return [2 /*return*/, TRUE_VALUE];\n                        }\n                        _b.label = 4;\n                    case 4: return [3 /*break*/, 2];\n                    case 5: return [3 /*break*/, 12];\n                    case 6:\n                        e_1_1 = _b.sent();\n                        e_1 = { error: e_1_1 };\n                        return [3 /*break*/, 12];\n                    case 7:\n                        _b.trys.push([7, , 10, 11]);\n                        if (!(right_1_1 && !right_1_1.done && (_a = right_1[\"return\"]))) return [3 /*break*/, 9];\n                        return [4 /*yield*/, _a.call(right_1)];\n                    case 8:\n                        _b.sent();\n                        _b.label = 9;\n                    case 9: return [3 /*break*/, 11];\n                    case 10:\n                        if (e_1) throw e_1.error;\n                        return [7 /*endfinally*/];\n                    case 11: return [7 /*endfinally*/];\n                    case 12: return [2 /*return*/, FALSE_VALUE];\n                    case 13: return [2 /*return*/, NULL_VALUE];\n                }\n            });\n        });\n    },\n    match: function match(left, right) {\n        return __awaiter(this, void 0, void 0, function () {\n            var tokens, patterns, didSucceed, matched;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        tokens = [];\n                        patterns = [];\n                        return [4 /*yield*/, gatherText(left, function (part) {\n                                tokens = tokens.concat(matchTokenize(part));\n                            })];\n                    case 1:\n                        _a.sent();\n                        return [4 /*yield*/, gatherText(right, function (part) {\n                                patterns = patterns.concat(matchAnalyzePattern(part));\n                            })];\n                    case 2:\n                        didSucceed = _a.sent();\n                        if (!didSucceed) {\n                            return [2 /*return*/, FALSE_VALUE];\n                        }\n                        matched = matchText(tokens, patterns);\n                        return [2 /*return*/, matched ? TRUE_VALUE : FALSE_VALUE];\n                }\n            });\n        });\n    },\n    '+': function plus(left, right) {\n        if (left.type === 'datetime' && right.type === 'number') {\n            return fromDateTime(left.data.add(right.data));\n        }\n        if (left.type === 'number' && right.type === 'number') {\n            return fromNumber(left.data + right.data);\n        }\n        if (left.type === 'string' && right.type === 'string') {\n            return fromString(left.data + right.data);\n        }\n        if (left.type === 'object' && right.type === 'object') {\n            return fromJS(__assign(__assign({}, left.data), right.data));\n        }\n        if (left.type === 'array' && right.type === 'array') {\n            return fromJS(left.data.concat(right.data));\n        }\n        if (left.isArray() && right.isArray()) {\n            return new StreamValue(function () {\n                return __asyncGenerator(this, arguments, function () {\n                    var left_1, left_1_1, val, e_2_1, right_2, right_2_1, val, e_3_1;\n                    var e_2, _a, e_3, _b;\n                    return __generator(this, function (_c) {\n                        switch (_c.label) {\n                            case 0:\n                                _c.trys.push([0, 7, 8, 13]);\n                                left_1 = __asyncValues(left);\n                                _c.label = 1;\n                            case 1: return [4 /*yield*/, __await(left_1.next())];\n                            case 2:\n                                if (!(left_1_1 = _c.sent(), !left_1_1.done)) return [3 /*break*/, 6];\n                                val = left_1_1.value;\n                                return [4 /*yield*/, __await(val)];\n                            case 3: return [4 /*yield*/, _c.sent()];\n                            case 4:\n                                _c.sent();\n                                _c.label = 5;\n                            case 5: return [3 /*break*/, 1];\n                            case 6: return [3 /*break*/, 13];\n                            case 7:\n                                e_2_1 = _c.sent();\n                                e_2 = { error: e_2_1 };\n                                return [3 /*break*/, 13];\n                            case 8:\n                                _c.trys.push([8, , 11, 12]);\n                                if (!(left_1_1 && !left_1_1.done && (_a = left_1[\"return\"]))) return [3 /*break*/, 10];\n                                return [4 /*yield*/, __await(_a.call(left_1))];\n                            case 9:\n                                _c.sent();\n                                _c.label = 10;\n                            case 10: return [3 /*break*/, 12];\n                            case 11:\n                                if (e_2) throw e_2.error;\n                                return [7 /*endfinally*/];\n                            case 12: return [7 /*endfinally*/];\n                            case 13:\n                                _c.trys.push([13, 20, 21, 26]);\n                                right_2 = __asyncValues(right);\n                                _c.label = 14;\n                            case 14: return [4 /*yield*/, __await(right_2.next())];\n                            case 15:\n                                if (!(right_2_1 = _c.sent(), !right_2_1.done)) return [3 /*break*/, 19];\n                                val = right_2_1.value;\n                                return [4 /*yield*/, __await(val)];\n                            case 16: return [4 /*yield*/, _c.sent()];\n                            case 17:\n                                _c.sent();\n                                _c.label = 18;\n                            case 18: return [3 /*break*/, 14];\n                            case 19: return [3 /*break*/, 26];\n                            case 20:\n                                e_3_1 = _c.sent();\n                                e_3 = { error: e_3_1 };\n                                return [3 /*break*/, 26];\n                            case 21:\n                                _c.trys.push([21, , 24, 25]);\n                                if (!(right_2_1 && !right_2_1.done && (_b = right_2[\"return\"]))) return [3 /*break*/, 23];\n                                return [4 /*yield*/, __await(_b.call(right_2))];\n                            case 22:\n                                _c.sent();\n                                _c.label = 23;\n                            case 23: return [3 /*break*/, 25];\n                            case 24:\n                                if (e_3) throw e_3.error;\n                                return [7 /*endfinally*/];\n                            case 25: return [7 /*endfinally*/];\n                            case 26: return [2 /*return*/];\n                        }\n                    });\n                });\n            });\n        }\n        return NULL_VALUE;\n    },\n    '-': function minus(left, right) {\n        if (left.type === 'datetime' && right.type === 'number') {\n            return fromDateTime(left.data.add(-right.data));\n        }\n        if (left.type === 'datetime' && right.type === 'datetime') {\n            return fromNumber(left.data.difference(right.data));\n        }\n        if (left.type === 'number' && right.type === 'number') {\n            return fromNumber(left.data - right.data);\n        }\n        return NULL_VALUE;\n    },\n    '*': numericOperator(function (a, b) { return a * b; }),\n    '/': numericOperator(function (a, b) { return a / b; }),\n    '%': numericOperator(function (a, b) { return a % b; }),\n    '**': numericOperator(function (a, b) { return Math.pow(a, b); })\n};\nfunction numericOperator(impl) {\n    return function (left, right) {\n        if (left.type === 'number' && right.type === 'number') {\n            var result = impl(left.data, right.data);\n            return fromNumber(result);\n        }\n        return NULL_VALUE;\n    };\n}var Scope = /** @class */ (function () {\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    function Scope(params, source, value, context, parent) {\n        this.isHidden = false;\n        this.params = params;\n        this.source = source;\n        this.value = value;\n        this.context = context;\n        this.parent = parent;\n    }\n    Scope.prototype.createNested = function (value) {\n        if (this.isHidden) {\n            return new Scope(this.params, this.source, value, this.context, this.parent);\n        }\n        return new Scope(this.params, this.source, value, this.context, this);\n    };\n    Scope.prototype.createHidden = function (value) {\n        var result = this.createNested(value);\n        result.isHidden = true;\n        return result;\n    };\n    return Scope;\n}());function evaluate(node, scope, execute) {\n    if (execute === void 0) { execute = evaluate; }\n    var func = EXECUTORS[node.type];\n    return func(node, scope, execute);\n}\n/**\n * Applies the function to a value, but tries to avoid creating unnecessary promises.\n */\nfunction promiselessApply(value, cb) {\n    if ('then' in value) {\n        return value.then(cb);\n    }\n    return cb(value);\n}\nvar EXECUTORS = {\n    This: function (_, scope) {\n        return scope.value;\n    },\n    Selector: function () {\n        // These should be evaluated separely using a different evaluator.\n        // At the mooment we haven't implemented this.\n        throw new Error('Selectors can not be evaluated');\n    },\n    Everything: function (_, scope) {\n        return scope.source;\n    },\n    Parameter: function (_a, scope) {\n        var name = _a.name;\n        return fromJS(scope.params[name]);\n    },\n    Context: function (_a, scope) {\n        var key = _a.key;\n        if (key === 'before' || key === 'after') {\n            var value = scope.context[key];\n            return value || NULL_VALUE;\n        }\n        throw new Error(\"unknown context key: \".concat(key));\n    },\n    Parent: function (_a, scope) {\n        var n = _a.n;\n        var current = scope;\n        for (var i = 0; i < n; i++) {\n            if (!current.parent) {\n                return NULL_VALUE;\n            }\n            current = current.parent;\n        }\n        return current.value;\n    },\n    OpCall: function (_a, scope, execute) {\n        var _this = this;\n        var op = _a.op, left = _a.left, right = _a.right;\n        var func = operators[op];\n        if (!func) {\n            throw new Error(\"Unknown operator: \".concat(op));\n        }\n        var leftValue = execute(left, scope);\n        var rightValue = execute(right, scope);\n        // Avoid uneccesary promises\n        // This is required for constant evaluation to work correctly.\n        if ('then' in leftValue || 'then' in rightValue) {\n            return (function () { return __awaiter(_this, void 0, void 0, function () { var _a, _b; return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        _a = func;\n                        return [4 /*yield*/, leftValue];\n                    case 1:\n                        _b = [_c.sent()];\n                        return [4 /*yield*/, rightValue];\n                    case 2: return [2 /*return*/, _a.apply(void 0, _b.concat([_c.sent()]))];\n                }\n            }); }); })();\n        }\n        return func(leftValue, rightValue);\n    },\n    Select: function (_a, scope, execute) {\n        var alternatives = _a.alternatives, fallback = _a.fallback;\n        return __awaiter(this, void 0, void 0, function () {\n            var _i, alternatives_1, alt, altCond;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _i = 0, alternatives_1 = alternatives;\n                        _b.label = 1;\n                    case 1:\n                        if (!(_i < alternatives_1.length)) return [3 /*break*/, 4];\n                        alt = alternatives_1[_i];\n                        return [4 /*yield*/, execute(alt.condition, scope)];\n                    case 2:\n                        altCond = _b.sent();\n                        if (altCond.type === 'boolean' && altCond.data === true) {\n                            return [2 /*return*/, execute(alt.value, scope)];\n                        }\n                        _b.label = 3;\n                    case 3:\n                        _i++;\n                        return [3 /*break*/, 1];\n                    case 4:\n                        if (fallback) {\n                            return [2 /*return*/, execute(fallback, scope)];\n                        }\n                        return [2 /*return*/, NULL_VALUE];\n                }\n            });\n        });\n    },\n    InRange: function (_a, scope, execute) {\n        var base = _a.base, left = _a.left, right = _a.right, isInclusive = _a.isInclusive;\n        return __awaiter(this, void 0, void 0, function () {\n            var value, leftValue, rightValue, leftCmp, _b, _c, rightCmp, _d, _e;\n            return __generator(this, function (_f) {\n                switch (_f.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        value = _f.sent();\n                        return [4 /*yield*/, execute(left, scope)];\n                    case 2:\n                        leftValue = _f.sent();\n                        return [4 /*yield*/, execute(right, scope)];\n                    case 3:\n                        rightValue = _f.sent();\n                        _b = partialCompare;\n                        return [4 /*yield*/, value.get()];\n                    case 4:\n                        _c = [_f.sent()];\n                        return [4 /*yield*/, leftValue.get()];\n                    case 5:\n                        leftCmp = _b.apply(void 0, _c.concat([_f.sent()]));\n                        if (leftCmp === null) {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        _d = partialCompare;\n                        return [4 /*yield*/, value.get()];\n                    case 6:\n                        _e = [_f.sent()];\n                        return [4 /*yield*/, rightValue.get()];\n                    case 7:\n                        rightCmp = _d.apply(void 0, _e.concat([_f.sent()]));\n                        if (rightCmp === null) {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        if (isInclusive) {\n                            return [2 /*return*/, leftCmp >= 0 && rightCmp <= 0 ? TRUE_VALUE : FALSE_VALUE];\n                        }\n                        return [2 /*return*/, leftCmp >= 0 && rightCmp < 0 ? TRUE_VALUE : FALSE_VALUE];\n                }\n            });\n        });\n    },\n    Filter: function (_a, scope, execute) {\n        var base = _a.base, expr = _a.expr;\n        return __awaiter(this, void 0, void 0, function () {\n            var baseValue;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        baseValue = _b.sent();\n                        if (!baseValue.isArray()) {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        return [2 /*return*/, new StreamValue(function () {\n                                return __asyncGenerator(this, arguments, function () {\n                                    var baseValue_1, baseValue_1_1, elem, newScope, exprValue, e_1_1;\n                                    var e_1, _a;\n                                    return __generator(this, function (_b) {\n                                        switch (_b.label) {\n                                            case 0:\n                                                _b.trys.push([0, 8, 9, 14]);\n                                                baseValue_1 = __asyncValues(baseValue);\n                                                _b.label = 1;\n                                            case 1: return [4 /*yield*/, __await(baseValue_1.next())];\n                                            case 2:\n                                                if (!(baseValue_1_1 = _b.sent(), !baseValue_1_1.done)) return [3 /*break*/, 7];\n                                                elem = baseValue_1_1.value;\n                                                newScope = scope.createNested(elem);\n                                                return [4 /*yield*/, __await(execute(expr, newScope))];\n                                            case 3:\n                                                exprValue = _b.sent();\n                                                if (!(exprValue.type === 'boolean' && exprValue.data === true)) return [3 /*break*/, 6];\n                                                return [4 /*yield*/, __await(elem)];\n                                            case 4: return [4 /*yield*/, _b.sent()];\n                                            case 5:\n                                                _b.sent();\n                                                _b.label = 6;\n                                            case 6: return [3 /*break*/, 1];\n                                            case 7: return [3 /*break*/, 14];\n                                            case 8:\n                                                e_1_1 = _b.sent();\n                                                e_1 = { error: e_1_1 };\n                                                return [3 /*break*/, 14];\n                                            case 9:\n                                                _b.trys.push([9, , 12, 13]);\n                                                if (!(baseValue_1_1 && !baseValue_1_1.done && (_a = baseValue_1[\"return\"]))) return [3 /*break*/, 11];\n                                                return [4 /*yield*/, __await(_a.call(baseValue_1))];\n                                            case 10:\n                                                _b.sent();\n                                                _b.label = 11;\n                                            case 11: return [3 /*break*/, 13];\n                                            case 12:\n                                                if (e_1) throw e_1.error;\n                                                return [7 /*endfinally*/];\n                                            case 13: return [7 /*endfinally*/];\n                                            case 14: return [2 /*return*/];\n                                        }\n                                    });\n                                });\n                            })];\n                }\n            });\n        });\n    },\n    Projection: function (_a, scope, execute) {\n        var base = _a.base, expr = _a.expr;\n        return __awaiter(this, void 0, void 0, function () {\n            var baseValue, newScope;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        baseValue = _b.sent();\n                        if (baseValue.type !== 'object') {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        newScope = scope.createNested(baseValue);\n                        return [2 /*return*/, execute(expr, newScope)];\n                }\n            });\n        });\n    },\n    FuncCall: function (_a, scope, execute) {\n        var func = _a.func, args = _a.args;\n        return func(args, scope, execute);\n    },\n    PipeFuncCall: function (_a, scope, execute) {\n        var func = _a.func, base = _a.base, args = _a.args;\n        return __awaiter(this, void 0, void 0, function () {\n            var baseValue;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        baseValue = _b.sent();\n                        return [2 /*return*/, func(baseValue, args, scope, execute)];\n                }\n            });\n        });\n    },\n    AccessAttribute: function (_a, scope, execute) {\n        var base = _a.base, name = _a.name;\n        return __awaiter(this, void 0, void 0, function () {\n            var value;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        value = scope.value;\n                        if (!base) return [3 /*break*/, 2];\n                        return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        value = _b.sent();\n                        _b.label = 2;\n                    case 2:\n                        if (value.type === 'object') {\n                            if (value.data.hasOwnProperty(name)) {\n                                return [2 /*return*/, fromJS(value.data[name])];\n                            }\n                        }\n                        return [2 /*return*/, NULL_VALUE];\n                }\n            });\n        });\n    },\n    AccessElement: function (_a, scope, execute) {\n        var base = _a.base, index = _a.index;\n        return __awaiter(this, void 0, void 0, function () {\n            var baseValue, data, finalIndex;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        baseValue = _b.sent();\n                        if (!baseValue.isArray()) {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        return [4 /*yield*/, baseValue.get()];\n                    case 2:\n                        data = _b.sent();\n                        finalIndex = index < 0 ? index + data.length : index;\n                        return [2 /*return*/, fromJS(data[finalIndex])];\n                }\n            });\n        });\n    },\n    Slice: function (_a, scope, execute) {\n        var base = _a.base, left = _a.left, right = _a.right, isInclusive = _a.isInclusive;\n        return __awaiter(this, void 0, void 0, function () {\n            var baseValue, array, leftIdx, rightIdx;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        baseValue = _b.sent();\n                        if (!baseValue.isArray()) {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        return [4 /*yield*/, baseValue.get()];\n                    case 2:\n                        array = (_b.sent());\n                        leftIdx = left;\n                        rightIdx = right;\n                        // Handle negative index\n                        if (leftIdx < 0) {\n                            leftIdx = array.length + leftIdx;\n                        }\n                        if (rightIdx < 0) {\n                            rightIdx = array.length + rightIdx;\n                        }\n                        // Convert from inclusive to exclusive index\n                        if (isInclusive) {\n                            rightIdx++;\n                        }\n                        if (leftIdx < 0) {\n                            leftIdx = 0;\n                        }\n                        if (rightIdx < 0) {\n                            rightIdx = 0;\n                        }\n                        // Note: At this point the indices might point out-of-bound, but\n                        // .slice handles this correctly.\n                        return [2 /*return*/, fromJS(array.slice(leftIdx, rightIdx))];\n                }\n            });\n        });\n    },\n    Deref: function (_a, scope, execute) {\n        var e_2, _b;\n        var base = _a.base;\n        return __awaiter(this, void 0, void 0, function () {\n            var value, id, _c, _d, doc, e_2_1;\n            return __generator(this, function (_e) {\n                switch (_e.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        value = _e.sent();\n                        if (!scope.source.isArray()) {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        if (value.type !== 'object') {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        id = value.data._ref;\n                        if (typeof id !== 'string') {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        _e.label = 2;\n                    case 2:\n                        _e.trys.push([2, 7, 8, 13]);\n                        _c = __asyncValues(scope.source);\n                        _e.label = 3;\n                    case 3: return [4 /*yield*/, _c.next()];\n                    case 4:\n                        if (!(_d = _e.sent(), !_d.done)) return [3 /*break*/, 6];\n                        doc = _d.value;\n                        if (doc.type === 'object' && id === doc.data._id) {\n                            return [2 /*return*/, doc];\n                        }\n                        _e.label = 5;\n                    case 5: return [3 /*break*/, 3];\n                    case 6: return [3 /*break*/, 13];\n                    case 7:\n                        e_2_1 = _e.sent();\n                        e_2 = { error: e_2_1 };\n                        return [3 /*break*/, 13];\n                    case 8:\n                        _e.trys.push([8, , 11, 12]);\n                        if (!(_d && !_d.done && (_b = _c[\"return\"]))) return [3 /*break*/, 10];\n                        return [4 /*yield*/, _b.call(_c)];\n                    case 9:\n                        _e.sent();\n                        _e.label = 10;\n                    case 10: return [3 /*break*/, 12];\n                    case 11:\n                        if (e_2) throw e_2.error;\n                        return [7 /*endfinally*/];\n                    case 12: return [7 /*endfinally*/];\n                    case 13: return [2 /*return*/, NULL_VALUE];\n                }\n            });\n        });\n    },\n    Value: function (_a) {\n        var value = _a.value;\n        return fromJS(value);\n    },\n    Group: function (_a, scope, execute) {\n        var base = _a.base;\n        return execute(base, scope);\n    },\n    Object: function (_a, scope, execute) {\n        var attributes = _a.attributes;\n        return __awaiter(this, void 0, void 0, function () {\n            var result, _i, attributes_1, attr, attrType, _b, value, _c, _d, cond, value, value;\n            return __generator(this, function (_e) {\n                switch (_e.label) {\n                    case 0:\n                        result = {};\n                        _i = 0, attributes_1 = attributes;\n                        _e.label = 1;\n                    case 1:\n                        if (!(_i < attributes_1.length)) return [3 /*break*/, 12];\n                        attr = attributes_1[_i];\n                        attrType = attr.type;\n                        _b = attr.type;\n                        switch (_b) {\n                            case 'ObjectAttributeValue': return [3 /*break*/, 2];\n                            case 'ObjectConditionalSplat': return [3 /*break*/, 5];\n                            case 'ObjectSplat': return [3 /*break*/, 8];\n                        }\n                        return [3 /*break*/, 10];\n                    case 2: return [4 /*yield*/, execute(attr.value, scope)];\n                    case 3:\n                        value = _e.sent();\n                        _c = result;\n                        _d = attr.name;\n                        return [4 /*yield*/, value.get()];\n                    case 4:\n                        _c[_d] = _e.sent();\n                        return [3 /*break*/, 11];\n                    case 5: return [4 /*yield*/, execute(attr.condition, scope)];\n                    case 6:\n                        cond = _e.sent();\n                        if (cond.type !== 'boolean' || cond.data === false) {\n                            return [3 /*break*/, 11];\n                        }\n                        return [4 /*yield*/, execute(attr.value, scope)];\n                    case 7:\n                        value = _e.sent();\n                        if (value.type === 'object') {\n                            Object.assign(result, value.data);\n                        }\n                        return [3 /*break*/, 11];\n                    case 8: return [4 /*yield*/, execute(attr.value, scope)];\n                    case 9:\n                        value = _e.sent();\n                        if (value.type === 'object') {\n                            Object.assign(result, value.data);\n                        }\n                        return [3 /*break*/, 11];\n                    case 10: throw new Error(\"Unknown node type: \".concat(attrType));\n                    case 11:\n                        _i++;\n                        return [3 /*break*/, 1];\n                    case 12: return [2 /*return*/, fromJS(result)];\n                }\n            });\n        });\n    },\n    Array: function (_a, scope, execute) {\n        var elements = _a.elements;\n        return new StreamValue(function () {\n            return __asyncGenerator(this, arguments, function () {\n                var _i, elements_1, element, value, value_1, value_1_1, v, e_3_1;\n                var e_3, _a;\n                return __generator(this, function (_b) {\n                    switch (_b.label) {\n                        case 0:\n                            _i = 0, elements_1 = elements;\n                            _b.label = 1;\n                        case 1:\n                            if (!(_i < elements_1.length)) return [3 /*break*/, 21];\n                            element = elements_1[_i];\n                            return [4 /*yield*/, __await(execute(element.value, scope))];\n                        case 2:\n                            value = _b.sent();\n                            if (!element.isSplat) return [3 /*break*/, 17];\n                            if (!value.isArray()) return [3 /*break*/, 16];\n                            _b.label = 3;\n                        case 3:\n                            _b.trys.push([3, 10, 11, 16]);\n                            value_1 = (e_3 = void 0, __asyncValues(value));\n                            _b.label = 4;\n                        case 4: return [4 /*yield*/, __await(value_1.next())];\n                        case 5:\n                            if (!(value_1_1 = _b.sent(), !value_1_1.done)) return [3 /*break*/, 9];\n                            v = value_1_1.value;\n                            return [4 /*yield*/, __await(v)];\n                        case 6: return [4 /*yield*/, _b.sent()];\n                        case 7:\n                            _b.sent();\n                            _b.label = 8;\n                        case 8: return [3 /*break*/, 4];\n                        case 9: return [3 /*break*/, 16];\n                        case 10:\n                            e_3_1 = _b.sent();\n                            e_3 = { error: e_3_1 };\n                            return [3 /*break*/, 16];\n                        case 11:\n                            _b.trys.push([11, , 14, 15]);\n                            if (!(value_1_1 && !value_1_1.done && (_a = value_1[\"return\"]))) return [3 /*break*/, 13];\n                            return [4 /*yield*/, __await(_a.call(value_1))];\n                        case 12:\n                            _b.sent();\n                            _b.label = 13;\n                        case 13: return [3 /*break*/, 15];\n                        case 14:\n                            if (e_3) throw e_3.error;\n                            return [7 /*endfinally*/];\n                        case 15: return [7 /*endfinally*/];\n                        case 16: return [3 /*break*/, 20];\n                        case 17: return [4 /*yield*/, __await(value)];\n                        case 18: return [4 /*yield*/, _b.sent()];\n                        case 19:\n                            _b.sent();\n                            _b.label = 20;\n                        case 20:\n                            _i++;\n                            return [3 /*break*/, 1];\n                        case 21: return [2 /*return*/];\n                    }\n                });\n            });\n        });\n    },\n    Tuple: function () {\n        throw new Error('tuples can not be evaluated');\n    },\n    Or: function (_a, scope, execute) {\n        var left = _a.left, right = _a.right;\n        return __awaiter(this, void 0, void 0, function () {\n            var leftValue, rightValue;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(left, scope)];\n                    case 1:\n                        leftValue = _b.sent();\n                        return [4 /*yield*/, execute(right, scope)];\n                    case 2:\n                        rightValue = _b.sent();\n                        if (leftValue.type === 'boolean') {\n                            if (leftValue.data === true) {\n                                return [2 /*return*/, TRUE_VALUE];\n                            }\n                        }\n                        if (rightValue.type === 'boolean') {\n                            if (rightValue.data === true) {\n                                return [2 /*return*/, TRUE_VALUE];\n                            }\n                        }\n                        if (leftValue.type !== 'boolean' || rightValue.type !== 'boolean') {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        return [2 /*return*/, FALSE_VALUE];\n                }\n            });\n        });\n    },\n    And: function (_a, scope, execute) {\n        var left = _a.left, right = _a.right;\n        return __awaiter(this, void 0, void 0, function () {\n            var leftValue, rightValue;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(left, scope)];\n                    case 1:\n                        leftValue = _b.sent();\n                        return [4 /*yield*/, execute(right, scope)];\n                    case 2:\n                        rightValue = _b.sent();\n                        if (leftValue.type === 'boolean') {\n                            if (leftValue.data === false) {\n                                return [2 /*return*/, FALSE_VALUE];\n                            }\n                        }\n                        if (rightValue.type === 'boolean') {\n                            if (rightValue.data === false) {\n                                return [2 /*return*/, FALSE_VALUE];\n                            }\n                        }\n                        if (leftValue.type !== 'boolean' || rightValue.type !== 'boolean') {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        return [2 /*return*/, TRUE_VALUE];\n                }\n            });\n        });\n    },\n    Not: function (_a, scope, execute) {\n        var base = _a.base;\n        return __awaiter(this, void 0, void 0, function () {\n            var value;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        value = _b.sent();\n                        if (value.type !== 'boolean') {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        return [2 /*return*/, value.data ? FALSE_VALUE : TRUE_VALUE];\n                }\n            });\n        });\n    },\n    Neg: function (_a, scope, execute) {\n        var base = _a.base;\n        return promiselessApply(execute(base, scope), function (value) {\n            if (value.type !== 'number') {\n                return NULL_VALUE;\n            }\n            return fromNumber(-value.data);\n        });\n    },\n    Pos: function (_a, scope, execute) {\n        var base = _a.base;\n        return promiselessApply(execute(base, scope), function (value) {\n            if (value.type !== 'number') {\n                return NULL_VALUE;\n            }\n            return fromNumber(value.data);\n        });\n    },\n    Asc: function () {\n        return NULL_VALUE;\n    },\n    Desc: function () {\n        return NULL_VALUE;\n    },\n    ArrayCoerce: function (_a, scope, execute) {\n        var base = _a.base;\n        return __awaiter(this, void 0, void 0, function () {\n            var value;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        value = _b.sent();\n                        return [2 /*return*/, value.isArray() ? value : NULL_VALUE];\n                }\n            });\n        });\n    },\n    Map: function (_a, scope, execute) {\n        var base = _a.base, expr = _a.expr;\n        return __awaiter(this, void 0, void 0, function () {\n            var value;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        value = _b.sent();\n                        if (!value.isArray()) {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        return [2 /*return*/, new StreamValue(function () {\n                                return __asyncGenerator(this, arguments, function () {\n                                    var value_2, value_2_1, elem, newScope, e_4_1;\n                                    var e_4, _a;\n                                    return __generator(this, function (_b) {\n                                        switch (_b.label) {\n                                            case 0:\n                                                _b.trys.push([0, 8, 9, 14]);\n                                                value_2 = __asyncValues(value);\n                                                _b.label = 1;\n                                            case 1: return [4 /*yield*/, __await(value_2.next())];\n                                            case 2:\n                                                if (!(value_2_1 = _b.sent(), !value_2_1.done)) return [3 /*break*/, 7];\n                                                elem = value_2_1.value;\n                                                newScope = scope.createHidden(elem);\n                                                return [4 /*yield*/, __await(execute(expr, newScope))];\n                                            case 3: return [4 /*yield*/, __await.apply(void 0, [_b.sent()])];\n                                            case 4: return [4 /*yield*/, _b.sent()];\n                                            case 5:\n                                                _b.sent();\n                                                _b.label = 6;\n                                            case 6: return [3 /*break*/, 1];\n                                            case 7: return [3 /*break*/, 14];\n                                            case 8:\n                                                e_4_1 = _b.sent();\n                                                e_4 = { error: e_4_1 };\n                                                return [3 /*break*/, 14];\n                                            case 9:\n                                                _b.trys.push([9, , 12, 13]);\n                                                if (!(value_2_1 && !value_2_1.done && (_a = value_2[\"return\"]))) return [3 /*break*/, 11];\n                                                return [4 /*yield*/, __await(_a.call(value_2))];\n                                            case 10:\n                                                _b.sent();\n                                                _b.label = 11;\n                                            case 11: return [3 /*break*/, 13];\n                                            case 12:\n                                                if (e_4) throw e_4.error;\n                                                return [7 /*endfinally*/];\n                                            case 13: return [7 /*endfinally*/];\n                                            case 14: return [2 /*return*/];\n                                        }\n                                    });\n                                });\n                            })];\n                }\n            });\n        });\n    },\n    FlatMap: function (_a, scope, execute) {\n        var base = _a.base, expr = _a.expr;\n        return __awaiter(this, void 0, void 0, function () {\n            var value;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, execute(base, scope)];\n                    case 1:\n                        value = _b.sent();\n                        if (!value.isArray()) {\n                            return [2 /*return*/, NULL_VALUE];\n                        }\n                        return [2 /*return*/, new StreamValue(function () {\n                                return __asyncGenerator(this, arguments, function () {\n                                    var value_3, value_3_1, elem, newScope, innerValue, innerValue_1, innerValue_1_1, inner, e_5_1, e_6_1;\n                                    var e_6, _a, e_5, _b;\n                                    return __generator(this, function (_c) {\n                                        switch (_c.label) {\n                                            case 0:\n                                                _c.trys.push([0, 23, 24, 29]);\n                                                value_3 = __asyncValues(value);\n                                                _c.label = 1;\n                                            case 1: return [4 /*yield*/, __await(value_3.next())];\n                                            case 2:\n                                                if (!(value_3_1 = _c.sent(), !value_3_1.done)) return [3 /*break*/, 22];\n                                                elem = value_3_1.value;\n                                                newScope = scope.createHidden(elem);\n                                                return [4 /*yield*/, __await(execute(expr, newScope))];\n                                            case 3:\n                                                innerValue = _c.sent();\n                                                if (!innerValue.isArray()) return [3 /*break*/, 18];\n                                                _c.label = 4;\n                                            case 4:\n                                                _c.trys.push([4, 11, 12, 17]);\n                                                innerValue_1 = (e_5 = void 0, __asyncValues(innerValue));\n                                                _c.label = 5;\n                                            case 5: return [4 /*yield*/, __await(innerValue_1.next())];\n                                            case 6:\n                                                if (!(innerValue_1_1 = _c.sent(), !innerValue_1_1.done)) return [3 /*break*/, 10];\n                                                inner = innerValue_1_1.value;\n                                                return [4 /*yield*/, __await(inner)];\n                                            case 7: return [4 /*yield*/, _c.sent()];\n                                            case 8:\n                                                _c.sent();\n                                                _c.label = 9;\n                                            case 9: return [3 /*break*/, 5];\n                                            case 10: return [3 /*break*/, 17];\n                                            case 11:\n                                                e_5_1 = _c.sent();\n                                                e_5 = { error: e_5_1 };\n                                                return [3 /*break*/, 17];\n                                            case 12:\n                                                _c.trys.push([12, , 15, 16]);\n                                                if (!(innerValue_1_1 && !innerValue_1_1.done && (_b = innerValue_1[\"return\"]))) return [3 /*break*/, 14];\n                                                return [4 /*yield*/, __await(_b.call(innerValue_1))];\n                                            case 13:\n                                                _c.sent();\n                                                _c.label = 14;\n                                            case 14: return [3 /*break*/, 16];\n                                            case 15:\n                                                if (e_5) throw e_5.error;\n                                                return [7 /*endfinally*/];\n                                            case 16: return [7 /*endfinally*/];\n                                            case 17: return [3 /*break*/, 21];\n                                            case 18: return [4 /*yield*/, __await(innerValue)];\n                                            case 19: return [4 /*yield*/, _c.sent()];\n                                            case 20:\n                                                _c.sent();\n                                                _c.label = 21;\n                                            case 21: return [3 /*break*/, 1];\n                                            case 22: return [3 /*break*/, 29];\n                                            case 23:\n                                                e_6_1 = _c.sent();\n                                                e_6 = { error: e_6_1 };\n                                                return [3 /*break*/, 29];\n                                            case 24:\n                                                _c.trys.push([24, , 27, 28]);\n                                                if (!(value_3_1 && !value_3_1.done && (_a = value_3[\"return\"]))) return [3 /*break*/, 26];\n                                                return [4 /*yield*/, __await(_a.call(value_3))];\n                                            case 25:\n                                                _c.sent();\n                                                _c.label = 26;\n                                            case 26: return [3 /*break*/, 28];\n                                            case 27:\n                                                if (e_6) throw e_6.error;\n                                                return [7 /*endfinally*/];\n                                            case 28: return [7 /*endfinally*/];\n                                            case 29: return [2 /*return*/];\n                                        }\n                                    });\n                                });\n                            })];\n                }\n            });\n        });\n    }\n};\n/**\n * Evaluates a query.\n */\nfunction evaluateQuery(tree, options) {\n    if (options === void 0) { options = {}; }\n    var root = fromJS(options.root);\n    var dataset = fromJS(options.dataset);\n    var params = __assign({}, options.params);\n    var scope = new Scope(params, dataset, root, {\n        timestamp: options.timestamp || new Date(),\n        identity: options.identity === undefined ? 'me' : options.identity,\n        sanity: options.sanity,\n        after: options.after ? fromJS(options.after) : null,\n        before: options.before ? fromJS(options.before) : null\n    }, null);\n    return evaluate(tree, scope);\n}function canConstantEvaluate(node) {\n    switch (node.type) {\n        case 'Group':\n        case 'Value':\n        case 'Parameter':\n            return true;\n        case 'Pos':\n        case 'Neg':\n            return canConstantEvaluate(node.base);\n        case 'OpCall':\n            switch (node.op) {\n                case '+':\n                case '-':\n                case '*':\n                case '/':\n                case '%':\n                case '**':\n                    return canConstantEvaluate(node.left) && canConstantEvaluate(node.right);\n                default:\n                    return false;\n            }\n        default:\n            return false;\n    }\n}\nvar DUMMY_SCOPE = new Scope({}, NULL_VALUE, NULL_VALUE, { timestamp: new Date(0), identity: 'me', before: null, after: null }, null);\nfunction tryConstantEvaluate(node) {\n    if (!canConstantEvaluate(node)) {\n        return null;\n    }\n    return constantEvaluate(node);\n}\nfunction constantEvaluate(node) {\n    var value = evaluate(node, DUMMY_SCOPE, constantEvaluate);\n    if ('then' in value) {\n        throw new Error('BUG: constant evaluate should never return a promise');\n    }\n    return value;\n}var ESCAPE_SEQUENCE = {\n    \"'\": \"'\",\n    '\"': '\"',\n    '\\\\': '\\\\',\n    '/': '/',\n    b: '\\b',\n    f: '\\f',\n    n: '\\n',\n    r: '\\r',\n    t: '\\t'\n};\nfunction expandHex(str) {\n    var charCode = parseInt(str, 16);\n    return String.fromCharCode(charCode);\n}\nvar GroqQueryError = /** @class */ (function (_super) {\n    __extends(GroqQueryError, _super);\n    function GroqQueryError() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.name = 'GroqQueryError';\n        return _this;\n    }\n    return GroqQueryError;\n}(Error));\nvar EXPR_BUILDER = {\n    group: function (p) {\n        var inner = p.process(EXPR_BUILDER);\n        return {\n            type: 'Group',\n            base: inner\n        };\n    },\n    everything: function () {\n        return { type: 'Everything' };\n    },\n    \"this\": function () {\n        return { type: 'This' };\n    },\n    parent: function () {\n        return {\n            type: 'Parent',\n            n: 1\n        };\n    },\n    dblparent: function (p) {\n        var next = p.process(EXPR_BUILDER);\n        return {\n            type: 'Parent',\n            n: next.n + 1\n        };\n    },\n    traverse: function (p) {\n        var base = p.process(EXPR_BUILDER);\n        var traversalList = [];\n        while (p.getMark().name !== 'traversal_end') {\n            traversalList.push(p.process(TRAVERSE_BUILDER));\n        }\n        p.shift();\n        var traversal = null;\n        for (var i = traversalList.length - 1; i >= 0; i--) {\n            traversal = traversalList[i](traversal);\n        }\n        if (base.type === 'Everything' || base.type === 'Array' || base.type === 'PipeFuncCall') {\n            traversal = traverseArray(function (val) { return val; }, traversal);\n        }\n        if (traversal === null)\n            throw new Error('BUG: unexpected empty traversal');\n        return traversal.build(base);\n    },\n    this_attr: function (p) {\n        var name = p.processString();\n        if (name === 'null') {\n            return { type: 'Value', value: null };\n        }\n        if (name === 'true') {\n            return { type: 'Value', value: true };\n        }\n        if (name === 'false') {\n            return { type: 'Value', value: false };\n        }\n        return {\n            type: 'AccessAttribute',\n            name: name\n        };\n    },\n    neg: function (p) {\n        var base = p.process(EXPR_BUILDER);\n        return {\n            type: 'Neg',\n            base: base\n        };\n    },\n    pos: function (p) {\n        var base = p.process(EXPR_BUILDER);\n        return {\n            type: 'Pos',\n            base: base\n        };\n    },\n    add: function (p) {\n        var left = p.process(EXPR_BUILDER);\n        var right = p.process(EXPR_BUILDER);\n        return {\n            type: 'OpCall',\n            op: '+',\n            left: left,\n            right: right\n        };\n    },\n    sub: function (p) {\n        var left = p.process(EXPR_BUILDER);\n        var right = p.process(EXPR_BUILDER);\n        return {\n            type: 'OpCall',\n            op: '-',\n            left: left,\n            right: right\n        };\n    },\n    mul: function (p) {\n        var left = p.process(EXPR_BUILDER);\n        var right = p.process(EXPR_BUILDER);\n        return {\n            type: 'OpCall',\n            op: '*',\n            left: left,\n            right: right\n        };\n    },\n    div: function (p) {\n        var left = p.process(EXPR_BUILDER);\n        var right = p.process(EXPR_BUILDER);\n        return {\n            type: 'OpCall',\n            op: '/',\n            left: left,\n            right: right\n        };\n    },\n    mod: function (p) {\n        var left = p.process(EXPR_BUILDER);\n        var right = p.process(EXPR_BUILDER);\n        return {\n            type: 'OpCall',\n            op: '%',\n            left: left,\n            right: right\n        };\n    },\n    pow: function (p) {\n        var left = p.process(EXPR_BUILDER);\n        var right = p.process(EXPR_BUILDER);\n        return {\n            type: 'OpCall',\n            op: '**',\n            left: left,\n            right: right\n        };\n    },\n    comp: function (p) {\n        var left = p.process(EXPR_BUILDER);\n        var op = p.processString();\n        var right = p.process(EXPR_BUILDER);\n        return {\n            type: 'OpCall',\n            op: op,\n            left: left,\n            right: right\n        };\n    },\n    in_range: function (p) {\n        var base = p.process(EXPR_BUILDER);\n        var isInclusive = p.getMark().name === 'inc_range';\n        p.shift();\n        var left = p.process(EXPR_BUILDER);\n        var right = p.process(EXPR_BUILDER);\n        return {\n            type: 'InRange',\n            base: base,\n            left: left,\n            right: right,\n            isInclusive: isInclusive\n        };\n    },\n    str: function (p) {\n        var value = '';\n        // eslint-disable-next-line no-labels\n        loop: while (p.hasMark()) {\n            var mark = p.getMark();\n            switch (mark.name) {\n                case 'str_end':\n                    value += p.processStringEnd();\n                    // eslint-disable-next-line no-labels\n                    break loop;\n                case 'str_pause':\n                    value += p.processStringEnd();\n                    break;\n                case 'str_start':\n                    p.shift();\n                    break;\n                case 'single_escape': {\n                    var char = p.slice(1);\n                    p.shift();\n                    value += ESCAPE_SEQUENCE[char];\n                    break;\n                }\n                case 'unicode_hex':\n                    p.shift();\n                    value += expandHex(p.processStringEnd());\n                    break;\n                default:\n                    throw new Error(\"unexpected mark: \".concat(mark.name));\n            }\n        }\n        return { type: 'Value', value: value };\n    },\n    integer: function (p) {\n        var strValue = p.processStringEnd();\n        return {\n            type: 'Value',\n            value: Number(strValue)\n        };\n    },\n    float: function (p) {\n        var strValue = p.processStringEnd();\n        return {\n            type: 'Value',\n            value: Number(strValue)\n        };\n    },\n    sci: function (p) {\n        var strValue = p.processStringEnd();\n        return {\n            type: 'Value',\n            value: Number(strValue)\n        };\n    },\n    object: function (p) {\n        var attributes = [];\n        while (p.getMark().name !== 'object_end') {\n            attributes.push(p.process(OBJECT_BUILDER));\n        }\n        p.shift();\n        return {\n            type: 'Object',\n            attributes: attributes\n        };\n    },\n    array: function (p) {\n        var elements = [];\n        while (p.getMark().name !== 'array_end') {\n            var isSplat = false;\n            if (p.getMark().name === 'array_splat') {\n                isSplat = true;\n                p.shift();\n            }\n            var value = p.process(EXPR_BUILDER);\n            elements.push({\n                type: 'ArrayElement',\n                value: value,\n                isSplat: isSplat\n            });\n        }\n        p.shift();\n        return {\n            type: 'Array',\n            elements: elements\n        };\n    },\n    tuple: function (p) {\n        var members = [];\n        while (p.getMark().name !== 'tuple_end') {\n            members.push(p.process(EXPR_BUILDER));\n        }\n        p.shift();\n        return {\n            type: 'Tuple',\n            members: members\n        };\n    },\n    func_call: function (p) {\n        var namespace = 'global';\n        if (p.getMark().name === 'namespace') {\n            p.shift();\n            namespace = p.processString();\n        }\n        var name = p.processString();\n        if (namespace === 'global' && name === 'select') {\n            var result = {\n                type: 'Select',\n                alternatives: []\n            };\n            while (p.getMark().name !== 'func_args_end') {\n                if (p.getMark().name === 'pair') {\n                    if (result.fallback)\n                        throw new GroqQueryError(\"unexpected argument to select()\");\n                    p.shift();\n                    var condition = p.process(EXPR_BUILDER);\n                    var value = p.process(EXPR_BUILDER);\n                    result.alternatives.push({\n                        type: 'SelectAlternative',\n                        condition: condition,\n                        value: value\n                    });\n                }\n                else {\n                    if (result.fallback)\n                        throw new GroqQueryError(\"unexpected argument to select()\");\n                    var value = p.process(EXPR_BUILDER);\n                    result.fallback = value;\n                }\n            }\n            p.shift();\n            return result;\n        }\n        var args = [];\n        while (p.getMark().name !== 'func_args_end') {\n            if (argumentShouldBeSelector(namespace, name, args.length)) {\n                // Since the diff/delta functions aren't validated yet we only want to validate the selector\n                // being used. We expect the null valued arg to throw an error at evaluation time.\n                p.process(SELECTOR_BUILDER);\n                args.push({ type: 'Selector' });\n            }\n            else {\n                args.push(p.process(EXPR_BUILDER));\n            }\n        }\n        p.shift();\n        if (namespace === 'global' && (name === 'before' || name === 'after')) {\n            if (p.parseOptions.mode === 'delta') {\n                return {\n                    type: 'Context',\n                    key: name\n                };\n            }\n        }\n        if (namespace === 'global' && name === 'boost' && !p.allowBoost)\n            throw new GroqQueryError('unexpected boost');\n        var funcs = namespaces[namespace];\n        if (!funcs) {\n            throw new GroqQueryError(\"Undefined namespace: \".concat(namespace));\n        }\n        var func = funcs[name];\n        if (!func) {\n            throw new GroqQueryError(\"Undefined function: \".concat(name));\n        }\n        if (func.arity !== undefined) {\n            validateArity(name, func.arity, args.length);\n        }\n        if (func.mode !== undefined && func.mode !== p.parseOptions.mode) {\n            throw new GroqQueryError(\"Undefined function: \".concat(name));\n        }\n        return {\n            type: 'FuncCall',\n            func: func,\n            name: name,\n            args: args\n        };\n    },\n    pipecall: function (p) {\n        var base = p.process(EXPR_BUILDER);\n        p.shift(); // Remove the func_call\n        var namespace = 'global';\n        if (p.getMark().name === 'namespace') {\n            p.shift();\n            namespace = p.processString();\n        }\n        if (namespace !== 'global') {\n            throw new GroqQueryError(\"Undefined namespace: \".concat(namespace));\n        }\n        var name = p.processString();\n        var args = [];\n        var oldAllowBoost = p.allowBoost;\n        if (name === 'score') {\n            // Only allow boost inside a score expression\n            p.allowBoost = true;\n        }\n        for (;;) {\n            var markName = p.getMark().name;\n            if (markName === 'func_args_end') {\n                break;\n            }\n            if (name === 'order') {\n                if (markName === 'asc') {\n                    p.shift();\n                    args.push({ type: 'Asc', base: p.process(EXPR_BUILDER) });\n                    continue;\n                }\n                else if (markName === 'desc') {\n                    p.shift();\n                    args.push({ type: 'Desc', base: p.process(EXPR_BUILDER) });\n                    continue;\n                }\n            }\n            args.push(p.process(EXPR_BUILDER));\n        }\n        p.shift();\n        p.allowBoost = oldAllowBoost;\n        var func = pipeFunctions[name];\n        if (!func) {\n            throw new GroqQueryError(\"Undefined pipe function: \".concat(name));\n        }\n        if (func.arity) {\n            validateArity(name, func.arity, args.length);\n        }\n        return {\n            type: 'PipeFuncCall',\n            func: func,\n            base: base,\n            name: name,\n            args: args\n        };\n    },\n    pair: function (p) {\n        throw new GroqQueryError(\"unexpected =>\");\n    },\n    and: function (p) {\n        var left = p.process(EXPR_BUILDER);\n        var right = p.process(EXPR_BUILDER);\n        return {\n            type: 'And',\n            left: left,\n            right: right\n        };\n    },\n    or: function (p) {\n        var left = p.process(EXPR_BUILDER);\n        var right = p.process(EXPR_BUILDER);\n        return {\n            type: 'Or',\n            left: left,\n            right: right\n        };\n    },\n    not: function (p) {\n        var base = p.process(EXPR_BUILDER);\n        return {\n            type: 'Not',\n            base: base\n        };\n    },\n    asc: function (p) {\n        throw new GroqQueryError('unexpected asc');\n    },\n    desc: function (p) {\n        throw new GroqQueryError('unexpected desc');\n    },\n    param: function (p) {\n        var name = p.processString();\n        if (p.parseOptions.params && p.parseOptions.params.hasOwnProperty(name)) {\n            return {\n                type: 'Value',\n                value: p.parseOptions.params[name]\n            };\n        }\n        return {\n            type: 'Parameter',\n            name: name\n        };\n    }\n};\nvar OBJECT_BUILDER = {\n    object_expr: function (p) {\n        if (p.getMark().name === 'pair') {\n            p.shift();\n            var condition = p.process(EXPR_BUILDER);\n            var value_1 = p.process(EXPR_BUILDER);\n            return {\n                type: 'ObjectConditionalSplat',\n                condition: condition,\n                value: value_1\n            };\n        }\n        var value = p.process(EXPR_BUILDER);\n        return {\n            type: 'ObjectAttributeValue',\n            name: extractPropertyKey(value),\n            value: value\n        };\n    },\n    object_pair: function (p) {\n        var name = p.process(EXPR_BUILDER);\n        if (name.type !== 'Value')\n            throw new Error('name must be string');\n        var value = p.process(EXPR_BUILDER);\n        return {\n            type: 'ObjectAttributeValue',\n            name: name.value,\n            value: value\n        };\n    },\n    object_splat: function (p) {\n        var value = p.process(EXPR_BUILDER);\n        return {\n            type: 'ObjectSplat',\n            value: value\n        };\n    },\n    object_splat_this: function () {\n        return {\n            type: 'ObjectSplat',\n            value: { type: 'This' }\n        };\n    }\n};\nvar TRAVERSE_BUILDER = {\n    square_bracket: function (p) {\n        var expr = p.process(EXPR_BUILDER);\n        var value = tryConstantEvaluate(expr);\n        if (value && value.type === 'number') {\n            return function (right) {\n                return traverseElement(function (base) { return ({ type: 'AccessElement', base: base, index: value.data }); }, right);\n            };\n        }\n        if (value && value.type === 'string') {\n            return function (right) {\n                return traversePlain(function (base) { return ({ type: 'AccessAttribute', base: base, name: value.data }); }, right);\n            };\n        }\n        return function (right) {\n            return traverseArray(function (base) { return ({\n                type: 'Filter',\n                base: base,\n                expr: expr\n            }); }, right);\n        };\n    },\n    slice: function (p) {\n        var isInclusive = p.getMark().name === 'inc_range';\n        p.shift();\n        var left = p.process(EXPR_BUILDER);\n        var right = p.process(EXPR_BUILDER);\n        var leftValue = tryConstantEvaluate(left);\n        var rightValue = tryConstantEvaluate(right);\n        if (!leftValue || !rightValue || leftValue.type !== 'number' || rightValue.type !== 'number') {\n            throw new GroqQueryError('slicing must use constant numbers');\n        }\n        return function (rhs) {\n            return traverseArray(function (base) { return ({\n                type: 'Slice',\n                base: base,\n                left: leftValue.data,\n                right: rightValue.data,\n                isInclusive: isInclusive\n            }); }, rhs);\n        };\n    },\n    projection: function (p) {\n        var obj = p.process(EXPR_BUILDER);\n        return function (right) {\n            return traverseProjection(function (base) { return ({ type: 'Projection', base: base, expr: obj }); }, right);\n        };\n    },\n    attr_access: function (p) {\n        var name = p.processString();\n        return function (right) { return traversePlain(function (base) { return ({ type: 'AccessAttribute', base: base, name: name }); }, right); };\n    },\n    deref: function (p) {\n        var attr = null;\n        if (p.getMark().name === 'deref_attr') {\n            p.shift();\n            attr = p.processString();\n        }\n        var wrap = function (base) {\n            return attr ? { type: 'AccessAttribute', base: base, name: attr } : base;\n        };\n        return function (right) {\n            return traversePlain(function (base) {\n                return wrap({\n                    type: 'Deref',\n                    base: base\n                });\n            }, right);\n        };\n    },\n    array_postfix: function (p) {\n        return function (right) { return traverseArray(function (base) { return ({ type: 'ArrayCoerce', base: base }); }, right); };\n    }\n};\nvar SELECTOR_BUILDER = {\n    group: function (p) {\n        p.process(SELECTOR_BUILDER);\n        return null;\n    },\n    everything: function () {\n        throw new Error('Invalid selector syntax');\n    },\n    \"this\": function () {\n        throw new Error('Invalid selector syntax');\n    },\n    parent: function () {\n        throw new Error('Invalid selector syntax');\n    },\n    dblparent: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    traverse: function (p) {\n        p.process(SELECTOR_BUILDER);\n        while (p.getMark().name !== 'traversal_end') {\n            p.process(TRAVERSE_BUILDER);\n        }\n        p.shift();\n        return null;\n    },\n    this_attr: function (p) {\n        p.processString();\n        return null;\n    },\n    neg: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    pos: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    add: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    sub: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    mul: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    div: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    mod: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    pow: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    comp: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    in_range: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    str: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    integer: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    float: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    sci: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    object: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    array: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    tuple: function (p) {\n        // This should only throw an error until we add support for tuples in selectors.\n        throw new Error('Invalid selector syntax');\n    },\n    func_call: function (p, mark) {\n        var func = EXPR_BUILDER.func_call(p, mark);\n        if (func.name === 'anywhere' && func.args.length === 1)\n            return null;\n        throw new Error('Invalid selector syntax');\n    },\n    pipecall: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    pair: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    and: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    or: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    not: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    asc: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    desc: function (p) {\n        throw new Error('Invalid selector syntax');\n    },\n    param: function (p) {\n        throw new Error('Invalid selector syntax');\n    }\n};\nfunction extractPropertyKey(node) {\n    if (node.type === 'AccessAttribute' && !node.base) {\n        return node.name;\n    }\n    if (node.type === 'Deref' ||\n        node.type === 'Map' ||\n        node.type === 'Projection' ||\n        node.type === 'Slice' ||\n        node.type === 'Filter' ||\n        node.type === 'AccessElement' ||\n        node.type === 'ArrayCoerce') {\n        return extractPropertyKey(node.base);\n    }\n    throw new GroqQueryError(\"Cannot determine property key for type: \".concat(node.type));\n}\nfunction validateArity(name, arity, count) {\n    if (typeof arity === 'number') {\n        if (count !== arity) {\n            throw new GroqQueryError(\"Incorrect number of arguments to function \".concat(name, \"(). Expected \").concat(arity, \", got \").concat(count, \".\"));\n        }\n    }\n    else if (arity) {\n        if (!arity(count)) {\n            throw new GroqQueryError(\"Incorrect number of arguments to function \".concat(name, \"().\"));\n        }\n    }\n}\nfunction argumentShouldBeSelector(namespace, functionName, argCount) {\n    var functionsRequiringSelectors = ['changedAny', 'changedOnly'];\n    return namespace == 'diff' && argCount == 2 && functionsRequiringSelectors.includes(functionName);\n}\nvar GroqSyntaxError = /** @class */ (function (_super) {\n    __extends(GroqSyntaxError, _super);\n    function GroqSyntaxError(position) {\n        var _this = _super.call(this, \"Syntax error in GROQ query at position \".concat(position)) || this;\n        _this.name = 'GroqSyntaxError';\n        _this.position = position;\n        return _this;\n    }\n    return GroqSyntaxError;\n}(Error));\n/**\n * Parses a GROQ query and returns a tree structure.\n */\nfunction parse(input, options) {\n    if (options === void 0) { options = {}; }\n    var result = parse$1(input);\n    if (result.type === 'error') {\n        throw new GroqSyntaxError(result.position);\n    }\n    var processor = new MarkProcessor(input, result.marks, options);\n    return processor.process(EXPR_BUILDER);\n}exports.evaluate=evaluateQuery;exports.parse=parse;Object.defineProperty(exports,'__esModule',{value:true});}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3JvcS1qcy9kaXN0LzEudW1kLmNqcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLEtBQXNELFlBQVksQ0FBZ0ksRUFBRSwwQkFBMEIsYUFBYTtBQUMxUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUNuRiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkJBQTZCLDBCQUEwQixjQUFjLHFCQUFxQjtBQUN4RyxpQkFBaUIsb0RBQW9ELHFFQUFxRSxjQUFjO0FBQ3hKLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLG1DQUFtQyxTQUFTO0FBQzVDLG1DQUFtQyxXQUFXLFVBQVU7QUFDeEQsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQSw4R0FBOEcsT0FBTztBQUNySCxpRkFBaUYsaUJBQWlCO0FBQ2xHLHlEQUF5RCxnQkFBZ0IsUUFBUTtBQUNqRiwrQ0FBK0MsZ0JBQWdCLGdCQUFnQjtBQUMvRTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsVUFBVSxZQUFZLGFBQWEsU0FBUyxVQUFVO0FBQ3RELG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUZBQXVGLGNBQWM7QUFDdEgsdUJBQXVCLGdDQUFnQyxxQ0FBcUMsMkNBQTJDO0FBQ3ZJLDRCQUE0QixNQUFNLGlCQUFpQixZQUFZO0FBQy9ELHVCQUF1QjtBQUN2Qiw4QkFBOEI7QUFDOUIsNkJBQTZCO0FBQzdCLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHLHVGQUF1RixjQUFjO0FBQ2hOLHVCQUF1Qiw4QkFBOEIsZ0RBQWdELHdEQUF3RDtBQUM3Siw2Q0FBNkMsc0NBQXNDLFVBQVUsbUJBQW1CLElBQUk7QUFDcEgsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLElBQUkseUJBQXlCLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxtQkFBbUIsRUFBRSxJQUFJLEVBQUU7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGdCQUFnQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSTtBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxJQUFJO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGlDQUFpQyxHQUFHO0FBQ3JDLDhDQUE4QyxHQUFHO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyx5QkFBeUI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDJCQUEyQixzQ0FBc0Msd0JBQXdCLE9BQU87QUFDdkk7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLCtGQUErRjtBQUN0STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLHNDQUFzQztBQUM3RztBQUNBO0FBQ0Esa0RBQWtELHFCQUFxQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHdCQUF3QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsOENBQThDLHFCQUFxQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxnQkFBZ0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELG9CQUFvQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsd0VBQXdFLGNBQWM7QUFDdEY7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsZ0JBQWdCLG9CQUFvQjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCw2QkFBNkI7QUFDL0U7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQ0FBZ0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdDQUFnQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQ0FBa0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBLHNCQUFzQixpQ0FBaUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0NBQWtDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0NBQWdDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2QkFBNkI7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1DQUFtQztBQUMzRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsaUNBQWlDO0FBQ3JELFFBQVE7QUFDUixnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0NBQXNDO0FBQzFEO0FBQ0E7QUFDQSxrQkFBa0IsbUNBQW1DO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQ0FBaUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVDQUF1QztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0NBQWtDO0FBQzdDLFdBQVcsc0NBQXNDO0FBQ2pELFdBQVcsaUNBQWlDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBOztBQUVBO0FBQ0EsV0FBVyx5QkFBeUI7QUFDcEMsV0FBVyxtQ0FBbUM7QUFDOUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzQ0FBc0M7QUFDckQsZUFBZSxrQ0FBa0M7QUFDakQsZUFBZSxpQ0FBaUM7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIscUNBQXFDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUNBQXFDO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQ0FBaUM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlDQUFpQztBQUM1RCx3QkFBd0IsK0JBQStCLEdBQUcsdUNBQXVDO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQ0FBZ0M7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdDQUFnQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdDQUFnQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdDQUFnQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0NBQWdDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQ0FBZ0M7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUNBQWlDO0FBQ3hELG9CQUFvQiwrQkFBK0IsR0FBRyxrQ0FBa0M7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLCtCQUErQjtBQUN4RDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIscUNBQXFDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdDQUFnQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQ0FBaUM7QUFDeEQsb0JBQW9CLCtCQUErQixHQUFHLHVDQUF1QztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUNBQWlDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0NBQWdDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QixxQ0FBcUM7QUFDbEUsb0NBQW9DLCtCQUErQjtBQUNuRTtBQUNBLGNBQWM7QUFDZDtBQUNBLDZCQUE2QixpQ0FBaUM7QUFDOUQsMEJBQTBCLCtCQUErQixHQUFHLHVDQUF1QztBQUNuRztBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlDQUFpQztBQUM1RCx3QkFBd0IsK0JBQStCLEdBQUcsdUNBQXVDO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyx3Q0FBd0M7QUFDbkQsV0FBVyxvQ0FBb0M7QUFDL0MsV0FBVyxpQ0FBaUM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qzs7QUFFQSxvQkFBb0Isa0NBQWtDO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVDQUF1QztBQUNsRCxXQUFXLGtDQUFrQztBQUM3QyxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMENBQTBDO0FBQzdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQSxhQUFhLGtDQUFrQztBQUMvQyxhQUFhLCtCQUErQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQSxpQkFBaUIsMkNBQTJDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLDhCQUE4Qix1Q0FBdUM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLDRCQUE0Qix1Q0FBdUM7QUFDbkU7QUFDQTtBQUNBOztBQUVBLFVBQVU7QUFDVjs7QUFFQTtBQUNBOztBQUVBLGNBQWMsc0NBQXNDOztBQUVwRDtBQUNBLGdCQUFnQixzQ0FBc0M7QUFDdEQsZ0JBQWdCLGtDQUFrQyxHQUFHLGlDQUFpQztBQUN0RjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLGdCQUFnQiw2QkFBNkIsR0FBRywyQ0FBMkM7QUFDM0Y7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxJQUFJO0FBQ0osZ0JBQWdCLGtDQUFrQyxHQUFHLGlDQUFpQztBQUN0RjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0EsY0FBYyx5Q0FBeUM7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQiw4QkFBOEI7QUFDOUM7O0FBRUEsd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLG9CQUFvQix3Q0FBd0M7QUFDNUQ7QUFDQTtBQUNBLFFBQVE7QUFDUixvQkFBb0IsNkNBQTZDO0FBQ2pFO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1Q0FBdUM7QUFDM0Q7QUFDQTtBQUNBLFFBQVE7QUFDUiw4QkFBOEIsbUNBQW1DO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQixZQUFZO0FBQ1o7O0FBRUE7QUFDQSxjQUFjLGtDQUFrQztBQUNoRCxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJCQUEyQjtBQUM3QyxnQkFBZ0I7QUFDaEIsa0NBQWtDOztBQUVsQztBQUNBO0FBQ0Esb0JBQW9CLCtCQUErQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQ0FBaUM7QUFDckQ7QUFDQSxpQ0FBaUM7QUFDakMsd0JBQXdCLHVDQUF1QztBQUMvRCxnQ0FBZ0M7QUFDaEMsd0JBQXdCLHVDQUF1QztBQUMvRCxZQUFZO0FBQ1osd0JBQXdCLHVDQUF1QztBQUMvRCx3QkFBd0IsMkNBQTJDO0FBQ25FO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysc0JBQXNCLHlDQUF5QztBQUMvRDtBQUNBO0FBQ0Esb0JBQW9CLHFDQUFxQztBQUN6RDtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixVQUFVLHVDQUF1QyxjQUFjLEdBQUc7QUFDL0Y7QUFDQTtBQUNBLDZCQUE2QixVQUFVLDJDQUEyQyxjQUFjLEdBQUc7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDJDQUEyQyxlQUFlO0FBQzFELDJDQUEyQyxlQUFlO0FBQzFELDJDQUEyQyxlQUFlO0FBQzFELDRDQUE0Qyx3QkFBd0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSTtBQUNMLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxzREFBc0QsWUFBWTtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLElBQUksSUFBSTtBQUNyQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3QjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLGlDQUFpQztBQUNqQyw2QkFBNkI7QUFDN0I7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxpQ0FBaUM7QUFDakMsNkJBQTZCO0FBQzdCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDRCQUE0QixtRUFBbUU7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxhQUFhO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDRDQUE0QztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw2Q0FBNkM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxVQUFVLHNEQUFzRCxJQUFJO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFVBQVUsdURBQXVELElBQUk7QUFDNUg7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLGFBQWEsSUFBSTtBQUNqQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLElBQUk7QUFDakI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFVBQVUsMkNBQTJDLElBQUk7QUFDakg7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtDQUFrQyx1Q0FBdUMsVUFBVSxpREFBaUQsSUFBSTtBQUN4SSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0RBQWtEO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQSxrQ0FBa0MsdUNBQXVDLFVBQVUsaUNBQWlDLElBQUk7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsK0JBQStCLG9CQUFvQiw0Q0FBNEMsV0FBVyxHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ncm9xLWpzL2Rpc3QvMS51bWQuY2pzPzc5ZjMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKGcsZil7dHlwZW9mIGV4cG9ydHM9PT0nb2JqZWN0JyYmdHlwZW9mIG1vZHVsZSE9PSd1bmRlZmluZWQnP2YoZXhwb3J0cyk6dHlwZW9mIGRlZmluZT09PSdmdW5jdGlvbicmJmRlZmluZS5hbWQ/ZGVmaW5lKFsnZXhwb3J0cyddLGYpOihnPXR5cGVvZiBnbG9iYWxUaGlzIT09J3VuZGVmaW5lZCc/Z2xvYmFsVGhpczpnfHxzZWxmLGYoZ1tcIjFcIl09e30pKTt9KSh0aGlzLChmdW5jdGlvbihleHBvcnRzKXsndXNlIHN0cmljdCc7LyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXQodikge1xyXG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn12YXIgTWFya1Byb2Nlc3NvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXJrUHJvY2Vzc29yKHN0cmluZywgbWFya3MsIHBhcnNlT3B0aW9ucykge1xuICAgICAgICB0aGlzLmFsbG93Qm9vc3QgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgICAgIHRoaXMubWFya3MgPSBtYXJrcztcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIHRoaXMucGFyc2VPcHRpb25zID0gcGFyc2VPcHRpb25zO1xuICAgIH1cbiAgICBNYXJrUHJvY2Vzc29yLnByb3RvdHlwZS5oYXNNYXJrID0gZnVuY3Rpb24gKHBvcykge1xuICAgICAgICBpZiAocG9zID09PSB2b2lkIDApIHsgcG9zID0gMDsgfVxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleCArIHBvcyA8IHRoaXMubWFya3MubGVuZ3RoO1xuICAgIH07XG4gICAgTWFya1Byb2Nlc3Nvci5wcm90b3R5cGUuZ2V0TWFyayA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgaWYgKHBvcyA9PT0gdm9pZCAwKSB7IHBvcyA9IDA7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMubWFya3NbdGhpcy5pbmRleCArIHBvc107XG4gICAgfTtcbiAgICBNYXJrUHJvY2Vzc29yLnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbmRleCArPSAxO1xuICAgIH07XG4gICAgTWFya1Byb2Nlc3Nvci5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7XG4gICAgICAgIHZhciBtYXJrID0gdGhpcy5tYXJrc1t0aGlzLmluZGV4XTtcbiAgICAgICAgdGhpcy5zaGlmdCgpO1xuICAgICAgICB2YXIgZnVuYyA9IHZpc2l0b3JbbWFyay5uYW1lXTtcbiAgICAgICAgaWYgKCFmdW5jKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGhhbmRsZXI6IFwiLmNvbmNhdChtYXJrLm5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHZpc2l0b3IsIHRoaXMsIG1hcmspO1xuICAgIH07XG4gICAgTWFya1Byb2Nlc3Nvci5wcm90b3R5cGUucHJvY2Vzc1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zaGlmdCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzU3RyaW5nRW5kKCk7XG4gICAgfTtcbiAgICBNYXJrUHJvY2Vzc29yLnByb3RvdHlwZS5wcm9jZXNzU3RyaW5nRW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJldiA9IHRoaXMubWFya3NbdGhpcy5pbmRleCAtIDFdO1xuICAgICAgICB2YXIgY3VyciA9IHRoaXMubWFya3NbdGhpcy5pbmRleF07XG4gICAgICAgIHRoaXMuc2hpZnQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKHByZXYucG9zaXRpb24sIGN1cnIucG9zaXRpb24pO1xuICAgIH07XG4gICAgTWFya1Byb2Nlc3Nvci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAobGVuKSB7XG4gICAgICAgIHZhciBwb3MgPSB0aGlzLm1hcmtzW3RoaXMuaW5kZXhdLnBvc2l0aW9uO1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UocG9zLCBwb3MgKyBsZW4pO1xuICAgIH07XG4gICAgcmV0dXJuIE1hcmtQcm9jZXNzb3I7XG59KCkpO3ZhciBSRkMzMzM5X1JFR0VYID0gL15cXGR7NH0tXFxkezJ9LVxcZHsyfVRcXGR7Mn06XFxkezJ9OlxcZHsyfShcXC5cXGQrKT8oWnwoWy0rXVxcZHsyfTpcXGR7Mn0pKSQvO1xuZnVuY3Rpb24gcGFyc2VSRkMzMzM5KHN0cikge1xuICAgIGlmIChSRkMzMzM5X1JFR0VYLnRlc3Qoc3RyKSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoc3RyKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBmb3JtYXRSRkMzMzM5KGQpIHtcbiAgICB2YXIgeWVhciA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDRnVsbFllYXIoKSwgNCk7XG4gICAgdmFyIG1vbnRoID0gYWRkTGVhZGluZ1plcm8oZC5nZXRVVENNb250aCgpICsgMSwgMik7XG4gICAgdmFyIGRheSA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDRGF0ZSgpLCAyKTtcbiAgICB2YXIgaG91ciA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDSG91cnMoKSwgMik7XG4gICAgdmFyIG1pbnV0ZSA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDTWludXRlcygpLCAyKTtcbiAgICB2YXIgc2Vjb25kID0gYWRkTGVhZGluZ1plcm8oZC5nZXRVVENTZWNvbmRzKCksIDIpO1xuICAgIHZhciBmcmFjdGlvbmFsU2Vjb25kID0gJyc7XG4gICAgdmFyIG1pbGxpcyA9IGQuZ2V0TWlsbGlzZWNvbmRzKCk7XG4gICAgaWYgKG1pbGxpcyAhPSAwKSB7XG4gICAgICAgIGZyYWN0aW9uYWxTZWNvbmQgPSBcIi5cIi5jb25jYXQoYWRkTGVhZGluZ1plcm8obWlsbGlzLCAzKSk7XG4gICAgfVxuICAgIHJldHVybiBcIlwiLmNvbmNhdCh5ZWFyLCBcIi1cIikuY29uY2F0KG1vbnRoLCBcIi1cIikuY29uY2F0KGRheSwgXCJUXCIpLmNvbmNhdChob3VyLCBcIjpcIikuY29uY2F0KG1pbnV0ZSwgXCI6XCIpLmNvbmNhdChzZWNvbmQpLmNvbmNhdChmcmFjdGlvbmFsU2Vjb25kLCBcIlpcIik7XG59XG5mdW5jdGlvbiBhZGRMZWFkaW5nWmVybyhudW0sIHRhcmdldExlbmd0aCkge1xuICAgIHZhciBzdHIgPSBudW0udG9TdHJpbmcoKTtcbiAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHRhcmdldExlbmd0aCkge1xuICAgICAgICBzdHIgPSBcIjBcIi5jb25jYXQoc3RyKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1mdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpO1xufVxuZnVuY3Rpb24gcGF0aFJlZ0V4cChwYXR0ZXJuKSB7XG4gICAgdmFyIHJlID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHBhdHRlcm4uc3BsaXQoJy4nKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBfYVtfaV07XG4gICAgICAgIGlmIChwYXJ0ID09PSAnKicpIHtcbiAgICAgICAgICAgIHJlLnB1c2goJ1teLl0rJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFydCA9PT0gJyoqJykge1xuICAgICAgICAgICAgcmUucHVzaCgnLionKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlLnB1c2goZXNjYXBlUmVnRXhwKHBhcnQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFJlZ0V4cChcIl5cIi5jb25jYXQocmUuam9pbignLicpLCBcIiRcIikpO1xufVxudmFyIFBhdGggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGF0aChwYXR0ZXJuKSB7XG4gICAgICAgIHRoaXMucGF0dGVybiA9IHBhdHRlcm47XG4gICAgICAgIHRoaXMucGF0dGVyblJlID0gcGF0aFJlZ0V4cChwYXR0ZXJuKTtcbiAgICB9XG4gICAgUGF0aC5wcm90b3R5cGUubWF0Y2hlcyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0dGVyblJlLnRlc3Qoc3RyKTtcbiAgICB9O1xuICAgIFBhdGgucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0dGVybjtcbiAgICB9O1xuICAgIHJldHVybiBQYXRoO1xufSgpKTt2YXIgU3RyZWFtVmFsdWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RyZWFtVmFsdWUoZ2VuZXJhdG9yKSB7XG4gICAgICAgIHRoaXMudHlwZSA9ICdzdHJlYW0nO1xuICAgICAgICB0aGlzLmdlbmVyYXRvciA9IGdlbmVyYXRvcjtcbiAgICAgICAgdGhpcy50aWNrZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmlzRG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgICBTdHJlYW1WYWx1ZS5wcm90b3R5cGUuaXNBcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBTdHJlYW1WYWx1ZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgX2IsIF9jLCB2YWx1ZSwgX2QsIF9lLCBlXzFfMTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2YpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9mLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2YubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfZi50cnlzLnB1c2goWzEsIDcsIDgsIDEzXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYiA9IF9fYXN5bmNWYWx1ZXModGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZi5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFs0IC8qeWllbGQqLywgX2IubmV4dCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoX2MgPSBfZi5zZW50KCksICFfYy5kb25lKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2UgPSAoX2QgPSByZXN1bHQpLnB1c2g7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB2YWx1ZS5nZXQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9lLmFwcGx5KF9kLCBbX2Yuc2VudCgpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZi5sYWJlbCA9IDU7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIFszIC8qYnJlYWsqLywgMTNdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICBlXzFfMSA9IF9mLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxM107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9mLnRyeXMucHVzaChbOCwgLCAxMSwgMTJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iW1wicmV0dXJuXCJdKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDEwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9hLmNhbGwoX2IpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Yuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2YubGFiZWwgPSAxMDtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDogcmV0dXJuIFszIC8qYnJlYWsqLywgMTJdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjogcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3RyZWFtVmFsdWUucHJvdG90eXBlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiBfYSgpIHtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoaSA8IHRoaXMuZGF0YS5sZW5ndGgpKSByZXR1cm4gWzMgLypicmVhayovLCA2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQodGhpcy5kYXRhW2ldKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFs0IC8qeWllbGQqLywgX2Iuc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA1O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzRG9uZSkgcmV0dXJuIFszIC8qYnJlYWsqLywgOF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KHZvaWQgMCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6IHJldHVybiBbMiAvKnJldHVybiovLCBfYi5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDg6IHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQodGhpcy5fbmV4dFRpY2soKSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFN0cmVhbVZhbHVlLnByb3RvdHlwZS5fbmV4dFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLnRpY2tlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGlja2VyO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJyZW50UmVzb2x2ZXI7XG4gICAgICAgIHZhciBzZXR1cFRpY2tlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnRpY2tlciA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFJlc29sdmVyID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgdGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGN1cnJlbnRSZXNvbHZlcigpO1xuICAgICAgICAgICAgc2V0dXBUaWNrZXIoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGZldGNoID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgdmFsdWUsIGVfMl8xO1xuICAgICAgICAgICAgdmFyIGVfMiwgX2M7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9kKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfZC5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfZC50cnlzLnB1c2goWzAsIDUsIDYsIDExXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IF9fYXN5bmNWYWx1ZXModGhpcy5nZW5lcmF0b3IoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZC5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFs0IC8qeWllbGQqLywgX2EubmV4dCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoX2IgPSBfZC5zZW50KCksICFfYi5kb25lKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF9iLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGljaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2QubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMyAvKmJyZWFrKi8sIDExXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgZV8yXzEgPSBfZC5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlXzIgPSB7IGVycm9yOiBlXzJfMSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTFdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICBfZC50cnlzLnB1c2goWzYsICwgOSwgMTBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKF9iICYmICFfYi5kb25lICYmIChfYyA9IF9hW1wicmV0dXJuXCJdKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX2MuY2FsbChfYSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICBfZC5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZC5sYWJlbCA9IDg7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgODogcmV0dXJuIFszIC8qYnJlYWsqLywgMTBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOiByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0RvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGljaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTsgfTtcbiAgICAgICAgc2V0dXBUaWNrZXIoKTtcbiAgICAgICAgZmV0Y2goKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudGlja2VyO1xuICAgIH07XG4gICAgcmV0dXJuIFN0cmVhbVZhbHVlO1xufSgpKTt2YXIgU3RhdGljVmFsdWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RhdGljVmFsdWUoZGF0YSwgdHlwZSkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICBTdGF0aWNWYWx1ZS5wcm90b3R5cGUuaXNBcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gJ2FycmF5JztcbiAgICB9O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZXF1aXJlLWF3YWl0XG4gICAgU3RhdGljVmFsdWUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLmRhdGFdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3RhdGljVmFsdWUucHJvdG90eXBlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5kYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBfaSwgZGF0YV8xLCBlbGVtZW50O1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pID0gMCwgZGF0YV8xID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoX2kgPCBkYXRhXzEubGVuZ3RoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IGRhdGFfMVtfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZnJvbUpTKGVsZW1lbnQpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkodGhpcy5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgaXRlcmF0ZSBvdmVyOiBcIi5jb25jYXQodGhpcy50eXBlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGljVmFsdWU7XG59KCkpO1xudmFyIE5VTExfVkFMVUUgPSBuZXcgU3RhdGljVmFsdWUobnVsbCwgJ251bGwnKTtcbnZhciBUUlVFX1ZBTFVFID0gbmV3IFN0YXRpY1ZhbHVlKHRydWUsICdib29sZWFuJyk7XG52YXIgRkFMU0VfVkFMVUUgPSBuZXcgU3RhdGljVmFsdWUoZmFsc2UsICdib29sZWFuJyk7XG52YXIgRGF0ZVRpbWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGF0ZVRpbWUoZGF0ZSkge1xuICAgICAgICB0aGlzLmRhdGUgPSBkYXRlO1xuICAgIH1cbiAgICBEYXRlVGltZS5wYXJzZVRvVmFsdWUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHZhciBkYXRlID0gcGFyc2VSRkMzMzM5KHN0cik7XG4gICAgICAgIGlmIChkYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0YXRpY1ZhbHVlKG5ldyBEYXRlVGltZShkYXRlKSwgJ2RhdGV0aW1lJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfTtcbiAgICBEYXRlVGltZS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGUuZ2V0VGltZSgpID09IG90aGVyLmRhdGUuZ2V0VGltZSgpO1xuICAgIH07XG4gICAgRGF0ZVRpbWUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChzZWNzKSB7XG4gICAgICAgIHZhciBjb3B5ID0gbmV3IERhdGUodGhpcy5kYXRlLmdldFRpbWUoKSk7XG4gICAgICAgIGNvcHkuc2V0VGltZShjb3B5LmdldFRpbWUoKSArIHNlY3MgKiAxMDAwKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlVGltZShjb3B5KTtcbiAgICB9O1xuICAgIERhdGVUaW1lLnByb3RvdHlwZS5kaWZmZXJlbmNlID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5kYXRlLmdldFRpbWUoKSAtIG90aGVyLmRhdGUuZ2V0VGltZSgpKSAvIDEwMDA7XG4gICAgfTtcbiAgICBEYXRlVGltZS5wcm90b3R5cGUuY29tcGFyZVRvID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGUuZ2V0VGltZSgpIC0gb3RoZXIuZGF0ZS5nZXRUaW1lKCk7XG4gICAgfTtcbiAgICBEYXRlVGltZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXRSRkMzMzM5KHRoaXMuZGF0ZSk7XG4gICAgfTtcbiAgICBEYXRlVGltZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICAgIH07XG4gICAgcmV0dXJuIERhdGVUaW1lO1xufSgpKTtcbmZ1bmN0aW9uIGZyb21OdW1iZXIobnVtKSB7XG4gICAgaWYgKE51bWJlci5pc0Zpbml0ZShudW0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RhdGljVmFsdWUobnVtLCAnbnVtYmVyJyk7XG4gICAgfVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xufVxuZnVuY3Rpb24gZnJvbVN0cmluZyhzdHIpIHtcbiAgICByZXR1cm4gbmV3IFN0YXRpY1ZhbHVlKHN0ciwgJ3N0cmluZycpO1xufVxuZnVuY3Rpb24gZnJvbURhdGVUaW1lKGR0KSB7XG4gICAgcmV0dXJuIG5ldyBTdGF0aWNWYWx1ZShkdCwgJ2RhdGV0aW1lJyk7XG59XG5mdW5jdGlvbiBmcm9tUGF0aChwYXRoKSB7XG4gICAgcmV0dXJuIG5ldyBTdGF0aWNWYWx1ZShwYXRoLCAncGF0aCcpO1xufVxuZnVuY3Rpb24gaXNJdGVyYXRvcihvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBvYmoubmV4dCA9PT0gJ2Z1bmN0aW9uJztcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG5mdW5jdGlvbiBmcm9tSlModmFsKSB7XG4gICAgaWYgKGlzSXRlcmF0b3IodmFsKSkge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbVZhbHVlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWxfMSwgdmFsXzFfMSwgdmFsdWUsIGVfMV8xO1xuICAgICAgICAgICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbMCwgNywgOCwgMTNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxfMSA9IF9fYXN5bmNWYWx1ZXModmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQodmFsXzEubmV4dCgpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodmFsXzFfMSA9IF9iLnNlbnQoKSwgIXZhbF8xXzEuZG9uZSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KGZyb21KUyh2YWx1ZSkpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFs0IC8qeWllbGQqLywgX2Iuc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIFszIC8qYnJlYWsqLywgMTNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVfMV8xID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbOCwgLCAxMSwgMTJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh2YWxfMV8xICYmICF2YWxfMV8xLmRvbmUgJiYgKF9hID0gdmFsXzFbXCJyZXR1cm5cIl0pKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQoX2EuY2FsbCh2YWxfMSkpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOiByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMzogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdGF0aWNWYWx1ZSh2YWwsIGdldFR5cGUodmFsKSk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHR5cGUgb2YgdGhlIHZhbHVlLlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xuZnVuY3Rpb24gZ2V0VHlwZShkYXRhKSB7XG4gICAgaWYgKGRhdGEgPT09IG51bGwgfHwgdHlwZW9mIGRhdGEgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgIHJldHVybiAnYXJyYXknO1xuICAgIH1cbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIFBhdGgpIHtcbiAgICAgICAgcmV0dXJuICdwYXRoJztcbiAgICB9XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBEYXRlVGltZSkge1xuICAgICAgICByZXR1cm4gJ2RhdGV0aW1lJztcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiBkYXRhO1xufXZhciBUWVBFX09SREVSID0ge1xuICAgIGRhdGV0aW1lOiAxLFxuICAgIG51bWJlcjogMixcbiAgICBzdHJpbmc6IDMsXG4gICAgYm9vbGVhbjogNFxufTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG5mdW5jdGlvbiBwYXJ0aWFsQ29tcGFyZShhLCBiKSB7XG4gICAgdmFyIGFUeXBlID0gZ2V0VHlwZShhKTtcbiAgICB2YXIgYlR5cGUgPSBnZXRUeXBlKGIpO1xuICAgIGlmIChhVHlwZSAhPT0gYlR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHN3aXRjaCAoYVR5cGUpIHtcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICBpZiAoYSA8IGIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgaWYgKGEgPiBiKVxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGNhc2UgJ2RhdGV0aW1lJzpcbiAgICAgICAgICAgIHJldHVybiBhLmNvbXBhcmVUbyhiKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG5mdW5jdGlvbiB0b3RhbENvbXBhcmUoYSwgYikge1xuICAgIHZhciBhVHlwZSA9IGdldFR5cGUoYSk7XG4gICAgdmFyIGJUeXBlID0gZ2V0VHlwZShiKTtcbiAgICB2YXIgYVR5cGVPcmRlciA9IFRZUEVfT1JERVJbYVR5cGVdIHx8IDEwMDtcbiAgICB2YXIgYlR5cGVPcmRlciA9IFRZUEVfT1JERVJbYlR5cGVdIHx8IDEwMDtcbiAgICBpZiAoYVR5cGVPcmRlciAhPT0gYlR5cGVPcmRlcikge1xuICAgICAgICByZXR1cm4gYVR5cGVPcmRlciAtIGJUeXBlT3JkZXI7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBwYXJ0aWFsQ29tcGFyZShhLCBiKTtcbiAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgIHJlc3VsdCA9IDA7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59dmFyIENIQVJTID0gLyhbXiFAIyQlXiYqKCksXFxcXC8/XCI7Ont9fFtcXF0rPD5cXHMtXSkrL2c7XG52YXIgQ0hBUlNfV0lUSF9XSUxEQ0FSRCA9IC8oW14hQCMkJV4mKCksXFxcXC8/XCI7Ont9fFtcXF0rPD5cXHMtXSkrL2c7XG52YXIgRURHRV9DSEFSUyA9IC8oXFxiXFwuK3xcXC4rXFxiKS9nO1xudmFyIE1BWF9URVJNX0xFTkdUSCA9IDEwMjQ7XG5mdW5jdGlvbiBtYXRjaFRleHQodG9rZW5zLCBwYXR0ZXJucykge1xuICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAwIHx8IHBhdHRlcm5zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBwYXR0ZXJucy5ldmVyeShmdW5jdGlvbiAocGF0dGVybikgeyByZXR1cm4gcGF0dGVybih0b2tlbnMpOyB9KTtcbn1cbmZ1bmN0aW9uIG1hdGNoVG9rZW5pemUodGV4dCkge1xuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoRURHRV9DSEFSUywgJycpLm1hdGNoKENIQVJTKSB8fCBbXTtcbn1cbmZ1bmN0aW9uIG1hdGNoQW5hbHl6ZVBhdHRlcm4odGV4dCkge1xuICAgIHZhciB0ZXJtc1JlID0gbWF0Y2hQYXR0ZXJuUmVnZXgodGV4dCk7XG4gICAgcmV0dXJuIHRlcm1zUmUubWFwKGZ1bmN0aW9uIChyZSkgeyByZXR1cm4gZnVuY3Rpb24gKHRva2VucykgeyByZXR1cm4gdG9rZW5zLnNvbWUoZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiByZS50ZXN0KHRva2VuKTsgfSk7IH07IH0pO1xufVxuZnVuY3Rpb24gbWF0Y2hQYXR0ZXJuUmVnZXgodGV4dCkge1xuICAgIHZhciB0ZXJtcyA9IHRleHQucmVwbGFjZShFREdFX0NIQVJTLCAnJykubWF0Y2goQ0hBUlNfV0lUSF9XSUxEQ0FSRCkgfHwgW107XG4gICAgcmV0dXJuIHRlcm1zLm1hcChmdW5jdGlvbiAodGVybSkgeyByZXR1cm4gbmV3IFJlZ0V4cChcIl5cIi5jb25jYXQodGVybS5zbGljZSgwLCBNQVhfVEVSTV9MRU5HVEgpLnJlcGxhY2UoL1xcKi9nLCAnLionKSwgXCIkXCIpLCAnaScpOyB9KTtcbn1cbmZ1bmN0aW9uIGdhdGhlclRleHQodmFsdWUsIGNiKSB7XG4gICAgdmFyIHZhbHVlXzEsIHZhbHVlXzFfMTtcbiAgICB2YXIgZV8xLCBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdWNjZXNzLCBwYXJ0LCBlXzFfMTtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYih2YWx1ZS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0cnVlXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlLmlzQXJyYXkoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTNdO1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFsxLCA2LCA3LCAxMl0pO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZV8xID0gX19hc3luY1ZhbHVlcyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbNCAvKnlpZWxkKi8sIHZhbHVlXzEubmV4dCgpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHZhbHVlXzFfMSA9IF9iLnNlbnQoKSwgIXZhbHVlXzFfMS5kb25lKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgIHBhcnQgPSB2YWx1ZV8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0LnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYihwYXJ0LmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gNDtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFszIC8qYnJlYWsqLywgMTJdO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgZV8xXzEgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDEyXTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbNywgLCAxMCwgMTFdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodmFsdWVfMV8xICYmICF2YWx1ZV8xXzEuZG9uZSAmJiAoX2EgPSB2YWx1ZV8xW1wicmV0dXJuXCJdKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDldO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfYS5jYWxsKHZhbHVlXzEpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA5O1xuICAgICAgICAgICAgICAgIGNhc2UgOTogcmV0dXJuIFszIC8qYnJlYWsqLywgMTFdO1xuICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgIGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICBjYXNlIDExOiByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgIGNhc2UgMTI6IHJldHVybiBbMiAvKnJldHVybiovLCBzdWNjZXNzXTtcbiAgICAgICAgICAgICAgICBjYXNlIDEzOiByZXR1cm4gWzIgLypyZXR1cm4qLywgZmFsc2VdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn0vLyBCTTI1IHNpbWlsYXJpdHkgY29uc3RhbnRzXG52YXIgQk0yNWsgPSAxLjI7XG5mdW5jdGlvbiBldmFsdWF0ZVNjb3JlKG5vZGUsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5uZXJTY29yZSwgYm9vc3QsIF9hLCBsZWZ0U2NvcmUsIHJpZ2h0U2NvcmUsIGxlZnRTY29yZSwgcmlnaHRTY29yZSwgcmVzO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAnT3BDYWxsJyAmJiBub2RlLm9wID09PSAnbWF0Y2gnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZXZhbHVhdGVNYXRjaFNjb3JlKG5vZGUubGVmdCwgbm9kZS5yaWdodCwgc2NvcGUsIGV4ZWN1dGUpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIShub2RlLnR5cGUgPT09ICdGdW5jQ2FsbCcgJiYgbm9kZS5uYW1lID09PSAnYm9vc3QnKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGV2YWx1YXRlU2NvcmUobm9kZS5hcmdzWzBdLCBzY29wZSwgZXhlY3V0ZSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJTY29yZSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShub2RlLmFyZ3NbMV0sIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBib29zdCA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvb3N0LnR5cGUgPT09ICdudW1iZXInICYmIGlubmVyU2NvcmUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgaW5uZXJTY29yZSArIGJvb3N0LmRhdGFdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCAwXTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIF9hID0gbm9kZS50eXBlO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdPcic6IHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnQW5kJzogcmV0dXJuIFszIC8qYnJlYWsqLywgN107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTBdO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXZhbHVhdGVTY29yZShub2RlLmxlZnQsIHNjb3BlLCBleGVjdXRlKV07XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBsZWZ0U2NvcmUgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGV2YWx1YXRlU2NvcmUobm9kZS5yaWdodCwgc2NvcGUsIGV4ZWN1dGUpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0U2NvcmUgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBsZWZ0U2NvcmUgKyByaWdodFNjb3JlXTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV2YWx1YXRlU2NvcmUobm9kZS5sZWZ0LCBzY29wZSwgZXhlY3V0ZSldO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgbGVmdFNjb3JlID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBldmFsdWF0ZVNjb3JlKG5vZGUucmlnaHQsIHNjb3BlLCBleGVjdXRlKV07XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICByaWdodFNjb3JlID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdFNjb3JlID09PSAwIHx8IHJpZ2h0U2NvcmUgPT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgMF07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBsZWZ0U2NvcmUgKyByaWdodFNjb3JlXTtcbiAgICAgICAgICAgICAgICBjYXNlIDEwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKG5vZGUsIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzLnR5cGUgPT09ICdib29sZWFuJyAmJiByZXMuZGF0YSA9PT0gdHJ1ZSA/IDEgOiAwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBldmFsdWF0ZU1hdGNoU2NvcmUobGVmdCwgcmlnaHQsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGV4dCwgcGF0dGVybiwgdG9rZW5zLCB0ZXJtcywgZGlkU3VjY2VlZCwgc2NvcmUsIF9sb29wXzEsIF9pLCB0ZXJtc18xLCByZTtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShsZWZ0LCBzY29wZSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShyaWdodCwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHRva2VucyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0ZXJtcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBnYXRoZXJUZXh0KHRleHQsIGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zID0gdG9rZW5zLmNvbmNhdChtYXRjaFRva2VuaXplKHBhcnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZ2F0aGVyVGV4dChwYXR0ZXJuLCBmdW5jdGlvbiAocGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1zID0gdGVybXMuY29uY2F0KG1hdGNoUGF0dGVyblJlZ2V4KHBhcnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIGRpZFN1Y2NlZWQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZGlkU3VjY2VlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIDBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAwIHx8IHRlcm1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIDBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNjb3JlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgX2xvb3BfMSA9IGZ1bmN0aW9uIChyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyZXEgPSB0b2tlbnMucmVkdWNlKGZ1bmN0aW9uIChjLCB0b2tlbikgeyByZXR1cm4gYyArIChyZS50ZXN0KHRva2VuKSA/IDEgOiAwKTsgfSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29yZSArPSAoZnJlcSAqIChCTTI1ayArIDEpKSAvIChmcmVxICsgQk0yNWspO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKF9pID0gMCwgdGVybXNfMSA9IHRlcm1zOyBfaSA8IHRlcm1zXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZSA9IHRlcm1zXzFbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2xvb3BfMShyZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHNjb3JlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59ZnVuY3Rpb24gcG9ydGFibGVUZXh0Q29udGVudCh2YWx1ZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRleHRzO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh2YWx1ZS50eXBlID09PSAnb2JqZWN0JykpIHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgYmxvY2tUZXh0KHZhbHVlLmRhdGEpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUuaXNBcnJheSgpKSByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgYXJyYXlUZXh0KHZhbHVlKV07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB0ZXh0cyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0ZXh0cy5qb2luKCdcXG5cXG4nKV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGFycmF5VGV4dCh2YWx1ZSwgcmVzdWx0KSB7XG4gICAgdmFyIHZhbHVlXzEsIHZhbHVlXzFfMTtcbiAgICB2YXIgZV8xLCBfYTtcbiAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHsgcmVzdWx0ID0gW107IH1cbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBibG9jaywgdGV4dCwgZV8xXzE7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbMCwgNywgOCwgMTNdKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVfMSA9IF9fYXN5bmNWYWx1ZXModmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzQgLyp5aWVsZCovLCB2YWx1ZV8xLm5leHQoKV07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh2YWx1ZV8xXzEgPSBfYi5zZW50KCksICF2YWx1ZV8xXzEuZG9uZSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xuICAgICAgICAgICAgICAgICAgICBibG9jayA9IHZhbHVlXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoYmxvY2sudHlwZSA9PT0gJ29iamVjdCcpKSByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IGJsb2NrVGV4dChibG9jay5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHQgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWJsb2NrLmlzQXJyYXkoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGFycmF5VGV4dChibG9jaywgcmVzdWx0KV07XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gNTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuICAgICAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIFszIC8qYnJlYWsqLywgMTNdO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgZV8xXzEgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDEzXTtcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbOCwgLCAxMSwgMTJdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodmFsdWVfMV8xICYmICF2YWx1ZV8xXzEuZG9uZSAmJiAoX2EgPSB2YWx1ZV8xW1wicmV0dXJuXCJdKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDEwXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX2EuY2FsbCh2YWx1ZV8xKV07XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTA7XG4gICAgICAgICAgICAgICAgY2FzZSAxMDogcmV0dXJuIFszIC8qYnJlYWsqLywgMTJdO1xuICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgIGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICBjYXNlIDEyOiByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgIGNhc2UgMTM6IHJldHVybiBbMiAvKnJldHVybiovLCByZXN1bHRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGJsb2NrVGV4dChvYmopIHtcbiAgICBpZiAodHlwZW9mIG9iai5fdHlwZSAhPT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHZhciBjaGlsZHJlbiA9IG9iai5jaGlsZHJlbjtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBjaGlsZHJlbl8xID0gY2hpbGRyZW47IF9pIDwgY2hpbGRyZW5fMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5fMVtfaV07XG4gICAgICAgIGlmIChjaGlsZCAmJlxuICAgICAgICAgICAgdHlwZW9mIGNoaWxkID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgdHlwZW9mIGNoaWxkLl90eXBlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgY2hpbGQuX3R5cGUgPT09ICdzcGFuJyAmJlxuICAgICAgICAgICAgdHlwZW9mIGNoaWxkLnRleHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gY2hpbGQudGV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufWZ1bmN0aW9uIGhhc1JlZmVyZW5jZSh2YWx1ZSwgcGF0aFNldCkge1xuICAgIHN3aXRjaCAoZ2V0VHlwZSh2YWx1ZSkpIHtcbiAgICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCB2YWx1ZV8xID0gdmFsdWU7IF9pIDwgdmFsdWVfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdiA9IHZhbHVlXzFbX2ldO1xuICAgICAgICAgICAgICAgIGlmIChoYXNSZWZlcmVuY2UodiwgcGF0aFNldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICBpZiAodmFsdWUuX3JlZikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXRoU2V0Lmhhcyh2YWx1ZS5fcmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIF9hID0gMCwgX2IgPSBPYmplY3QudmFsdWVzKHZhbHVlKTsgX2EgPCBfYi5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdiA9IF9iW19hXTtcbiAgICAgICAgICAgICAgICBpZiAoaGFzUmVmZXJlbmNlKHYsIHBhdGhTZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjb3VudFVURjgoc3RyKSB7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY29kZSA+PSAweGQ4MDAgJiYgY29kZSA8PSAweGRiZmYpIHtcbiAgICAgICAgICAgIC8vIEhpZ2ggc3Vycm9nYXRlLiBEb24ndCBjb3VudCB0aGlzLlxuICAgICAgICAgICAgLy8gQnkgb25seSBjb3VudGluZyB0aGUgbG93IHN1cnJvZ2F0ZSB3ZSB3aWxsIGNvcnJlY3RseVxuICAgICAgICAgICAgLy8gY291bnQgdGhlIG51bWJlciBvZiBVVEYtOCBjb2RlIHBvaW50cy5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvdW50Kys7XG4gICAgfVxuICAgIHJldHVybiBjb3VudDtcbn1cbnZhciBnbG9iYWwgPSB7fTtcbmdsb2JhbC5hbnl3aGVyZSA9IGZ1bmN0aW9uIGFueXdoZXJlKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuZ2xvYmFsLmFueXdoZXJlLmFyaXR5ID0gMTtcbmdsb2JhbC5jb2FsZXNjZSA9IGZ1bmN0aW9uIGNvYWxlc2NlKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2ksIGFyZ3NfMSwgYXJnLCB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgX2kgPSAwLCBhcmdzXzEgPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShfaSA8IGFyZ3NfMS5sZW5ndGgpKSByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJnc18xW19pXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShhcmcsIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGUgIT09ICdudWxsJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDM7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBfaSsrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuZ2xvYmFsLmNvdW50ID0gZnVuY3Rpb24gY291bnQoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICB2YXIgZV8xLCBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbm5lciwgbnVtLCBpbm5lcl8xLCBpbm5lcl8xXzEsIGVfMV8xO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpbm5lciA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbm5lci5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBudW0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzIsIDcsIDgsIDEzXSk7XG4gICAgICAgICAgICAgICAgICAgIGlubmVyXzEgPSBfX2FzeW5jVmFsdWVzKGlubmVyKTtcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFs0IC8qeWllbGQqLywgaW5uZXJfMS5uZXh0KCldO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoaW5uZXJfMV8xID0gX2Iuc2VudCgpLCAhaW5uZXJfMV8xLmRvbmUpKSByZXR1cm4gWzMgLypicmVhayovLCA2XTtcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBudW0rKztcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA1O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgY2FzZSA2OiByZXR1cm4gWzMgLypicmVhayovLCAxM107XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICBlXzFfMSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZV8xID0geyBlcnJvcjogZV8xXzEgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTNdO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFs4LCAsIDExLCAxMl0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShpbm5lcl8xXzEgJiYgIWlubmVyXzFfMS5kb25lICYmIChfYSA9IGlubmVyXzFbXCJyZXR1cm5cIl0pKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTBdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfYS5jYWxsKGlubmVyXzEpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxMDtcbiAgICAgICAgICAgICAgICBjYXNlIDEwOiByZXR1cm4gWzMgLypicmVhayovLCAxMl07XG4gICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgIGNhc2UgMTI6IHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgY2FzZSAxMzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21OdW1iZXIobnVtKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbmdsb2JhbC5jb3VudC5hcml0eSA9IDE7XG5nbG9iYWwuZGF0ZVRpbWUgPSBmdW5jdGlvbiBkYXRlVGltZShhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbDtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsLnR5cGUgPT09ICdkYXRldGltZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB2YWxdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwudHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgRGF0ZVRpbWUucGFyc2VUb1ZhbHVlKHZhbC5kYXRhKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbmdsb2JhbC5kYXRlVGltZS5hcml0eSA9IDE7XG5nbG9iYWwuZGVmaW5lZCA9IGZ1bmN0aW9uIGRlZmluZWQoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbm5lcjtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaW5uZXIgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBpbm5lci50eXBlID09PSAnbnVsbCcgPyBGQUxTRV9WQUxVRSA6IFRSVUVfVkFMVUVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5nbG9iYWwuZGVmaW5lZC5hcml0eSA9IDE7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVxdWlyZS1hd2FpdFxuZ2xvYmFsLmlkZW50aXR5ID0gZnVuY3Rpb24gaWRlbnRpdHkoYXJncywgc2NvcGUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmcm9tU3RyaW5nKHNjb3BlLmNvbnRleHQuaWRlbnRpdHkpXTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuZ2xvYmFsLmlkZW50aXR5LmFyaXR5ID0gMDtcbmdsb2JhbC5sZW5ndGggPSBmdW5jdGlvbiBsZW5ndGgoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICB2YXIgZV8yLCBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbm5lciwgbnVtLCBpbm5lcl8yLCBpbm5lcl8yXzEsIGVfMl8xO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpbm5lciA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlubmVyLnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZnJvbU51bWJlcihjb3VudFVURjgoaW5uZXIuZGF0YSkpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlubmVyLmlzQXJyYXkoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTRdO1xuICAgICAgICAgICAgICAgICAgICBudW0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzIsIDcsIDgsIDEzXSk7XG4gICAgICAgICAgICAgICAgICAgIGlubmVyXzIgPSBfX2FzeW5jVmFsdWVzKGlubmVyKTtcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFs0IC8qeWllbGQqLywgaW5uZXJfMi5uZXh0KCldO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoaW5uZXJfMl8xID0gX2Iuc2VudCgpLCAhaW5uZXJfMl8xLmRvbmUpKSByZXR1cm4gWzMgLypicmVhayovLCA2XTtcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJfMl8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBudW0rKztcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA1O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgY2FzZSA2OiByZXR1cm4gWzMgLypicmVhayovLCAxM107XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICBlXzJfMSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZV8yID0geyBlcnJvcjogZV8yXzEgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTNdO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFs4LCAsIDExLCAxMl0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShpbm5lcl8yXzEgJiYgIWlubmVyXzJfMS5kb25lICYmIChfYSA9IGlubmVyXzJbXCJyZXR1cm5cIl0pKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTBdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfYS5jYWxsKGlubmVyXzIpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxMDtcbiAgICAgICAgICAgICAgICBjYXNlIDEwOiByZXR1cm4gWzMgLypicmVhayovLCAxMl07XG4gICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgIGNhc2UgMTI6IHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgY2FzZSAxMzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21OdW1iZXIobnVtKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxNDogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5nbG9iYWwubGVuZ3RoLmFyaXR5ID0gMTtcbmdsb2JhbC5wYXRoID0gZnVuY3Rpb24gcGF0aChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlubmVyO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpbm5lciA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlubmVyLnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21QYXRoKG5ldyBQYXRoKGlubmVyLmRhdGEpKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbmdsb2JhbC5wYXRoLmFyaXR5ID0gMTtcbmdsb2JhbC5zdHJpbmcgPSBmdW5jdGlvbiBzdHJpbmcoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodmFsdWUudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2RhdGV0aW1lJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZnJvbVN0cmluZyhcIlwiLmNvbmNhdCh2YWx1ZS5kYXRhKSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5nbG9iYWwuc3RyaW5nLmFyaXR5ID0gMTtcbmdsb2JhbC5yZWZlcmVuY2VzID0gZnVuY3Rpb24gcmVmZXJlbmNlcyhhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHZhciBlXzMsIF9hO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhdGhTZXQsIF9pLCBhcmdzXzIsIGFyZywgcGF0aCwgcGF0aF8xLCBwYXRoXzFfMSwgZWxlbSwgZV8zXzEsIHNjb3BlVmFsdWU7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHBhdGhTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIF9pID0gMCwgYXJnc18yID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoX2kgPCBhcmdzXzIubGVuZ3RoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTZdO1xuICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmdzXzJbX2ldO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGFyZywgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHBhdGggPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHBhdGgudHlwZSA9PT0gJ3N0cmluZycpKSByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aFNldC5hZGQocGF0aC5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTVdO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXRoLmlzQXJyYXkoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTVdO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDQ7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzQsIDksIDEwLCAxNV0pO1xuICAgICAgICAgICAgICAgICAgICBwYXRoXzEgPSAoZV8zID0gdm9pZCAwLCBfX2FzeW5jVmFsdWVzKHBhdGgpKTtcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA1O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFs0IC8qeWllbGQqLywgcGF0aF8xLm5leHQoKV07XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShwYXRoXzFfMSA9IF9iLnNlbnQoKSwgIXBhdGhfMV8xLmRvbmUpKSByZXR1cm4gWzMgLypicmVhayovLCA4XTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbSA9IHBhdGhfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbS50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aFNldC5hZGQoZWxlbS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDc7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiByZXR1cm4gWzMgLypicmVhayovLCA1XTtcbiAgICAgICAgICAgICAgICBjYXNlIDg6IHJldHVybiBbMyAvKmJyZWFrKi8sIDE1XTtcbiAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgIGVfM18xID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBlXzMgPSB7IGVycm9yOiBlXzNfMSB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxNV07XG4gICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFsxMCwgLCAxMywgMTRdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocGF0aF8xXzEgJiYgIXBhdGhfMV8xLmRvbmUgJiYgKF9hID0gcGF0aF8xW1wicmV0dXJuXCJdKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDEyXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX2EuY2FsbChwYXRoXzEpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTI7XG4gICAgICAgICAgICAgICAgY2FzZSAxMjogcmV0dXJuIFszIC8qYnJlYWsqLywgMTRdO1xuICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICAgIGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE0OiByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgICAgIF9pKys7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuICAgICAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXRoU2V0LnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBGQUxTRV9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgc2NvcGUudmFsdWUuZ2V0KCldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlVmFsdWUgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBoYXNSZWZlcmVuY2Uoc2NvcGVWYWx1ZSwgcGF0aFNldCkgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5nbG9iYWwucmVmZXJlbmNlcy5hcml0eSA9IGZ1bmN0aW9uIChjKSB7IHJldHVybiBjID49IDE7IH07XG5nbG9iYWwucm91bmQgPSBmdW5jdGlvbiByb3VuZChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlLCBudW0sIHByZWMsIHByZWNWYWx1ZTtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG51bSA9IHZhbHVlLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIHByZWMgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShhcmdzLmxlbmd0aCA9PT0gMikpIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGFyZ3NbMV0sIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBwcmVjVmFsdWUgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmVjVmFsdWUudHlwZSAhPT0gJ251bWJlcicgfHwgcHJlY1ZhbHVlLmRhdGEgPCAwIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKHByZWNWYWx1ZS5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByZWMgPSBwcmVjVmFsdWUuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZWMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudW0gPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSmF2YVNjcmlwdCdzIHJvdW5kKCkgZnVuY3Rpb24gd2lsbCBhbHdheXMgcm91bmRzIHRvd2FyZHMgcG9zaXRpdmUgaW5maW5pdHkgKC0zLjUgLT4gLTMpLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBiZWhhdmlvciB3ZSdyZSBpbnRlcmVzdGVkIGluIGlzIHRvIFwicm91bmQgaGFsZiBhd2F5IGZyb20gemVyb1wiLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmcm9tTnVtYmVyKC1NYXRoLnJvdW5kKC1udW0pKV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZnJvbU51bWJlcihNYXRoLnJvdW5kKG51bSkpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZnJvbU51bWJlcihOdW1iZXIobnVtLnRvRml4ZWQocHJlYykpKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbmdsb2JhbC5yb3VuZC5hcml0eSA9IGZ1bmN0aW9uIChjb3VudCkgeyByZXR1cm4gY291bnQgPj0gMSAmJiBjb3VudCA8PSAyOyB9O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlcXVpcmUtYXdhaXRcbmdsb2JhbC5ub3cgPSBmdW5jdGlvbiBub3coYXJncywgc2NvcGUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmcm9tU3RyaW5nKHNjb3BlLmNvbnRleHQudGltZXN0YW1wLnRvSVNPU3RyaW5nKCkpXTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuZ2xvYmFsLm5vdy5hcml0eSA9IDA7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVxdWlyZS1hd2FpdFxuZ2xvYmFsLmJvb3N0ID0gZnVuY3Rpb24gYm9vc3QoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBiZSBoYW5kbGVkIGJ5IHRoZSBzY29yaW5nIGZ1bmN0aW9uLlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIGJvb3N0IGNhbGwnKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuZ2xvYmFsLmJvb3N0LmFyaXR5ID0gMjtcbnZhciBzdHJpbmcgPSB7fTtcbnN0cmluZy5sb3dlciA9IGZ1bmN0aW9uIChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21TdHJpbmcodmFsdWUuZGF0YS50b0xvd2VyQ2FzZSgpKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbnN0cmluZy5sb3dlci5hcml0eSA9IDE7XG5zdHJpbmcudXBwZXIgPSBmdW5jdGlvbiAoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmcm9tU3RyaW5nKHZhbHVlLmRhdGEudG9VcHBlckNhc2UoKSldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5zdHJpbmcudXBwZXIuYXJpdHkgPSAxO1xuZ2xvYmFsLmxvd2VyID0gc3RyaW5nLmxvd2VyO1xuZ2xvYmFsLnVwcGVyID0gc3RyaW5nLnVwcGVyO1xudmFyIHB0ID0ge307XG5wdC50ZXh0ID0gZnVuY3Rpb24gKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWUsIHRleHQ7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBwb3J0YWJsZVRleHRDb250ZW50KHZhbHVlKV07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmcm9tU3RyaW5nKHRleHQpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xucHQudGV4dC5hcml0eSA9IDE7XG52YXIgc2FuaXR5ID0ge307XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVxdWlyZS1hd2FpdFxuc2FuaXR5LnByb2plY3RJZCA9IGZ1bmN0aW9uIChhcmdzLCBzY29wZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgaWYgKHNjb3BlLmNvbnRleHQuc2FuaXR5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21TdHJpbmcoc2NvcGUuY29udGV4dC5zYW5pdHkucHJvamVjdElkKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZXF1aXJlLWF3YWl0XG5zYW5pdHkuZGF0YXNldCA9IGZ1bmN0aW9uIChhcmdzLCBzY29wZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgaWYgKHNjb3BlLmNvbnRleHQuc2FuaXR5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21TdHJpbmcoc2NvcGUuY29udGV4dC5zYW5pdHkuZGF0YXNldCldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG52YXIgcGlwZUZ1bmN0aW9ucyA9IHt9O1xucGlwZUZ1bmN0aW9ucy5vcmRlciA9IGZ1bmN0aW9uIG9yZGVyKGJhc2UsIGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgdmFyIGJhc2VfMSwgYmFzZV8xXzE7XG4gICAgdmFyIGVfNCwgX2E7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWFwcGVycywgZGlyZWN0aW9ucywgbiwgX2ksIGFyZ3NfMywgbWFwcGVyLCBkaXJlY3Rpb24sIGF1eCwgaWR4LCB2YWx1ZSwgbmV3U2NvcGUsIHR1cGxlLCBpLCByZXN1bHQsIF9iLCBfYywgZV80XzE7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2QpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2QubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IFxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9ycGV0cmljaC9iYWJlbC1wbHVnaW4tdHJhbnNmb3JtLWFzeW5jLXRvLXByb21pc2VzL2lzc3Vlcy81OVxuICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRydWVdO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9ycGV0cmljaC9iYWJlbC1wbHVnaW4tdHJhbnNmb3JtLWFzeW5jLXRvLXByb21pc2VzL2lzc3Vlcy81OVxuICAgICAgICAgICAgICAgICAgICBfZC5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYmFzZS5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtYXBwZXJzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoX2kgPSAwLCBhcmdzXzMgPSBhcmdzOyBfaSA8IGFyZ3NfMy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBlciA9IGFyZ3NfM1tfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSAnYXNjJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXBwZXIudHlwZSA9PT0gJ0Rlc2MnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gJ2Rlc2MnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBlciA9IG1hcHBlci5iYXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWFwcGVyLnR5cGUgPT09ICdBc2MnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGVyID0gbWFwcGVyLmJhc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwZXJzLnB1c2gobWFwcGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbnMucHVzaChkaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbisrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGF1eCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZHggPSAwO1xuICAgICAgICAgICAgICAgICAgICBfZC5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBfZC50cnlzLnB1c2goWzIsIDEzLCAxNCwgMTldKTtcbiAgICAgICAgICAgICAgICAgICAgYmFzZV8xID0gX19hc3luY1ZhbHVlcyhiYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgX2QubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFs0IC8qeWllbGQqLywgYmFzZV8xLm5leHQoKV07XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShiYXNlXzFfMSA9IF9kLnNlbnQoKSwgIWJhc2VfMV8xLmRvbmUpKSByZXR1cm4gWzMgLypicmVhayovLCAxMl07XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYmFzZV8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlTmVzdGVkKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdmFsdWUuZ2V0KCldO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgdHVwbGUgPSBbX2Quc2VudCgpLCBpZHhdO1xuICAgICAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgX2QubGFiZWwgPSA2O1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoaSA8IG4pKSByZXR1cm4gWzMgLypicmVhayovLCAxMF07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUobWFwcGVyc1tpXSwgbmV3U2NvcGUpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9kLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgX2MgPSAoX2IgPSB0dXBsZSkucHVzaDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcmVzdWx0LmdldCgpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIF9jLmFwcGx5KF9iLCBbX2Quc2VudCgpXSk7XG4gICAgICAgICAgICAgICAgICAgIF9kLmxhYmVsID0gOTtcbiAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG4gICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgYXV4LnB1c2godHVwbGUpO1xuICAgICAgICAgICAgICAgICAgICBpZHgrKztcbiAgICAgICAgICAgICAgICAgICAgX2QubGFiZWwgPSAxMTtcbiAgICAgICAgICAgICAgICBjYXNlIDExOiByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICBjYXNlIDEyOiByZXR1cm4gWzMgLypicmVhayovLCAxOV07XG4gICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgICAgZV80XzEgPSBfZC5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGVfNCA9IHsgZXJyb3I6IGVfNF8xIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDE5XTtcbiAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgICAgICBfZC50cnlzLnB1c2goWzE0LCAsIDE3LCAxOF0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShiYXNlXzFfMSAmJiAhYmFzZV8xXzEuZG9uZSAmJiAoX2EgPSBiYXNlXzFbXCJyZXR1cm5cIl0pKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTZdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfYS5jYWxsKGJhc2VfMSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgICAgIF9kLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgX2QubGFiZWwgPSAxNjtcbiAgICAgICAgICAgICAgICBjYXNlIDE2OiByZXR1cm4gWzMgLypicmVhayovLCAxOF07XG4gICAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVfNCkgdGhyb3cgZV80LmVycm9yO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgIGNhc2UgMTg6IHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgICAgICAgYXV4LnNvcnQoZnVuY3Rpb24gKGFUdXBsZSwgYlR1cGxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gdG90YWxDb21wYXJlKGFUdXBsZVtpICsgMl0sIGJUdXBsZVtpICsgMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb25zW2ldID09PSAnZGVzYycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IC1jO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYyAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGYWxsYmFjayB0byBzb3J0aW5nIG9uIHRoZSBvcmlnaW5hbCBpbmRleCBmb3Igc3RhYmxlIHNvcnRpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYVR1cGxlWzFdIC0gYlR1cGxlWzFdO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21KUyhhdXgubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2WzBdOyB9KSldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5waXBlRnVuY3Rpb25zLm9yZGVyLmFyaXR5ID0gZnVuY3Rpb24gKGNvdW50KSB7IHJldHVybiBjb3VudCA+PSAxOyB9O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlcXVpcmUtYXdhaXRcbnBpcGVGdW5jdGlvbnMuc2NvcmUgPSBmdW5jdGlvbiBzY29yZShiYXNlLCBhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHZhciBiYXNlXzIsIGJhc2VfMl8xO1xuICAgIHZhciBlXzUsIF9hO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHVua25vd24sIHNjb3JlZCwgdmFsdWUsIF9iLCBfYywgbmV3U2NvcGUsIHZhbHVlU2NvcmUsIF9pLCBhcmdzXzQsIGFyZywgX2QsIG5ld09iamVjdCwgZV81XzE7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2UpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2UubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGlmICghYmFzZS5pc0FycmF5KCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFueXRoaW5nIHRoYXQgaXNuJ3QgYW4gb2JqZWN0IHNob3VsZCBiZSBzb3J0ZWQgZmlyc3QuXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICB1bmtub3duID0gW107XG4gICAgICAgICAgICAgICAgICAgIHNjb3JlZCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBfZS5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBfZS50cnlzLnB1c2goWzEsIDEyLCAxMywgMThdKTtcbiAgICAgICAgICAgICAgICAgICAgYmFzZV8yID0gX19hc3luY1ZhbHVlcyhiYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgX2UubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFs0IC8qeWllbGQqLywgYmFzZV8yLm5leHQoKV07XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShiYXNlXzJfMSA9IF9lLnNlbnQoKSwgIWJhc2VfMl8xLmRvbmUpKSByZXR1cm4gWzMgLypicmVhayovLCAxMV07XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYmFzZV8yXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHZhbHVlLnR5cGUgIT09ICdvYmplY3QnKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgIF9jID0gKF9iID0gdW5rbm93bikucHVzaDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdmFsdWUuZ2V0KCldO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgX2MuYXBwbHkoX2IsIFtfZS5zZW50KCldKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTBdO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVOZXN0ZWQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZVNjb3JlID0gdHlwZW9mIHZhbHVlLmRhdGEuX3Njb3JlID09PSAnbnVtYmVyJyA/IHZhbHVlLmRhdGEuX3Njb3JlIDogMDtcbiAgICAgICAgICAgICAgICAgICAgX2kgPSAwLCBhcmdzXzQgPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICBfZS5sYWJlbCA9IDY7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShfaSA8IGFyZ3NfNC5sZW5ndGgpKSByZXR1cm4gWzMgLypicmVhayovLCA5XTtcbiAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJnc180W19pXTtcbiAgICAgICAgICAgICAgICAgICAgX2QgPSB2YWx1ZVNjb3JlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBldmFsdWF0ZVNjb3JlKGFyZywgbmV3U2NvcGUsIGV4ZWN1dGUpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlU2NvcmUgPSBfZCArIF9lLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgX2UubGFiZWwgPSA4O1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgX2krKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICBuZXdPYmplY3QgPSBPYmplY3QuYXNzaWduKHt9LCB2YWx1ZS5kYXRhLCB7IF9zY29yZTogdmFsdWVTY29yZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgc2NvcmVkLnB1c2gobmV3T2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgX2UubGFiZWwgPSAxMDtcbiAgICAgICAgICAgICAgICBjYXNlIDEwOiByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICBjYXNlIDExOiByZXR1cm4gWzMgLypicmVhayovLCAxOF07XG4gICAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICAgICAgZV81XzEgPSBfZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGVfNSA9IHsgZXJyb3I6IGVfNV8xIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDE4XTtcbiAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgICBfZS50cnlzLnB1c2goWzEzLCAsIDE2LCAxN10pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShiYXNlXzJfMSAmJiAhYmFzZV8yXzEuZG9uZSAmJiAoX2EgPSBiYXNlXzJbXCJyZXR1cm5cIl0pKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTVdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfYS5jYWxsKGJhc2VfMildO1xuICAgICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgICAgIF9lLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgX2UubGFiZWwgPSAxNTtcbiAgICAgICAgICAgICAgICBjYXNlIDE1OiByZXR1cm4gWzMgLypicmVhayovLCAxN107XG4gICAgICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVfNSkgdGhyb3cgZV81LmVycm9yO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgIGNhc2UgMTc6IHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgICAgICAgICAgc2NvcmVkLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGIuX3Njb3JlIC0gYS5fc2NvcmU7IH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZnJvbUpTKHNjb3JlZCldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5waXBlRnVuY3Rpb25zLnNjb3JlLmFyaXR5ID0gZnVuY3Rpb24gKGNvdW50KSB7IHJldHVybiBjb3VudCA+PSAxOyB9O1xudmFyIGRlbHRhID0ge307XG5kZWx0YS5vcGVyYXRpb24gPSBmdW5jdGlvbiAoYXJncywgc2NvcGUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBoYXNCZWZvcmUsIGhhc0FmdGVyO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBoYXNCZWZvcmUgPSBzY29wZS5jb250ZXh0LmJlZm9yZSAhPT0gbnVsbDtcbiAgICAgICAgICAgIGhhc0FmdGVyID0gc2NvcGUuY29udGV4dC5hZnRlciAhPT0gbnVsbDtcbiAgICAgICAgICAgIGlmIChoYXNCZWZvcmUgJiYgaGFzQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZnJvbVN0cmluZygndXBkYXRlJyldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc0FmdGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21TdHJpbmcoJ2NyZWF0ZScpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNCZWZvcmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZnJvbVN0cmluZygnZGVsZXRlJyldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5kZWx0YS5jaGFuZ2VkQW55ID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG59O1xuZGVsdGEuY2hhbmdlZEFueS5hcml0eSA9IDE7XG5kZWx0YS5jaGFuZ2VkQW55Lm1vZGUgPSAnZGVsdGEnO1xuZGVsdGEuY2hhbmdlZE9ubHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5kZWx0YS5jaGFuZ2VkT25seS5hcml0eSA9IDE7XG5kZWx0YS5jaGFuZ2VkT25seS5tb2RlID0gJ2RlbHRhJztcbnZhciBkaWZmID0ge307XG5kaWZmLmNoYW5nZWRBbnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5kaWZmLmNoYW5nZWRBbnkuYXJpdHkgPSAzO1xuZGlmZi5jaGFuZ2VkT25seSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xufTtcbmRpZmYuY2hhbmdlZE9ubHkuYXJpdHkgPSAzO1xudmFyIG5hbWVzcGFjZXMgPSB7XG4gICAgZ2xvYmFsOiBnbG9iYWwsXG4gICAgc3RyaW5nOiBzdHJpbmcsXG4gICAgcHQ6IHB0LFxuICAgIGRlbHRhOiBkZWx0YSxcbiAgICBkaWZmOiBkaWZmLFxuICAgIHNhbml0eTogc2FuaXR5XG59O2NvbnN0IFdTID0gL14oW1xcdFxcblxcdlxcZlxcciBcXHUwMDg1XFx1MDBBMF18KFxcL1xcL1teXFxuXSpcXG4pKSsvO1xuY29uc3QgTlVNID0gL15cXGQrLztcbmNvbnN0IElERU5UID0gL15bYS16QS1aX11bYS16QS1aXzAtOV0qLztcblxuLy8gUHJlY2VkZW5jZSBsZXZlbHMgZm9yIGJpbmFyeSBvcGVyYXRvcnM6XG5jb25zdCBQUkVDX1BBSVIgPSAxO1xuY29uc3QgUFJFQ19PUiA9IDI7XG5jb25zdCBQUkVDX0FORCA9IDM7XG5jb25zdCBQUkVDX0NPTVAgPSA0O1xuY29uc3QgUFJFQ19PUkRFUiA9IDQ7XG5jb25zdCBQUkVDX0FERCA9IDY7XG5jb25zdCBQUkVDX1NVQiA9IDY7XG5jb25zdCBQUkVDX01VTCA9IDc7XG5jb25zdCBQUkVDX0RJViA9IDc7XG5jb25zdCBQUkVDX01PRCA9IDc7XG5jb25zdCBQUkVDX1BPVyA9IDg7XG5cbi8vIFByZWNlZGVuY2UgbGV2ZWxzIGZvciBwcmVmaXggb3BlcmF0b3JzOlxuY29uc3QgUFJFQ19QT1MgPSAxMDtcbmNvbnN0IFBSRUNfTk9UID0gMTA7XG5jb25zdCBQUkVDX05FRyA9IDg7XG5cbmZ1bmN0aW9uIHBhcnNlJDEoc3RyKSB7XG4gIGxldCBwb3MgPSAwO1xuICBwb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICBsZXQgcmVzdWx0ID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgaWYgKHJlc3VsdC50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmVzdWx0XG4gIHBvcyA9IHNraXBXUyhzdHIsIHJlc3VsdC5wb3NpdGlvbik7XG4gIGlmIChwb3MgIT09IHN0ci5sZW5ndGgpIHtcbiAgICBpZiAocmVzdWx0LmZhaWxQb3NpdGlvbikge1xuICAgICAgcG9zID0gcmVzdWx0LmZhaWxQb3NpdGlvbiAtIDE7XG4gICAgfVxuICAgIHJldHVybiB7dHlwZTogJ2Vycm9yJywgcG9zaXRpb246IHBvc31cbiAgfVxuICBkZWxldGUgcmVzdWx0LnBvc2l0aW9uO1xuICBkZWxldGUgcmVzdWx0LmZhaWxQb3NpdGlvbjtcbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBwYXJzZUV4cHIoc3RyLCBwb3MsIGxldmVsKSB7XG4gIC8vIEluIHRoaXMgZnVuY3Rpb24gd2UgcGFyc2UgcHJlY2VkZW5jZSBcIm1hbnVhbGx5XCIgYnkgaGF2aW5nIHR3byB2YXJpYWJsZXM6XG4gIC8vXG4gIC8vIGBsZXZlbGAgaXMgdGhlIG1pbmltdW0gcHJlY2VkZW5jZSBsZXZlbCB3ZSB3YW50IHRvIHBhcnNlIGF0LiBJZiB0aGlzIGlzXG4gIC8vIGUuZy4gNyB0aGVuIHRoaXMgZnVuY3Rpb24gd2lsbCBub3QgcGFyc2UgYDMgKyA0YCAoc2luY2UgYWRkaXRpb24gaXMgYXQgNiksXG4gIC8vIGJ1dCBpbnN0ZWFkIGp1c3QgcmV0dXJuIGAxYCBhbmQgbGVhdmUgYCArIDVgIHJlbWFpbmluZy4gV2UgdXNlIHRoaXMgc28gdGhhdFxuICAvLyB3aGlsZSBoYW5kbGluZyB0aGUgUkhTIG9mIHRoZSBtdWx0aXBsaWNhdGlvbiBpbiBgMSArIDIgKiAzICsgNGAgd2Ugb25seSBwYXJzZSBgM2AuXG4gIC8vXG4gIC8vIGBsaHNMZXZlbGAgaXMgdGhlIHByZWNlZGVuY2UgbGV2ZWwgb2YgdGhlIGN1cnJlbnRseSBwYXJzZWQgZXhwcmVzc2lvbiBvblxuICAvLyB0aGUgbGVmdC1oYW5kIHNpZGUuIFRoaXMgaXMgbWFpbmx5IHVzZWQgdG8gaGFuZGxlIG5vbi1hc3NvY2ljYXRpdmVuZXNzLlxuXG4gIC8vIFRoaXMgbWVhbnMgdGhhdCB5b3UnbGwgc2VlIGNvZGUgbGlrZTpcbiAgLy8gLSBgaWYgKGxldmVsID4gUFJFQ19YWFgpIGJyZWFrYDogT3BlcmF0b3IgaXMgYXQgdGhpcyBwcmVjZWRlbmNlIGxldmVsLlxuICAvLyAtIGBpZiAobGhzTGV2ZWwgPCBQUkVDX1hYWCkgYnJlYWtgOiBPcGVyYXRvciBpcyBsZWZ0LWFzc29jaWF0aXZlLlxuICAvLyAtIGBpZiAobGhzTGV2ZWwgPD0gUFJFQ19YWFgpIGJyZWFrYDogT3BlcmF0b3IgaXMgcmlnaHQvbm9uLWFzc29jaWF0aXZlLlxuICAvLyAtIGBwYXJzZUV4cHIoc3RyLCBwb3MsIFBSRUNfWFhYICsgMSlgOiBPcGVyYXRvciBpcyBsZWZ0L25vbi1hc3NvaWNhdGUuXG4gIC8vIC0gYHBhcnNlRXhwcihzdHIsIHBvcywgUFJFQ19YWFgpYDogT3BlcmF0b3IgaXMgcmlnaHQtYXNzb2ljYXRlLlxuXG4gIGxldCBzdGFydFBvcyA9IHBvcztcbiAgbGV0IHRva2VuID0gc3RyW3Bvc107XG4gIGxldCBtYXJrcztcblxuICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgY2FzZSAnKyc6IHtcbiAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBwb3MgKyAxKSwgUFJFQ19QT1MpO1xuICAgICAgaWYgKHJocy50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmhzXG4gICAgICBtYXJrcyA9IFt7bmFtZTogJ3BvcycsIHBvc2l0aW9uOiBzdGFydFBvc31dLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2FzZSAnLSc6IHtcbiAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBwb3MgKyAxKSwgUFJFQ19ORUcpO1xuICAgICAgaWYgKHJocy50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmhzXG4gICAgICBtYXJrcyA9IFt7bmFtZTogJ25lZycsIHBvc2l0aW9uOiBzdGFydFBvc31dLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2FzZSAnKCc6IHtcbiAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBwb3MgKyAxKSwgMCk7XG4gICAgICBpZiAocmhzLnR5cGUgPT09ICdlcnJvcicpIHJldHVybiByaHNcbiAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHJocy5wb3NpdGlvbik7XG4gICAgICBzd2l0Y2ggKHN0cltwb3NdKSB7XG4gICAgICAgIGNhc2UgJywnOiB7XG4gICAgICAgICAgLy8gVHVwbGVzXG4gICAgICAgICAgbWFya3MgPSBbe25hbWU6ICd0dXBsZScsIHBvc2l0aW9uOiBzdGFydFBvc31dLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICByaHMgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xuICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmhzXG4gICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCByaHMucG9zaXRpb24pO1xuICAgICAgICAgICAgaWYgKHN0cltwb3NdICE9PSAnLCcpIGJyZWFrXG4gICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0cltwb3NdICE9PSAnKScpIHJldHVybiB7dHlwZTogJ2Vycm9yJywgcG9zaXRpb246IHBvc31cbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgICBtYXJrcy5wdXNoKHtuYW1lOiAndHVwbGVfZW5kJywgcG9zaXRpb246IHBvc30pO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnKSc6IHtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgICBtYXJrcyA9IFt7bmFtZTogJ2dyb3VwJywgcG9zaXRpb246IHN0YXJ0UG9zfV0uY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB7dHlwZTogJ2Vycm9yJywgcG9zaXRpb246IHBvc31cbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNhc2UgJyEnOiB7XG4gICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgcG9zICsgMSksIFBSRUNfTk9UKTtcbiAgICAgIGlmIChyaHMudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJoc1xuICAgICAgbWFya3MgPSBbe25hbWU6ICdub3QnLCBwb3NpdGlvbjogc3RhcnRQb3N9XS5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNhc2UgJ3snOiB7XG4gICAgICBsZXQgcmVzdWx0ID0gcGFyc2VPYmplY3Qoc3RyLCBwb3MpO1xuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmVzdWx0XG4gICAgICBtYXJrcyA9IHJlc3VsdC5tYXJrcztcbiAgICAgIHBvcyA9IHJlc3VsdC5wb3NpdGlvbjtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNhc2UgJ1snOlxuICAgICAgbWFya3MgPSBbe25hbWU6ICdhcnJheScsIHBvc2l0aW9uOiBwb3N9XTtcbiAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuXG4gICAgICBpZiAoc3RyW3Bvc10gIT09ICddJykge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGlmIChzdHIuc2xpY2UocG9zLCBwb3MgKyAzKSA9PT0gJy4uLicpIHtcbiAgICAgICAgICAgIG1hcmtzLnB1c2goe25hbWU6ICdhcnJheV9zcGxhdCcsIHBvc2l0aW9uOiBwb3N9KTtcbiAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCByZXMgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xuICAgICAgICAgIGlmIChyZXMudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJlc1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJlcy5tYXJrcyk7XG4gICAgICAgICAgcG9zID0gcmVzLnBvc2l0aW9uO1xuICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyk7XG4gICAgICAgICAgaWYgKHN0cltwb3NdICE9PSAnLCcpIGJyZWFrXG4gICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gICAgICAgICAgaWYgKHN0cltwb3NdID09PSAnXScpIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN0cltwb3NdID09PSAnXScpIHtcbiAgICAgICAgcG9zKys7XG4gICAgICAgIG1hcmtzLnB1c2goe25hbWU6ICdhcnJheV9lbmQnLCBwb3NpdGlvbjogcG9zfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge3R5cGU6ICdlcnJvcicsIHBvc2l0aW9uOiBwb3N9XG4gICAgICB9XG5cbiAgICAgIGJyZWFrXG4gICAgY2FzZSBcIidcIjpcbiAgICBjYXNlICdcIic6IHtcbiAgICAgIGxldCByZXN1bHQgPSBwYXJzZVN0cmluZyhzdHIsIHBvcyk7XG4gICAgICBpZiAocmVzdWx0LnR5cGUgPT09ICdlcnJvcicpIHJldHVybiByZXN1bHRcbiAgICAgIG1hcmtzID0gcmVzdWx0Lm1hcmtzO1xuICAgICAgcG9zID0gcmVzdWx0LnBvc2l0aW9uO1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2FzZSAnXic6IHtcbiAgICAgIHBvcysrO1xuICAgICAgbWFya3MgPSBbXTtcbiAgICAgIHdoaWxlIChzdHJbcG9zXSA9PT0gJy4nICYmIHN0cltwb3MgKyAxXSA9PT0gJ14nKSB7XG4gICAgICAgIG1hcmtzLnB1c2goe25hbWU6ICdkYmxwYXJlbnQnLCBwb3NpdGlvbjogc3RhcnRQb3N9KTtcbiAgICAgICAgcG9zICs9IDI7XG4gICAgICB9XG4gICAgICBtYXJrcy5wdXNoKHtuYW1lOiAncGFyZW50JywgcG9zaXRpb246IHN0YXJ0UG9zfSk7XG4gICAgICBicmVha1xuICAgIH1cbiAgICBjYXNlICdAJzpcbiAgICAgIG1hcmtzID0gW3tuYW1lOiAndGhpcycsIHBvc2l0aW9uOiBzdGFydFBvc31dO1xuICAgICAgcG9zKys7XG4gICAgICBicmVha1xuICAgIGNhc2UgJyonOlxuICAgICAgbWFya3MgPSBbe25hbWU6ICdldmVyeXRoaW5nJywgcG9zaXRpb246IHN0YXJ0UG9zfV07XG4gICAgICBwb3MrKztcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnJCc6IHtcbiAgICAgIGxldCBpZGVudExlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MgKyAxLCBJREVOVCk7XG4gICAgICBpZiAoaWRlbnRMZW4pIHtcbiAgICAgICAgcG9zICs9IDEgKyBpZGVudExlbjtcbiAgICAgICAgbWFya3MgPSBbXG4gICAgICAgICAge25hbWU6ICdwYXJhbScsIHBvc2l0aW9uOiBzdGFydFBvc30sXG4gICAgICAgICAge25hbWU6ICdpZGVudCcsIHBvc2l0aW9uOiBzdGFydFBvcyArIDF9LFxuICAgICAgICAgIHtuYW1lOiAnaWRlbnRfZW5kJywgcG9zaXRpb246IHBvc30sXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBsZXQgbnVtTGVuID0gcGFyc2VSZWdleChzdHIsIHBvcywgTlVNKTtcbiAgICAgIGlmIChudW1MZW4pIHtcbiAgICAgICAgcG9zICs9IG51bUxlbjtcbiAgICAgICAgbGV0IG5hbWUgPSAnaW50ZWdlcic7XG5cbiAgICAgICAgaWYgKHN0cltwb3NdID09PSAnLicpIHtcbiAgICAgICAgICBsZXQgZnJhY0xlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MgKyAxLCBOVU0pO1xuICAgICAgICAgIGlmIChmcmFjTGVuKSB7XG4gICAgICAgICAgICBuYW1lID0gJ2Zsb2F0JztcbiAgICAgICAgICAgIHBvcyArPSAxICsgZnJhY0xlbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyW3Bvc10gPT09ICdlJyB8fCBzdHJbcG9zXSA9PT0gJ0UnKSB7XG4gICAgICAgICAgbmFtZSA9ICdzY2knO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIGlmIChzdHJbcG9zXSA9PT0gJysnIHx8IHN0cltwb3NdID09PSAnLScpIHtcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgZXhwTGVuID0gcGFyc2VSZWdleChzdHIsIHBvcywgTlVNKTtcbiAgICAgICAgICBpZiAoIWV4cExlbikgcmV0dXJuIHt0eXBlOiAnZXJyb3InLCBwb3NpdGlvbjogcG9zfVxuICAgICAgICAgIHBvcyArPSBleHBMZW47XG4gICAgICAgIH1cblxuICAgICAgICBtYXJrcyA9IFtcbiAgICAgICAgICB7bmFtZSwgcG9zaXRpb246IHN0YXJ0UG9zfSxcbiAgICAgICAgICB7bmFtZTogbmFtZSArICdfZW5kJywgcG9zaXRpb246IHBvc30sXG4gICAgICAgIF07XG5cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgbGV0IGlkZW50TGVuID0gcGFyc2VSZWdleChzdHIsIHBvcywgSURFTlQpO1xuICAgICAgaWYgKGlkZW50TGVuKSB7XG4gICAgICAgIHBvcyArPSBpZGVudExlbjtcbiAgICAgICAgc3dpdGNoIChzdHJbcG9zXSkge1xuICAgICAgICAgIGNhc2UgJzonOlxuICAgICAgICAgIGNhc2UgJygnOiB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gcGFyc2VGdW5jQ2FsbChzdHIsIHN0YXJ0UG9zLCBwb3MpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmVzdWx0XG4gICAgICAgICAgICBtYXJrcyA9IHJlc3VsdC5tYXJrcztcbiAgICAgICAgICAgIHBvcyA9IHJlc3VsdC5wb3NpdGlvbjtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIG1hcmtzID0gW1xuICAgICAgICAgICAgICB7bmFtZTogJ3RoaXNfYXR0cicsIHBvc2l0aW9uOiBzdGFydFBvc30sXG4gICAgICAgICAgICAgIHtuYW1lOiAnaWRlbnQnLCBwb3NpdGlvbjogc3RhcnRQb3N9LFxuICAgICAgICAgICAgICB7bmFtZTogJ2lkZW50X2VuZCcsIHBvc2l0aW9uOiBwb3N9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghbWFya3MpIHtcbiAgICByZXR1cm4ge3R5cGU6ICdlcnJvcicsIHBvc2l0aW9uOiBwb3N9XG4gIH1cblxuICBsZXQgbGhzTGV2ZWwgPSAxMjtcbiAgbGV0IHRyYXY7XG5cbiAgbG9vcDogd2hpbGUgKHRydWUpIHtcbiAgICBsZXQgaW5uZXJQb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICAgIGlmIChpbm5lclBvcyA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgcG9zID0gaW5uZXJQb3M7XG4gICAgICBicmVha1xuICAgIH1cblxuICAgIHRyYXYgPSBwYXJzZVRyYXZlcnNhbChzdHIsIGlubmVyUG9zKTtcbiAgICBpZiAodHJhdi50eXBlID09PSAnc3VjY2VzcycpIHtcbiAgICAgIG1hcmtzLnVuc2hpZnQoe25hbWU6ICd0cmF2ZXJzZScsIHBvc2l0aW9uOiBzdGFydFBvc30pO1xuICAgICAgd2hpbGUgKHRyYXYudHlwZSA9PT0gJ3N1Y2Nlc3MnKSB7XG4gICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHRyYXYubWFya3MpO1xuICAgICAgICBwb3MgPSB0cmF2LnBvc2l0aW9uO1xuICAgICAgICB0cmF2ID0gcGFyc2VUcmF2ZXJzYWwoc3RyLCBza2lwV1Moc3RyLCBwb3MpKTtcbiAgICAgIH1cbiAgICAgIG1hcmtzLnB1c2goe25hbWU6ICd0cmF2ZXJzYWxfZW5kJywgcG9zaXRpb246IHBvc30pO1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBsZXQgdG9rZW4gPSBzdHJbaW5uZXJQb3NdO1xuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgIGNhc2UgJz0nOiB7XG4gICAgICAgIGxldCBuZXh0VG9rZW4gPSBzdHJbaW5uZXJQb3MgKyAxXTtcbiAgICAgICAgc3dpdGNoIChuZXh0VG9rZW4pIHtcbiAgICAgICAgICBjYXNlICc+Jzoge1xuICAgICAgICAgICAgLy8gPT5cbiAgICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfUEFJUiB8fCBsaHNMZXZlbCA8PSBQUkVDX1BBSVIpIGJyZWFrIGxvb3BcbiAgICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCBQUkVDX1BBSVIpO1xuICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmhzXG4gICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7bmFtZTogJ3BhaXInLCBwb3NpdGlvbjogc3RhcnRQb3N9KTtcbiAgICAgICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19QQUlSO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnPSc6IHtcbiAgICAgICAgICAgIC8vID09XG4gICAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX0NPTVAgfHwgbGhzTGV2ZWwgPD0gUFJFQ19DT01QKSBicmVhayBsb29wXG4gICAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgNSk7XG4gICAgICAgICAgICBpZiAocmhzLnR5cGUgPT09ICdlcnJvcicpIHJldHVybiByaHNcbiAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoe25hbWU6ICdjb21wJywgcG9zaXRpb246IHN0YXJ0UG9zfSk7XG4gICAgICAgICAgICBtYXJrcy5wdXNoKHtuYW1lOiAnb3AnLCBwb3NpdGlvbjogaW5uZXJQb3N9LCB7bmFtZTogJ29wX2VuZCcsIHBvc2l0aW9uOiBpbm5lclBvcyArIDJ9KTtcbiAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfQ09NUDtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhayBsb29wXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJysnOiB7XG4gICAgICAgIGlmIChsZXZlbCA+IFBSRUNfQUREIHx8IGxoc0xldmVsIDwgUFJFQ19BREQpIGJyZWFrIGxvb3BcbiAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIFBSRUNfQUREICsgMSk7XG4gICAgICAgIGlmIChyaHMudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJoc1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICBtYXJrcy51bnNoaWZ0KHtuYW1lOiAnYWRkJywgcG9zaXRpb246IHN0YXJ0UG9zfSk7XG4gICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX0FERDtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJy0nOiB7XG4gICAgICAgIGlmIChsZXZlbCA+IFBSRUNfU1VCIHx8IGxoc0xldmVsIDwgUFJFQ19TVUIpIGJyZWFrIGxvb3BcbiAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIFBSRUNfU1VCICsgMSk7XG4gICAgICAgIGlmIChyaHMudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJoc1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICBtYXJrcy51bnNoaWZ0KHtuYW1lOiAnc3ViJywgcG9zaXRpb246IHN0YXJ0UG9zfSk7XG4gICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX1NVQjtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJyonOiB7XG4gICAgICAgIGlmIChzdHJbaW5uZXJQb3MgKyAxXSA9PT0gJyonKSB7XG4gICAgICAgICAgLy8gKipcbiAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX1BPVyB8fCBsaHNMZXZlbCA8PSBQUkVDX1BPVykgYnJlYWsgbG9vcFxuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCBQUkVDX1BPVyk7XG4gICAgICAgICAgaWYgKHJocy50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmhzXG4gICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICBtYXJrcy51bnNoaWZ0KHtuYW1lOiAncG93JywgcG9zaXRpb246IHN0YXJ0UG9zfSk7XG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19QT1c7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICpcbiAgICAgICAgaWYgKGxldmVsID4gUFJFQ19NVUwgfHwgbGhzTGV2ZWwgPCBQUkVDX01VTCkgYnJlYWsgbG9vcFxuICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAxKSwgUFJFQ19NVUwgKyAxKTtcbiAgICAgICAgaWYgKHJocy50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmhzXG4gICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgIG1hcmtzLnVuc2hpZnQoe25hbWU6ICdtdWwnLCBwb3NpdGlvbjogc3RhcnRQb3N9KTtcbiAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICBsaHNMZXZlbCA9IFBSRUNfTVVMO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY2FzZSAnLyc6IHtcbiAgICAgICAgaWYgKGxldmVsID4gUFJFQ19ESVYgfHwgbGhzTGV2ZWwgPCBQUkVDX0RJVikgYnJlYWsgbG9vcFxuICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAxKSwgUFJFQ19ESVYgKyAxKTtcbiAgICAgICAgaWYgKHJocy50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmhzXG4gICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgIG1hcmtzLnVuc2hpZnQoe25hbWU6ICdkaXYnLCBwb3NpdGlvbjogc3RhcnRQb3N9KTtcbiAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICBsaHNMZXZlbCA9IFBSRUNfRElWO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY2FzZSAnJSc6IHtcbiAgICAgICAgaWYgKGxldmVsID4gUFJFQ19NT0QgfHwgbGhzTGV2ZWwgPCBQUkVDX01PRCkgYnJlYWsgbG9vcFxuICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAxKSwgUFJFQ19NT0QgKyAxKTtcbiAgICAgICAgaWYgKHJocy50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmhzXG4gICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgIG1hcmtzLnVuc2hpZnQoe25hbWU6ICdtb2QnLCBwb3NpdGlvbjogc3RhcnRQb3N9KTtcbiAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICBsaHNMZXZlbCA9IFBSRUNfTU9EO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY2FzZSAnPCc6XG4gICAgICBjYXNlICc+Jzoge1xuICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX0NPTVAgfHwgbGhzTGV2ZWwgPD0gUFJFQ19DT01QKSBicmVhayBsb29wXG4gICAgICAgIGxldCBuZXh0UG9zID0gaW5uZXJQb3MgKyAxO1xuICAgICAgICBpZiAoc3RyW25leHRQb3NdID09PSAnPScpIHtcbiAgICAgICAgICBuZXh0UG9zKys7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIG5leHRQb3MpLCBQUkVDX0NPTVAgKyAxKTtcbiAgICAgICAgaWYgKHJocy50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmhzXG4gICAgICAgIG1hcmtzLnVuc2hpZnQoe25hbWU6ICdjb21wJywgcG9zaXRpb246IHN0YXJ0UG9zfSk7XG4gICAgICAgIG1hcmtzLnB1c2goe25hbWU6ICdvcCcsIHBvc2l0aW9uOiBpbm5lclBvc30sIHtuYW1lOiAnb3BfZW5kJywgcG9zaXRpb246IG5leHRQb3N9KTtcbiAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICBsaHNMZXZlbCA9IFBSRUNfQ09NUDtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ3wnOiB7XG4gICAgICAgIGlmIChzdHJbaW5uZXJQb3MgKyAxXSA9PT0gJ3wnKSB7XG4gICAgICAgICAgLy8gfHxcbiAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX09SIHx8IGxoc0xldmVsIDwgUFJFQ19PUikgYnJlYWsgbG9vcFxuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCBQUkVDX09SICsgMSk7XG4gICAgICAgICAgaWYgKHJocy50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmhzXG4gICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICBtYXJrcy51bnNoaWZ0KHtuYW1lOiAnb3InLCBwb3NpdGlvbjogc3RhcnRQb3N9KTtcbiAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX09SO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChsZXZlbCA+IDExIHx8IGxoc0xldmVsIDwgMTEpIGJyZWFrIGxvb3BcbiAgICAgICAgICAvLyBwaXBlIGNhbGxcbiAgICAgICAgICBsZXQgaWRlbnRQb3MgPSBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpO1xuICAgICAgICAgIGxldCBpZGVudExlbiA9IHBhcnNlUmVnZXgoc3RyLCBpZGVudFBvcywgSURFTlQpO1xuICAgICAgICAgIGlmICghaWRlbnRMZW4pIHJldHVybiB7dHlwZTogJ2Vycm9yJywgcG9zaXRpb246IGlkZW50UG9zfVxuICAgICAgICAgIHBvcyA9IGlkZW50UG9zICsgaWRlbnRMZW47XG4gICAgICAgICAgaWYgKHN0cltwb3NdID09PSAnKCcgfHwgc3RyW3Bvc10gPT09ICc6Jykge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlRnVuY0NhbGwoc3RyLCBpZGVudFBvcywgcG9zKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJlc3VsdFxuICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmVzdWx0Lm1hcmtzKTtcbiAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoe25hbWU6ICdwaXBlY2FsbCcsIHBvc2l0aW9uOiBzdGFydFBvc30pO1xuICAgICAgICAgICAgcG9zID0gcmVzdWx0LnBvc2l0aW9uO1xuICAgICAgICAgICAgbGhzTGV2ZWwgPSAxMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJyYnOiB7XG4gICAgICAgIC8vICYmXG4gICAgICAgIGlmIChzdHJbaW5uZXJQb3MgKyAxXSAhPSAnJicpIGJyZWFrIGxvb3BcbiAgICAgICAgaWYgKGxldmVsID4gUFJFQ19BTkQgfHwgbGhzTGV2ZWwgPCBQUkVDX0FORCkgYnJlYWsgbG9vcFxuICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgUFJFQ19BTkQgKyAxKTtcbiAgICAgICAgaWYgKHJocy50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmhzXG4gICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgIG1hcmtzLnVuc2hpZnQoe25hbWU6ICdhbmQnLCBwb3NpdGlvbjogc3RhcnRQb3N9KTtcbiAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICBsaHNMZXZlbCA9IFBSRUNfQU5EO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY2FzZSAnISc6IHtcbiAgICAgICAgLy8gIT1cbiAgICAgICAgaWYgKHN0cltpbm5lclBvcyArIDFdICE9PSAnPScpIGJyZWFrIGxvb3BcbiAgICAgICAgaWYgKGxldmVsID4gUFJFQ19DT01QIHx8IGxoc0xldmVsIDwgUFJFQ19DT01QKSBicmVhayBsb29wXG4gICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCBQUkVDX0NPTVAgKyAxKTtcbiAgICAgICAgaWYgKHJocy50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmhzXG4gICAgICAgIG1hcmtzLnVuc2hpZnQoe25hbWU6ICdjb21wJywgcG9zaXRpb246IHN0YXJ0UG9zfSk7XG4gICAgICAgIG1hcmtzLnB1c2goe25hbWU6ICdvcCcsIHBvc2l0aW9uOiBpbm5lclBvc30sIHtuYW1lOiAnb3BfZW5kJywgcG9zaXRpb246IGlubmVyUG9zICsgMn0pO1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgIGxoc0xldmVsID0gUFJFQ19DT01QO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY2FzZSAnZCc6IHtcbiAgICAgICAgLy8gYXNjXG4gICAgICAgIGlmIChzdHIuc2xpY2UoaW5uZXJQb3MsIGlubmVyUG9zICsgNCkgIT09ICdkZXNjJykgYnJlYWsgbG9vcFxuICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX09SREVSIHx8IGxoc0xldmVsIDwgUFJFQ19PUkRFUikgYnJlYWsgbG9vcFxuICAgICAgICBtYXJrcy51bnNoaWZ0KHtuYW1lOiAnZGVzYycsIHBvc2l0aW9uOiBzdGFydFBvc30pO1xuICAgICAgICBwb3MgPSBpbm5lclBvcyArIDQ7XG4gICAgICAgIGxoc0xldmVsID0gUFJFQ19PUkRFUjtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2EnOiB7XG4gICAgICAgIC8vIGFzY1xuICAgICAgICBpZiAoc3RyLnNsaWNlKGlubmVyUG9zLCBpbm5lclBvcyArIDMpICE9PSAnYXNjJykgYnJlYWsgbG9vcFxuICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX09SREVSIHx8IGxoc0xldmVsIDwgUFJFQ19PUkRFUikgYnJlYWsgbG9vcFxuICAgICAgICBtYXJrcy51bnNoaWZ0KHtuYW1lOiAnYXNjJywgcG9zaXRpb246IHN0YXJ0UG9zfSk7XG4gICAgICAgIHBvcyA9IGlubmVyUG9zICsgMztcbiAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX09SREVSO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBsZXQgaWRlbnQgPSBwYXJzZVJlZ2V4U3RyKHN0ciwgaW5uZXJQb3MsIElERU5UKTtcbiAgICAgICAgc3dpdGNoIChpZGVudCkge1xuICAgICAgICAgIGNhc2UgJ2luJzoge1xuICAgICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19DT01QIHx8IGxoc0xldmVsIDw9IFBSRUNfQ09NUCkgYnJlYWsgbG9vcFxuXG4gICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpO1xuXG4gICAgICAgICAgICBsZXQgaXNHcm91cCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoc3RyW3Bvc10gPT09ICcoJykge1xuICAgICAgICAgICAgICBpc0dyb3VwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCByYW5nZVBvcyA9IHBvcztcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIFBSRUNfQ09NUCArIDEpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmVzdWx0XG5cbiAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHJlc3VsdC5wb3NpdGlvbik7XG5cbiAgICAgICAgICAgIGlmIChzdHJbcG9zXSA9PT0gJy4nICYmIHN0cltwb3MgKyAxXSA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgIC8vIExIUyBpbiBSQU5HRVxuICAgICAgICAgICAgICBsZXQgdHlwZSA9ICdpbmNfcmFuZ2UnO1xuICAgICAgICAgICAgICBpZiAoc3RyW3BvcyArIDJdID09PSAnLicpIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gJ2V4Y19yYW5nZSc7XG4gICAgICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMik7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgcG9zLCBQUkVDX0NPTVAgKyAxKTtcbiAgICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmhzXG4gICAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoe25hbWU6ICdpbl9yYW5nZScsIHBvc2l0aW9uOiBzdGFydFBvc30pO1xuICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdCh7bmFtZTogdHlwZSwgcG9zaXRpb246IHJhbmdlUG9zfSwgcmVzdWx0Lm1hcmtzLCByaHMubWFya3MpO1xuICAgICAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBMSFMgaW4gUkhTXG4gICAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoe25hbWU6ICdjb21wJywgcG9zaXRpb246IHN0YXJ0UG9zfSk7XG4gICAgICAgICAgICAgIG1hcmtzLnB1c2goe25hbWU6ICdvcCcsIHBvc2l0aW9uOiBpbm5lclBvc30sIHtuYW1lOiAnb3BfZW5kJywgcG9zaXRpb246IGlubmVyUG9zICsgMn0pO1xuICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyZXN1bHQubWFya3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNHcm91cCkge1xuICAgICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICAgICAgICAgICAgICBpZiAoc3RyW3Bvc10gIT09ICcpJykgcmV0dXJuIHt0eXBlOiAnZXJyb3InLCBwb3NpdGlvbjogcG9zfVxuICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX0NPTVA7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdtYXRjaCc6IHtcbiAgICAgICAgICAgIC8vIG1hdGNoIG9wZXJhdG9yXG4gICAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX0NPTVAgfHwgbGhzTGV2ZWwgPD0gUFJFQ19DT01QKSBicmVhayBsb29wXG4gICAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyA1KSwgUFJFQ19DT01QICsgMSk7XG4gICAgICAgICAgICBpZiAocmhzLnR5cGUgPT09ICdlcnJvcicpIHJldHVybiByaHNcbiAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoe25hbWU6ICdjb21wJywgcG9zaXRpb246IHN0YXJ0UG9zfSk7XG4gICAgICAgICAgICBtYXJrcy5wdXNoKHtuYW1lOiAnb3AnLCBwb3NpdGlvbjogaW5uZXJQb3N9LCB7bmFtZTogJ29wX2VuZCcsIHBvc2l0aW9uOiBpbm5lclBvcyArIDV9KTtcbiAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgICBsaHNMZXZlbCA9IDQ7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBicmVhayBsb29wXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbGV0IGZhaWxQb3NpdGlvbiA9IHRyYXY/LnR5cGUgPT09ICdlcnJvcicgJiYgdHJhdi5wb3NpdGlvbjtcblxuICByZXR1cm4ge3R5cGU6ICdzdWNjZXNzJywgbWFya3MsIHBvc2l0aW9uOiBwb3MsIGZhaWxQb3NpdGlvbn1cbn1cblxuZnVuY3Rpb24gcGFyc2VUcmF2ZXJzYWwoc3RyLCBwb3MpIHtcbiAgbGV0IHN0YXJ0UG9zID0gcG9zO1xuICBzd2l0Y2ggKHN0cltwb3NdKSB7XG4gICAgY2FzZSAnLic6IHtcbiAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgbGV0IGlkZW50U3RhcnQgPSBwb3M7XG4gICAgICBsZXQgaWRlbnRMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgcG9zLCBJREVOVCk7XG4gICAgICBpZiAoIWlkZW50TGVuKSByZXR1cm4ge3R5cGU6ICdlcnJvcicsIHBvc2l0aW9uOiBwb3N9XG4gICAgICBwb3MgKz0gaWRlbnRMZW47XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdzdWNjZXNzJyxcbiAgICAgICAgbWFya3M6IFtcbiAgICAgICAgICB7bmFtZTogJ2F0dHJfYWNjZXNzJywgcG9zaXRpb246IHN0YXJ0UG9zfSxcbiAgICAgICAgICB7bmFtZTogJ2lkZW50JywgcG9zaXRpb246IGlkZW50U3RhcnR9LFxuICAgICAgICAgIHtuYW1lOiAnaWRlbnRfZW5kJywgcG9zaXRpb246IHBvc30sXG4gICAgICAgIF0sXG4gICAgICAgIHBvc2l0aW9uOiBwb3MsXG4gICAgICB9XG4gICAgfVxuICAgIGNhc2UgJy0nOlxuICAgICAgaWYgKHN0cltwb3MgKyAxXSAhPT0gJz4nKSByZXR1cm4ge3R5cGU6ICdlcnJvcicsIHBvc2l0aW9uOiBwb3N9XG4gICAgICAvLyAtPlxuXG4gICAgICBsZXQgbWFya3MgPSBbe25hbWU6ICdkZXJlZicsIHBvc2l0aW9uOiBzdGFydFBvc31dO1xuICAgICAgcG9zICs9IDI7XG5cbiAgICAgIGxldCBpZGVudFBvcyA9IHNraXBXUyhzdHIsIHBvcyk7XG4gICAgICBsZXQgaWRlbnRMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgaWRlbnRQb3MsIElERU5UKTtcbiAgICAgIGlmIChpZGVudExlbikge1xuICAgICAgICBwb3MgPSBpZGVudFBvcyArIGlkZW50TGVuO1xuICAgICAgICBtYXJrcy5wdXNoKFxuICAgICAgICAgIHtuYW1lOiAnZGVyZWZfYXR0cicsIHBvc2l0aW9uOiBpZGVudFBvc30sXG4gICAgICAgICAge25hbWU6ICdpZGVudCcsIHBvc2l0aW9uOiBpZGVudFBvc30sXG4gICAgICAgICAge25hbWU6ICdpZGVudF9lbmQnLCBwb3NpdGlvbjogcG9zfVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnc3VjY2VzcycsXG4gICAgICAgIG1hcmtzLFxuICAgICAgICBwb3NpdGlvbjogcG9zLFxuICAgICAgfVxuICAgIGNhc2UgJ1snOiB7XG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcblxuICAgICAgaWYgKHN0cltwb3NdID09PSAnXScpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnc3VjY2VzcycsXG4gICAgICAgICAgbWFya3M6IFt7bmFtZTogJ2FycmF5X3Bvc3RmaXgnLCBwb3NpdGlvbjogc3RhcnRQb3N9XSxcbiAgICAgICAgICBwb3NpdGlvbjogcG9zICsgMSxcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZXQgcmFuZ2VQb3MgPSBwb3M7XG4gICAgICBsZXQgcmVzdWx0ID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJlc3VsdFxuXG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCByZXN1bHQucG9zaXRpb24pO1xuXG4gICAgICBpZiAoc3RyW3Bvc10gPT09ICcuJyAmJiBzdHJbcG9zICsgMV0gPT09ICcuJykge1xuICAgICAgICBsZXQgdHlwZSA9ICdpbmNfcmFuZ2UnO1xuICAgICAgICBpZiAoc3RyW3BvcyArIDJdID09PSAnLicpIHtcbiAgICAgICAgICB0eXBlID0gJ2V4Y19yYW5nZSc7XG4gICAgICAgICAgcG9zICs9IDM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgIH1cblxuICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgICAgaWYgKHJocy50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmhzXG4gICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHJocy5wb3NpdGlvbik7XG4gICAgICAgIGlmIChzdHJbcG9zXSAhPT0gJ10nKSByZXR1cm4ge3R5cGU6ICdlcnJvcicsIHBvc2l0aW9uOiBwb3N9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnc3VjY2VzcycsXG4gICAgICAgICAgbWFya3M6IFtcbiAgICAgICAgICAgIHtuYW1lOiAnc2xpY2UnLCBwb3NpdGlvbjogc3RhcnRQb3N9LFxuICAgICAgICAgICAge25hbWU6IHR5cGUsIHBvc2l0aW9uOiByYW5nZVBvc30sXG4gICAgICAgICAgXS5jb25jYXQocmVzdWx0Lm1hcmtzLCByaHMubWFya3MpLFxuICAgICAgICAgIHBvc2l0aW9uOiBwb3MgKyAxLFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHJbcG9zXSAhPT0gJ10nKSByZXR1cm4ge3R5cGU6ICdlcnJvcicsIHBvc2l0aW9uOiBwb3N9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdzdWNjZXNzJyxcbiAgICAgICAgbWFya3M6IFt7bmFtZTogJ3NxdWFyZV9icmFja2V0JywgcG9zaXRpb246IHN0YXJ0UG9zfV0uY29uY2F0KHJlc3VsdC5tYXJrcyksXG4gICAgICAgIHBvc2l0aW9uOiBwb3MgKyAxLFxuICAgICAgfVxuICAgIH1cbiAgICBjYXNlICd8Jzoge1xuICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gICAgICBpZiAoc3RyW3Bvc10gPT09ICd7Jykge1xuICAgICAgICBsZXQgcmVzdWx0ID0gcGFyc2VPYmplY3Qoc3RyLCBwb3MpO1xuICAgICAgICBpZiAocmVzdWx0LnR5cGUgPT09ICdlcnJvcicpIHJldHVybiByZXN1bHRcbiAgICAgICAgcmVzdWx0Lm1hcmtzLnVuc2hpZnQoe25hbWU6ICdwcm9qZWN0aW9uJywgcG9zaXRpb246IHN0YXJ0UG9zfSk7XG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNhc2UgJ3snOiB7XG4gICAgICBsZXQgcmVzdWx0ID0gcGFyc2VPYmplY3Qoc3RyLCBwb3MpO1xuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSAnZXJyb3InKSByZXR1cm4gcmVzdWx0XG4gICAgICByZXN1bHQubWFya3MudW5zaGlmdCh7bmFtZTogJ3Byb2plY3Rpb24nLCBwb3NpdGlvbjogc3RhcnRQb3N9KTtcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge3R5cGU6ICdlcnJvcicsIHBvc2l0aW9uOiBwb3N9XG59XG5cbmZ1bmN0aW9uIHBhcnNlRnVuY0NhbGwoc3RyLCBzdGFydFBvcywgcG9zKSB7XG4gIGxldCBtYXJrcyA9IFtdO1xuXG4gIG1hcmtzLnB1c2goe25hbWU6ICdmdW5jX2NhbGwnLCBwb3NpdGlvbjogc3RhcnRQb3N9KTtcblxuICBpZiAoc3RyW3Bvc10gPT09ICc6JyAmJiBzdHJbcG9zICsgMV0gPT09ICc6Jykge1xuICAgIG1hcmtzLnB1c2goe25hbWU6ICduYW1lc3BhY2UnLCBwb3NpdGlvbjogc3RhcnRQb3N9KTtcbiAgICBtYXJrcy5wdXNoKHtuYW1lOiAnaWRlbnQnLCBwb3NpdGlvbjogc3RhcnRQb3N9LCB7bmFtZTogJ2lkZW50X2VuZCcsIHBvc2l0aW9uOiBwb3N9KTtcbiAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAyKTtcbiAgICBsZXQgbmFtZUxlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MsIElERU5UKTtcbiAgICBpZiAoIW5hbWVMZW4pIHJldHVybiB7dHlwZTogJ2Vycm9yJywgcG9zaXRpb246IHBvc31cbiAgICBtYXJrcy5wdXNoKHtuYW1lOiAnaWRlbnQnLCBwb3NpdGlvbjogcG9zfSwge25hbWU6ICdpZGVudF9lbmQnLCBwb3NpdGlvbjogcG9zICsgbmFtZUxlbn0pO1xuICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIG5hbWVMZW4pO1xuICAgIGlmIChzdHJbcG9zXSAhPT0gJygnKSByZXR1cm4ge3R5cGU6ICdlcnJvcicsIHBvc2l0aW9uOiBwb3N9XG4gICAgcG9zKys7XG4gIH0gZWxzZSB7XG4gICAgbWFya3MucHVzaCh7bmFtZTogJ2lkZW50JywgcG9zaXRpb246IHN0YXJ0UG9zfSwge25hbWU6ICdpZGVudF9lbmQnLCBwb3NpdGlvbjogcG9zfSk7XG4gICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gIH1cblxuICBsZXQgbGFzdFBvcyA9IHBvcztcblxuICBpZiAoc3RyW3Bvc10gIT09ICcpJykge1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBsZXQgcmVzdWx0ID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHJlc3VsdFxuICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmVzdWx0Lm1hcmtzKTtcbiAgICAgIGxhc3RQb3MgPSByZXN1bHQucG9zaXRpb247XG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCByZXN1bHQucG9zaXRpb24pO1xuICAgICAgaWYgKHN0cltwb3NdICE9PSAnLCcpIGJyZWFrXG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgICAgIC8vIEFsc28gYWxsb3cgdHJhaWxpbmcgY29tbWFzXG4gICAgICBpZiAoc3RyW3Bvc10gPT09ICcpJykgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RyW3Bvc10gIT09ICcpJykge1xuICAgIHJldHVybiB7dHlwZTogJ2Vycm9yJywgcG9zaXRpb246IHBvc31cbiAgfVxuXG4gIC8vIE5PVEU6IGEgYml0IGFyYml0cmFyeSB0aGUgZnVuY19hcmdzX2VuZCBwb2ludHMgY29tZXMgYmVmb3JlIHRoZSB3aGl0ZXNwYWNlLlxuICBtYXJrcy5wdXNoKHtuYW1lOiAnZnVuY19hcmdzX2VuZCcsIHBvc2l0aW9uOiBsYXN0UG9zfSk7XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnc3VjY2VzcycsXG4gICAgbWFya3MsXG4gICAgcG9zaXRpb246IHBvcyArIDEsXG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VPYmplY3Qoc3RyLCBwb3MpIHtcbiAgbGV0IG1hcmtzID0gW3tuYW1lOiAnb2JqZWN0JywgcG9zaXRpb246IHBvc31dO1xuICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcblxuICB3aGlsZSAoc3RyW3Bvc10gIT09ICd9Jykge1xuICAgIGxldCBwYWlyUG9zID0gcG9zO1xuXG4gICAgaWYgKHN0ci5zbGljZShwb3MsIHBvcyArIDMpID09PSAnLi4uJykge1xuICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMyk7XG4gICAgICBpZiAoc3RyW3Bvc10gIT09ICd9JyAmJiBzdHJbcG9zXSAhPT0gJywnKSB7XG4gICAgICAgIGxldCBleHByID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgICAgaWYgKGV4cHIudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIGV4cHJcbiAgICAgICAgbWFya3MucHVzaCh7bmFtZTogJ29iamVjdF9zcGxhdCcsIHBvc2l0aW9uOiBwYWlyUG9zfSk7XG4gICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KGV4cHIubWFya3MpO1xuICAgICAgICBwb3MgPSBleHByLnBvc2l0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFya3MucHVzaCh7bmFtZTogJ29iamVjdF9zcGxhdF90aGlzJywgcG9zaXRpb246IHBhaXJQb3N9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGV4cHIgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xuICAgICAgaWYgKGV4cHIudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIGV4cHJcbiAgICAgIGxldCBuZXh0UG9zID0gc2tpcFdTKHN0ciwgZXhwci5wb3NpdGlvbik7XG4gICAgICBpZiAoZXhwci5tYXJrc1swXS5uYW1lID09PSAnc3RyJyAmJiBzdHJbbmV4dFBvc10gPT09ICc6Jykge1xuICAgICAgICBsZXQgdmFsdWUgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBuZXh0UG9zICsgMSksIDApO1xuICAgICAgICBpZiAodmFsdWUudHlwZSA9PT0gJ2Vycm9yJykgcmV0dXJuIHZhbHVlXG4gICAgICAgIG1hcmtzLnB1c2goe25hbWU6ICdvYmplY3RfcGFpcicsIHBvc2l0aW9uOiBwYWlyUG9zfSk7XG4gICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KGV4cHIubWFya3MsIHZhbHVlLm1hcmtzKTtcbiAgICAgICAgcG9zID0gdmFsdWUucG9zaXRpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdCh7bmFtZTogJ29iamVjdF9leHByJywgcG9zaXRpb246IHBvc30sIGV4cHIubWFya3MpO1xuICAgICAgICBwb3MgPSBleHByLnBvc2l0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICAgIGlmIChzdHJbcG9zXSAhPT0gJywnKSBicmVha1xuICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICB9XG5cbiAgaWYgKHN0cltwb3NdICE9PSAnfScpIHtcbiAgICByZXR1cm4ge3R5cGU6ICdlcnJvcicsIHBvc2l0aW9uOiBwb3N9XG4gIH1cblxuICBwb3MrKztcbiAgbWFya3MucHVzaCh7bmFtZTogJ29iamVjdF9lbmQnLCBwb3NpdGlvbjogcG9zfSk7XG4gIHJldHVybiB7dHlwZTogJ3N1Y2Nlc3MnLCBtYXJrcywgcG9zaXRpb246IHBvc31cbn1cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcoc3RyLCBwb3MpIHtcbiAgbGV0IHRva2VuID0gc3RyW3Bvc107XG4gIHBvcyA9IHBvcyArIDE7XG4gIGNvbnN0IG1hcmtzID0gW3tuYW1lOiAnc3RyJywgcG9zaXRpb246IHBvc31dO1xuICBzdHI6IGZvciAoOyA7IHBvcysrKSB7XG4gICAgaWYgKHBvcyA+IHN0ci5sZW5ndGgpIHJldHVybiB7dHlwZTogJ2Vycm9yJywgcG9zaXRpb246IHBvc31cblxuICAgIHN3aXRjaCAoc3RyW3Bvc10pIHtcbiAgICAgIGNhc2UgdG9rZW46IHtcbiAgICAgICAgbWFya3MucHVzaCh7bmFtZTogJ3N0cl9lbmQnLCBwb3NpdGlvbjogcG9zfSk7XG4gICAgICAgIHBvcysrO1xuICAgICAgICBicmVhayBzdHJcbiAgICAgIH1cbiAgICAgIGNhc2UgJ1xcXFwnOiB7XG4gICAgICAgIG1hcmtzLnB1c2goe25hbWU6ICdzdHJfcGF1c2UnLCBwb3NpdGlvbjogcG9zfSk7XG4gICAgICAgIGlmIChzdHJbcG9zICsgMV0gPT09ICd1Jykge1xuICAgICAgICAgIGlmIChzdHJbcG9zICsgMl0gPT09ICd7Jykge1xuICAgICAgICAgICAgbWFya3MucHVzaCh7bmFtZTogJ3VuaWNvZGVfaGV4JywgcG9zaXRpb246IHBvcyArIDN9KTtcbiAgICAgICAgICAgIHBvcyA9IHN0ci5pbmRleE9mKCd9JywgcG9zICsgMyk7XG4gICAgICAgICAgICBtYXJrcy5wdXNoKHtuYW1lOiAndW5pY29kZV9oZXhfZW5kJywgcG9zaXRpb246IHBvc30pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXJrcy5wdXNoKHtuYW1lOiAndW5pY29kZV9oZXgnLCBwb3NpdGlvbjogcG9zICsgMn0pO1xuICAgICAgICAgICAgbWFya3MucHVzaCh7bmFtZTogJ3VuaWNvZGVfaGV4X2VuZCcsIHBvc2l0aW9uOiBwb3MgKyA2fSk7XG4gICAgICAgICAgICBwb3MgKz0gNTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWFya3MucHVzaCh7bmFtZTogJ3NpbmdsZV9lc2NhcGUnLCBwb3NpdGlvbjogcG9zICsgMX0pO1xuICAgICAgICAgIHBvcyArPSAxO1xuICAgICAgICB9XG4gICAgICAgIG1hcmtzLnB1c2goe25hbWU6ICdzdHJfc3RhcnQnLCBwb3NpdGlvbjogcG9zICsgMX0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7dHlwZTogJ3N1Y2Nlc3MnLCBtYXJrcywgcG9zaXRpb246IHBvc31cbn1cblxuZnVuY3Rpb24gc2tpcFdTKHN0ciwgcG9zKSB7XG4gIHJldHVybiBwb3MgKyBwYXJzZVJlZ2V4KHN0ciwgcG9zLCBXUylcbn1cblxuLyoqXG4gKiBQYXJzZXMgYSByZWdleCBhdCBhIHBvc2l0aW9uIGFuZCByZXR1cm5zIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyB0aGF0IHdhcyBtYXRjaGVkLlxuICovXG5mdW5jdGlvbiBwYXJzZVJlZ2V4KHN0ciwgcG9zLCByZSkge1xuICBsZXQgbSA9IHJlLmV4ZWMoc3RyLnNsaWNlKHBvcykpO1xuICByZXR1cm4gbSA/IG1bMF0ubGVuZ3RoIDogMFxufVxuXG4vKipcbiAqIFBhcnNlcyBhIHJlZ2V4IGF0IGEgcG9zaXRpb24gYW5kIHJldHVybnMgbWF0Y2hlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlUmVnZXhTdHIoc3RyLCBwb3MsIHJlKSB7XG4gIGxldCBtID0gcmUuZXhlYyhzdHIuc2xpY2UocG9zKSk7XG4gIHJldHVybiBtID8gbVswXSA6IG51bGxcbn0vKipcbiAqIEpvaW4gY29tYmluZXMgdHdvIHRyYXZlcnNhbHMsIHJldHVybmluZyBhIG1hcHBlciB3aGljaCBpcyB0aGUgcmVzdWx0IG9mIGZpcnN0XG4gKiBhcHBseWluZyBgYWAgYW5kIHRoZW4gYXBwbHlpbmcgYGJgLlxuICovXG5mdW5jdGlvbiBqb2luKGEsIGIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGJhc2UpIHsgcmV0dXJuIGIoYShiYXNlKSk7IH07XG59XG4vKipcbiAqIE1hcCByZXR1cm5zIGEgbmV3IG1hcHBlciB3aGljaCB3aWxsIHRoZSBpbm5lciBtYXBwZSB0byBlYWNoIGVsZW1lbnQgb2YgdGhlIGFycmF5LlxuICovXG5mdW5jdGlvbiBtYXAoaW5uZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGJhc2UpIHsgcmV0dXJuICh7IHR5cGU6ICdNYXAnLCBiYXNlOiBiYXNlLCBleHByOiBpbm5lcih7IHR5cGU6ICdUaGlzJyB9KSB9KTsgfTtcbn1cbmZ1bmN0aW9uIGZsYXRNYXAoaW5uZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGJhc2UpIHsgcmV0dXJuICh7IHR5cGU6ICdGbGF0TWFwJywgYmFzZTogYmFzZSwgZXhwcjogaW5uZXIoeyB0eXBlOiAnVGhpcycgfSkgfSk7IH07XG59XG5mdW5jdGlvbiB0cmF2ZXJzZUFycmF5KGJ1aWxkLCByaWdodCkge1xuICAgIGlmICghcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdhLWEnLFxuICAgICAgICAgICAgYnVpbGQ6IGJ1aWxkXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN3aXRjaCAocmlnaHQudHlwZSkge1xuICAgICAgICBjYXNlICdhLWEnOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYS1hJyxcbiAgICAgICAgICAgICAgICBidWlsZDogam9pbihidWlsZCwgcmlnaHQuYnVpbGQpXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlICdhLWInOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYS1iJyxcbiAgICAgICAgICAgICAgICBidWlsZDogam9pbihidWlsZCwgcmlnaHQuYnVpbGQpXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlICdiLWInOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYS1hJyxcbiAgICAgICAgICAgICAgICBidWlsZDogam9pbihidWlsZCwgbWFwKHJpZ2h0LmJ1aWxkKSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgJ2ItYSc6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdhLWEnLFxuICAgICAgICAgICAgICAgIGJ1aWxkOiBqb2luKGJ1aWxkLCBmbGF0TWFwKHJpZ2h0LmJ1aWxkKSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiLmNvbmNhdChyaWdodC50eXBlKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdHJhdmVyc2VQbGFpbihtYXBwZXIsIHJpZ2h0KSB7XG4gICAgaWYgKCFyaWdodCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2ItYicsXG4gICAgICAgICAgICBidWlsZDogbWFwcGVyXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN3aXRjaCAocmlnaHQudHlwZSkge1xuICAgICAgICBjYXNlICdhLWEnOlxuICAgICAgICBjYXNlICdiLWEnOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYi1hJyxcbiAgICAgICAgICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnYS1iJzpcbiAgICAgICAgY2FzZSAnYi1iJzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2ItYicsXG4gICAgICAgICAgICAgICAgYnVpbGQ6IGpvaW4obWFwcGVyLCByaWdodC5idWlsZClcbiAgICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiLmNvbmNhdChyaWdodC50eXBlKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdHJhdmVyc2VFbGVtZW50KG1hcHBlciwgcmlnaHQpIHtcbiAgICBpZiAoIXJpZ2h0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnYS1iJyxcbiAgICAgICAgICAgIGJ1aWxkOiBtYXBwZXJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3dpdGNoIChyaWdodC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2EtYSc6XG4gICAgICAgIGNhc2UgJ2ItYSc6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdhLWEnLFxuICAgICAgICAgICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlICdhLWInOlxuICAgICAgICBjYXNlICdiLWInOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYS1iJyxcbiAgICAgICAgICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIuY29uY2F0KHJpZ2h0LnR5cGUpKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0cmF2ZXJzZVByb2plY3Rpb24obWFwcGVyLCByaWdodCkge1xuICAgIGlmICghcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdiLWInLFxuICAgICAgICAgICAgYnVpbGQ6IG1hcHBlclxuICAgICAgICB9O1xuICAgIH1cbiAgICBzd2l0Y2ggKHJpZ2h0LnR5cGUpIHtcbiAgICAgICAgY2FzZSAnYS1hJzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2EtYScsXG4gICAgICAgICAgICAgICAgYnVpbGQ6IGpvaW4obWFwKG1hcHBlciksIHJpZ2h0LmJ1aWxkKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnYS1iJzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2EtYicsXG4gICAgICAgICAgICAgICAgYnVpbGQ6IGpvaW4obWFwKG1hcHBlciksIHJpZ2h0LmJ1aWxkKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnYi1hJzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2ItYScsXG4gICAgICAgICAgICAgICAgYnVpbGQ6IGpvaW4obWFwcGVyLCByaWdodC5idWlsZClcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgJ2ItYic6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdiLWInLFxuICAgICAgICAgICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXG4gICAgICAgICAgICB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIi5jb25jYXQocmlnaHQudHlwZSkpO1xuICAgIH1cbn12YXIgaXNFcXVhbCA9IGVxdWFsaXR5O1xuZnVuY3Rpb24gZXF1YWxpdHkoYSwgYikge1xuICAgIGlmICgoYS50eXBlID09PSAnc3RyaW5nJyAmJiBiLnR5cGUgPT09ICdzdHJpbmcnKSB8fFxuICAgICAgICAoYS50eXBlID09PSAnYm9vbGVhbicgJiYgYi50eXBlID09PSAnYm9vbGVhbicpIHx8XG4gICAgICAgIChhLnR5cGUgPT09ICdudWxsJyAmJiBiLnR5cGUgPT09ICdudWxsJykgfHxcbiAgICAgICAgKGEudHlwZSA9PT0gJ251bWJlcicgJiYgYi50eXBlID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgcmV0dXJuIGEuZGF0YSA9PT0gYi5kYXRhO1xuICAgIH1cbiAgICBpZiAoYS50eXBlID09PSAnZGF0ZXRpbWUnICYmIGIudHlwZSA9PT0gJ2RhdGV0aW1lJykge1xuICAgICAgICByZXR1cm4gYS5kYXRhLmVxdWFscyhiLmRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59dmFyIG9wZXJhdG9ycyA9IHtcbiAgICAnPT0nOiBmdW5jdGlvbiBlcShsZWZ0LCByaWdodCkge1xuICAgICAgICByZXR1cm4gaXNFcXVhbChsZWZ0LCByaWdodCkgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gICAgfSxcbiAgICAnIT0nOiBmdW5jdGlvbiBuZXEobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIGlzRXF1YWwobGVmdCwgcmlnaHQpID8gRkFMU0VfVkFMVUUgOiBUUlVFX1ZBTFVFO1xuICAgIH0sXG4gICAgJz4nOiBmdW5jdGlvbiBndChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAobGVmdC50eXBlID09PSAnc3RyZWFtJyB8fCByaWdodC50eXBlID09PSAnc3RyZWFtJylcbiAgICAgICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgICB2YXIgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUobGVmdC5kYXRhLCByaWdodC5kYXRhKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdCA+IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gICAgfSxcbiAgICAnPj0nOiBmdW5jdGlvbiBndGUobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKGxlZnQudHlwZSA9PT0gJ3N0cmVhbScgfHwgcmlnaHQudHlwZSA9PT0gJ3N0cmVhbScpXG4gICAgICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnRpYWxDb21wYXJlKGxlZnQuZGF0YSwgcmlnaHQuZGF0YSk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQgPj0gMCA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgICB9LFxuICAgICc8JzogZnVuY3Rpb24gbHQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKGxlZnQudHlwZSA9PT0gJ3N0cmVhbScgfHwgcmlnaHQudHlwZSA9PT0gJ3N0cmVhbScpXG4gICAgICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnRpYWxDb21wYXJlKGxlZnQuZGF0YSwgcmlnaHQuZGF0YSk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQgPCAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICAgIH0sXG4gICAgJzw9JzogZnVuY3Rpb24gbHRlKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChsZWZ0LnR5cGUgPT09ICdzdHJlYW0nIHx8IHJpZ2h0LnR5cGUgPT09ICdzdHJlYW0nKVxuICAgICAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICAgIHZhciByZXN1bHQgPSBwYXJ0aWFsQ29tcGFyZShsZWZ0LmRhdGEsIHJpZ2h0LmRhdGEpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0IDw9IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gICAgfSxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lLW1hdGNoaW5nXG4gICAgXCJpblwiOiBmdW5jdGlvbiBpbm9wKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHZhciByaWdodF8xLCByaWdodF8xXzE7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYiwgZV8xXzE7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmlnaHQudHlwZSA9PT0gJ3BhdGgnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnQudHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmlnaHQuZGF0YS5tYXRjaGVzKGxlZnQuZGF0YSkgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyaWdodC5pc0FycmF5KCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDEzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFsxLCA2LCA3LCAxMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHRfMSA9IF9fYXN5bmNWYWx1ZXMocmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbNCAvKnlpZWxkKi8sIHJpZ2h0XzEubmV4dCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEocmlnaHRfMV8xID0gX2Iuc2VudCgpLCAhcmlnaHRfMV8xLmRvbmUpKSByZXR1cm4gWzMgLypicmVhayovLCA1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPSByaWdodF8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNFcXVhbChsZWZ0LCBiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBUUlVFX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gNDtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gWzMgLypicmVhayovLCAxMl07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVfMV8xID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZV8xID0geyBlcnJvcjogZV8xXzEgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDEyXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFs3LCAsIDEwLCAxMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEocmlnaHRfMV8xICYmICFyaWdodF8xXzEuZG9uZSAmJiAoX2EgPSByaWdodF8xW1wicmV0dXJuXCJdKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDldO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX2EuY2FsbChyaWdodF8xKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gOTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OiByZXR1cm4gWzMgLypicmVhayovLCAxMV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDExOiByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOiByZXR1cm4gWzIgLypyZXR1cm4qLywgRkFMU0VfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOiByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgbWF0Y2g6IGZ1bmN0aW9uIG1hdGNoKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0b2tlbnMsIHBhdHRlcm5zLCBkaWRTdWNjZWVkLCBtYXRjaGVkO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJucyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZ2F0aGVyVGV4dChsZWZ0LCBmdW5jdGlvbiAocGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMgPSB0b2tlbnMuY29uY2F0KG1hdGNoVG9rZW5pemUocGFydCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZ2F0aGVyVGV4dChyaWdodCwgZnVuY3Rpb24gKHBhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVybnMgPSBwYXR0ZXJucy5jb25jYXQobWF0Y2hBbmFseXplUGF0dGVybihwYXJ0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWRTdWNjZWVkID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkaWRTdWNjZWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIEZBTFNFX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSBtYXRjaFRleHQodG9rZW5zLCBwYXR0ZXJucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbWF0Y2hlZCA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgJysnOiBmdW5jdGlvbiBwbHVzKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChsZWZ0LnR5cGUgPT09ICdkYXRldGltZScgJiYgcmlnaHQudHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tRGF0ZVRpbWUobGVmdC5kYXRhLmFkZChyaWdodC5kYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlZnQudHlwZSA9PT0gJ251bWJlcicgJiYgcmlnaHQudHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tTnVtYmVyKGxlZnQuZGF0YSArIHJpZ2h0LmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWZ0LnR5cGUgPT09ICdzdHJpbmcnICYmIHJpZ2h0LnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJvbVN0cmluZyhsZWZ0LmRhdGEgKyByaWdodC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVmdC50eXBlID09PSAnb2JqZWN0JyAmJiByaWdodC50eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGZyb21KUyhfX2Fzc2lnbihfX2Fzc2lnbih7fSwgbGVmdC5kYXRhKSwgcmlnaHQuZGF0YSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWZ0LnR5cGUgPT09ICdhcnJheScgJiYgcmlnaHQudHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgcmV0dXJuIGZyb21KUyhsZWZ0LmRhdGEuY29uY2F0KHJpZ2h0LmRhdGEpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVmdC5pc0FycmF5KCkgJiYgcmlnaHQuaXNBcnJheSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmVhbVZhbHVlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlZnRfMSwgbGVmdF8xXzEsIHZhbCwgZV8yXzEsIHJpZ2h0XzIsIHJpZ2h0XzJfMSwgdmFsLCBlXzNfMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVfMiwgX2EsIGVfMywgX2I7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLnRyeXMucHVzaChbMCwgNywgOCwgMTNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdF8xID0gX19hc3luY1ZhbHVlcyhsZWZ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFs0IC8qeWllbGQqLywgX19hd2FpdChsZWZ0XzEubmV4dCgpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShsZWZ0XzFfMSA9IF9jLnNlbnQoKSwgIWxlZnRfMV8xLmRvbmUpKSByZXR1cm4gWzMgLypicmVhayovLCA2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gbGVmdF8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQodmFsKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzQgLyp5aWVsZCovLCBfYy5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVfMl8xID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlXzIgPSB7IGVycm9yOiBlXzJfMSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxM107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy50cnlzLnB1c2goWzgsICwgMTEsIDEyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGxlZnRfMV8xICYmICFsZWZ0XzFfMS5kb25lICYmIChfYSA9IGxlZnRfMVtcInJldHVyblwiXSkpKSByZXR1cm4gWzMgLypicmVhayovLCAxMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQoX2EuY2FsbChsZWZ0XzEpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMTA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDogcmV0dXJuIFszIC8qYnJlYWsqLywgMTJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOiByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLnRyeXMucHVzaChbMTMsIDIwLCAyMSwgMjZdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHRfMiA9IF9fYXN5bmNWYWx1ZXMocmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDE0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTQ6IHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQocmlnaHRfMi5uZXh0KCkpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShyaWdodF8yXzEgPSBfYy5zZW50KCksICFyaWdodF8yXzEuZG9uZSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDE5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gcmlnaHRfMl8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KHZhbCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTY6IHJldHVybiBbNCAvKnlpZWxkKi8sIF9jLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDE4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTg6IHJldHVybiBbMyAvKmJyZWFrKi8sIDE0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE5OiByZXR1cm4gWzMgLypicmVhayovLCAyNl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZV8zXzEgPSBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVfMyA9IHsgZXJyb3I6IGVfM18xIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDI2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy50cnlzLnB1c2goWzIxLCAsIDI0LCAyNV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShyaWdodF8yXzEgJiYgIXJpZ2h0XzJfMS5kb25lICYmIChfYiA9IHJpZ2h0XzJbXCJyZXR1cm5cIl0pKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMjNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KF9iLmNhbGwocmlnaHRfMikpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMjM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyMzogcmV0dXJuIFszIC8qYnJlYWsqLywgMjVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI1OiByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjY6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9LFxuICAgICctJzogZnVuY3Rpb24gbWludXMobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKGxlZnQudHlwZSA9PT0gJ2RhdGV0aW1lJyAmJiByaWdodC50eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIGZyb21EYXRlVGltZShsZWZ0LmRhdGEuYWRkKC1yaWdodC5kYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlZnQudHlwZSA9PT0gJ2RhdGV0aW1lJyAmJiByaWdodC50eXBlID09PSAnZGF0ZXRpbWUnKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJvbU51bWJlcihsZWZ0LmRhdGEuZGlmZmVyZW5jZShyaWdodC5kYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlZnQudHlwZSA9PT0gJ251bWJlcicgJiYgcmlnaHQudHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tTnVtYmVyKGxlZnQuZGF0YSAtIHJpZ2h0LmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH0sXG4gICAgJyonOiBudW1lcmljT3BlcmF0b3IoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgKiBiOyB9KSxcbiAgICAnLyc6IG51bWVyaWNPcGVyYXRvcihmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSAvIGI7IH0pLFxuICAgICclJzogbnVtZXJpY09wZXJhdG9yKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhICUgYjsgfSksXG4gICAgJyoqJzogbnVtZXJpY09wZXJhdG9yKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBNYXRoLnBvdyhhLCBiKTsgfSlcbn07XG5mdW5jdGlvbiBudW1lcmljT3BlcmF0b3IoaW1wbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKGxlZnQudHlwZSA9PT0gJ251bWJlcicgJiYgcmlnaHQudHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBpbXBsKGxlZnQuZGF0YSwgcmlnaHQuZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gZnJvbU51bWJlcihyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH07XG59dmFyIFNjb3BlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG4gICAgZnVuY3Rpb24gU2NvcGUocGFyYW1zLCBzb3VyY2UsIHZhbHVlLCBjb250ZXh0LCBwYXJlbnQpIHtcbiAgICAgICAgdGhpcy5pc0hpZGRlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICAgIFNjb3BlLnByb3RvdHlwZS5jcmVhdGVOZXN0ZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNIaWRkZW4pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2NvcGUodGhpcy5wYXJhbXMsIHRoaXMuc291cmNlLCB2YWx1ZSwgdGhpcy5jb250ZXh0LCB0aGlzLnBhcmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTY29wZSh0aGlzLnBhcmFtcywgdGhpcy5zb3VyY2UsIHZhbHVlLCB0aGlzLmNvbnRleHQsIHRoaXMpO1xuICAgIH07XG4gICAgU2NvcGUucHJvdG90eXBlLmNyZWF0ZUhpZGRlbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jcmVhdGVOZXN0ZWQodmFsdWUpO1xuICAgICAgICByZXN1bHQuaXNIaWRkZW4gPSB0cnVlO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIFNjb3BlO1xufSgpKTtmdW5jdGlvbiBldmFsdWF0ZShub2RlLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGlmIChleGVjdXRlID09PSB2b2lkIDApIHsgZXhlY3V0ZSA9IGV2YWx1YXRlOyB9XG4gICAgdmFyIGZ1bmMgPSBFWEVDVVRPUlNbbm9kZS50eXBlXTtcbiAgICByZXR1cm4gZnVuYyhub2RlLCBzY29wZSwgZXhlY3V0ZSk7XG59XG4vKipcbiAqIEFwcGxpZXMgdGhlIGZ1bmN0aW9uIHRvIGEgdmFsdWUsIGJ1dCB0cmllcyB0byBhdm9pZCBjcmVhdGluZyB1bm5lY2Vzc2FyeSBwcm9taXNlcy5cbiAqL1xuZnVuY3Rpb24gcHJvbWlzZWxlc3NBcHBseSh2YWx1ZSwgY2IpIHtcbiAgICBpZiAoJ3RoZW4nIGluIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50aGVuKGNiKTtcbiAgICB9XG4gICAgcmV0dXJuIGNiKHZhbHVlKTtcbn1cbnZhciBFWEVDVVRPUlMgPSB7XG4gICAgVGhpczogZnVuY3Rpb24gKF8sIHNjb3BlKSB7XG4gICAgICAgIHJldHVybiBzY29wZS52YWx1ZTtcbiAgICB9LFxuICAgIFNlbGVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFRoZXNlIHNob3VsZCBiZSBldmFsdWF0ZWQgc2VwYXJlbHkgdXNpbmcgYSBkaWZmZXJlbnQgZXZhbHVhdG9yLlxuICAgICAgICAvLyBBdCB0aGUgbW9vbWVudCB3ZSBoYXZlbid0IGltcGxlbWVudGVkIHRoaXMuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2VsZWN0b3JzIGNhbiBub3QgYmUgZXZhbHVhdGVkJyk7XG4gICAgfSxcbiAgICBFdmVyeXRoaW5nOiBmdW5jdGlvbiAoXywgc2NvcGUpIHtcbiAgICAgICAgcmV0dXJuIHNjb3BlLnNvdXJjZTtcbiAgICB9LFxuICAgIFBhcmFtZXRlcjogZnVuY3Rpb24gKF9hLCBzY29wZSkge1xuICAgICAgICB2YXIgbmFtZSA9IF9hLm5hbWU7XG4gICAgICAgIHJldHVybiBmcm9tSlMoc2NvcGUucGFyYW1zW25hbWVdKTtcbiAgICB9LFxuICAgIENvbnRleHQ6IGZ1bmN0aW9uIChfYSwgc2NvcGUpIHtcbiAgICAgICAgdmFyIGtleSA9IF9hLmtleTtcbiAgICAgICAgaWYgKGtleSA9PT0gJ2JlZm9yZScgfHwga2V5ID09PSAnYWZ0ZXInKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBzY29wZS5jb250ZXh0W2tleV07XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgfHwgTlVMTF9WQUxVRTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIGNvbnRleHQga2V5OiBcIi5jb25jYXQoa2V5KSk7XG4gICAgfSxcbiAgICBQYXJlbnQ6IGZ1bmN0aW9uIChfYSwgc2NvcGUpIHtcbiAgICAgICAgdmFyIG4gPSBfYS5uO1xuICAgICAgICB2YXIgY3VycmVudCA9IHNjb3BlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50LnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJyZW50LnZhbHVlO1xuICAgIH0sXG4gICAgT3BDYWxsOiBmdW5jdGlvbiAoX2EsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBvcCA9IF9hLm9wLCBsZWZ0ID0gX2EubGVmdCwgcmlnaHQgPSBfYS5yaWdodDtcbiAgICAgICAgdmFyIGZ1bmMgPSBvcGVyYXRvcnNbb3BdO1xuICAgICAgICBpZiAoIWZ1bmMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb3BlcmF0b3I6IFwiLmNvbmNhdChvcCkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZWZ0VmFsdWUgPSBleGVjdXRlKGxlZnQsIHNjb3BlKTtcbiAgICAgICAgdmFyIHJpZ2h0VmFsdWUgPSBleGVjdXRlKHJpZ2h0LCBzY29wZSk7XG4gICAgICAgIC8vIEF2b2lkIHVuZWNjZXNhcnkgcHJvbWlzZXNcbiAgICAgICAgLy8gVGhpcyBpcyByZXF1aXJlZCBmb3IgY29uc3RhbnQgZXZhbHVhdGlvbiB0byB3b3JrIGNvcnJlY3RseS5cbiAgICAgICAgaWYgKCd0aGVuJyBpbiBsZWZ0VmFsdWUgfHwgJ3RoZW4nIGluIHJpZ2h0VmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoZnVuY3Rpb24gKCkgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkgeyB2YXIgX2EsIF9iOyByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IGZ1bmM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBsZWZ0VmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYiA9IFtfYy5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcmlnaHRWYWx1ZV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLmFwcGx5KHZvaWQgMCwgX2IuY29uY2F0KFtfYy5zZW50KCldKSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pOyB9KTsgfSkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYyhsZWZ0VmFsdWUsIHJpZ2h0VmFsdWUpO1xuICAgIH0sXG4gICAgU2VsZWN0OiBmdW5jdGlvbiAoX2EsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgICAgIHZhciBhbHRlcm5hdGl2ZXMgPSBfYS5hbHRlcm5hdGl2ZXMsIGZhbGxiYWNrID0gX2EuZmFsbGJhY2s7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfaSwgYWx0ZXJuYXRpdmVzXzEsIGFsdCwgYWx0Q29uZDtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pID0gMCwgYWx0ZXJuYXRpdmVzXzEgPSBhbHRlcm5hdGl2ZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKF9pIDwgYWx0ZXJuYXRpdmVzXzEubGVuZ3RoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICBhbHQgPSBhbHRlcm5hdGl2ZXNfMVtfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGFsdC5jb25kaXRpb24sIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsdENvbmQgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWx0Q29uZC50eXBlID09PSAnYm9vbGVhbicgJiYgYWx0Q29uZC5kYXRhID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGV4ZWN1dGUoYWx0LnZhbHVlLCBzY29wZSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBfaSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBleGVjdXRlKGZhbGxiYWNrLCBzY29wZSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIEluUmFuZ2U6IGZ1bmN0aW9uIChfYSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICAgICAgdmFyIGJhc2UgPSBfYS5iYXNlLCBsZWZ0ID0gX2EubGVmdCwgcmlnaHQgPSBfYS5yaWdodCwgaXNJbmNsdXNpdmUgPSBfYS5pc0luY2x1c2l2ZTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlLCBsZWZ0VmFsdWUsIHJpZ2h0VmFsdWUsIGxlZnRDbXAsIF9iLCBfYywgcmlnaHRDbXAsIF9kLCBfZTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2YpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9mLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShiYXNlLCBzY29wZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF9mLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUobGVmdCwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdFZhbHVlID0gX2Yuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShyaWdodCwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHRWYWx1ZSA9IF9mLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iID0gcGFydGlhbENvbXBhcmU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB2YWx1ZS5nZXQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jID0gW19mLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBsZWZ0VmFsdWUuZ2V0KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0Q21wID0gX2IuYXBwbHkodm9pZCAwLCBfYy5jb25jYXQoW19mLnNlbnQoKV0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0Q21wID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX2QgPSBwYXJ0aWFsQ29tcGFyZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHZhbHVlLmdldCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgX2UgPSBbX2Yuc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJpZ2h0VmFsdWUuZ2V0KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodENtcCA9IF9kLmFwcGx5KHZvaWQgMCwgX2UuY29uY2F0KFtfZi5zZW50KCldKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmlnaHRDbXAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNJbmNsdXNpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbGVmdENtcCA+PSAwICYmIHJpZ2h0Q21wIDw9IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGxlZnRDbXAgPj0gMCAmJiByaWdodENtcCA8IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIEZpbHRlcjogZnVuY3Rpb24gKF9hLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgICAgICB2YXIgYmFzZSA9IF9hLmJhc2UsIGV4cHIgPSBfYS5leHByO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYmFzZVZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGJhc2UsIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VWYWx1ZSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYmFzZVZhbHVlLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgU3RyZWFtVmFsdWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiYXNlVmFsdWVfMSwgYmFzZVZhbHVlXzFfMSwgZWxlbSwgbmV3U2NvcGUsIGV4cHJWYWx1ZSwgZV8xXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbMCwgOCwgOSwgMTRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VWYWx1ZV8xID0gX19hc3luY1ZhbHVlcyhiYXNlVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQoYmFzZVZhbHVlXzEubmV4dCgpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGJhc2VWYWx1ZV8xXzEgPSBfYi5zZW50KCksICFiYXNlVmFsdWVfMV8xLmRvbmUpKSByZXR1cm4gWzMgLypicmVhayovLCA3XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0gPSBiYXNlVmFsdWVfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVOZXN0ZWQoZWxlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KGV4ZWN1dGUoZXhwciwgbmV3U2NvcGUpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJWYWx1ZSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGV4cHJWYWx1ZS50eXBlID09PSAnYm9vbGVhbicgJiYgZXhwclZhbHVlLmRhdGEgPT09IHRydWUpKSByZXR1cm4gWzMgLypicmVhayovLCA2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQoZWxlbSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbNCAvKnlpZWxkKi8sIF9iLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gNjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OiByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OiByZXR1cm4gWzMgLypicmVhayovLCAxNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVfMV8xID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZV8xID0geyBlcnJvcjogZV8xXzEgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDE0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFs5LCAsIDEyLCAxM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoYmFzZVZhbHVlXzFfMSAmJiAhYmFzZVZhbHVlXzFfMS5kb25lICYmIChfYSA9IGJhc2VWYWx1ZV8xW1wicmV0dXJuXCJdKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDExXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQoX2EuY2FsbChiYXNlVmFsdWVfMSkpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6IHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTQ6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIFByb2plY3Rpb246IGZ1bmN0aW9uIChfYSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICAgICAgdmFyIGJhc2UgPSBfYS5iYXNlLCBleHByID0gX2EuZXhwcjtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGJhc2VWYWx1ZSwgbmV3U2NvcGU7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYmFzZSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVZhbHVlID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJhc2VWYWx1ZS50eXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlTmVzdGVkKGJhc2VWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZXhlY3V0ZShleHByLCBuZXdTY29wZSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIEZ1bmNDYWxsOiBmdW5jdGlvbiAoX2EsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgICAgIHZhciBmdW5jID0gX2EuZnVuYywgYXJncyA9IF9hLmFyZ3M7XG4gICAgICAgIHJldHVybiBmdW5jKGFyZ3MsIHNjb3BlLCBleGVjdXRlKTtcbiAgICB9LFxuICAgIFBpcGVGdW5jQ2FsbDogZnVuY3Rpb24gKF9hLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgICAgICB2YXIgZnVuYyA9IF9hLmZ1bmMsIGJhc2UgPSBfYS5iYXNlLCBhcmdzID0gX2EuYXJncztcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGJhc2VWYWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShiYXNlLCBzY29wZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlVmFsdWUgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZnVuYyhiYXNlVmFsdWUsIGFyZ3MsIHNjb3BlLCBleGVjdXRlKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgQWNjZXNzQXR0cmlidXRlOiBmdW5jdGlvbiAoX2EsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgICAgIHZhciBiYXNlID0gX2EuYmFzZSwgbmFtZSA9IF9hLm5hbWU7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gc2NvcGUudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJhc2UpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShiYXNlLCBzY29wZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmRhdGEuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21KUyh2YWx1ZS5kYXRhW25hbWVdKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIEFjY2Vzc0VsZW1lbnQ6IGZ1bmN0aW9uIChfYSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICAgICAgdmFyIGJhc2UgPSBfYS5iYXNlLCBpbmRleCA9IF9hLmluZGV4O1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYmFzZVZhbHVlLCBkYXRhLCBmaW5hbEluZGV4O1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGJhc2UsIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VWYWx1ZSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYmFzZVZhbHVlLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGJhc2VWYWx1ZS5nZXQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbEluZGV4ID0gaW5kZXggPCAwID8gaW5kZXggKyBkYXRhLmxlbmd0aCA6IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21KUyhkYXRhW2ZpbmFsSW5kZXhdKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgU2xpY2U6IGZ1bmN0aW9uIChfYSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICAgICAgdmFyIGJhc2UgPSBfYS5iYXNlLCBsZWZ0ID0gX2EubGVmdCwgcmlnaHQgPSBfYS5yaWdodCwgaXNJbmNsdXNpdmUgPSBfYS5pc0luY2x1c2l2ZTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGJhc2VWYWx1ZSwgYXJyYXksIGxlZnRJZHgsIHJpZ2h0SWR4O1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGJhc2UsIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VWYWx1ZSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYmFzZVZhbHVlLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGJhc2VWYWx1ZS5nZXQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5ID0gKF9iLnNlbnQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0SWR4ID0gbGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0SWR4ID0gcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgbmVnYXRpdmUgaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0SWR4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRJZHggPSBhcnJheS5sZW5ndGggKyBsZWZ0SWR4O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJpZ2h0SWR4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0SWR4ID0gYXJyYXkubGVuZ3RoICsgcmlnaHRJZHg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IGZyb20gaW5jbHVzaXZlIHRvIGV4Y2x1c2l2ZSBpbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzSW5jbHVzaXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHRJZHgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0SWR4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRJZHggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJpZ2h0SWR4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0SWR4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IEF0IHRoaXMgcG9pbnQgdGhlIGluZGljZXMgbWlnaHQgcG9pbnQgb3V0LW9mLWJvdW5kLCBidXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC5zbGljZSBoYW5kbGVzIHRoaXMgY29ycmVjdGx5LlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZyb21KUyhhcnJheS5zbGljZShsZWZ0SWR4LCByaWdodElkeCkpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBEZXJlZjogZnVuY3Rpb24gKF9hLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgICAgICB2YXIgZV8yLCBfYjtcbiAgICAgICAgdmFyIGJhc2UgPSBfYS5iYXNlO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUsIGlkLCBfYywgX2QsIGRvYywgZV8yXzE7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9lKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfZS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYmFzZSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNjb3BlLnNvdXJjZS5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUudHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZCA9IHZhbHVlLmRhdGEuX3JlZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX2UubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBfZS50cnlzLnB1c2goWzIsIDcsIDgsIDEzXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYyA9IF9fYXN5bmNWYWx1ZXMoc2NvcGUuc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9lLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzQgLyp5aWVsZCovLCBfYy5uZXh0KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShfZCA9IF9lLnNlbnQoKSwgIV9kLmRvbmUpKSByZXR1cm4gWzMgLypicmVhayovLCA2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvYyA9IF9kLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvYy50eXBlID09PSAnb2JqZWN0JyAmJiBpZCA9PT0gZG9jLmRhdGEuX2lkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGRvY107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfZS5sYWJlbCA9IDU7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIFszIC8qYnJlYWsqLywgMTNdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICBlXzJfMSA9IF9lLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxM107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9lLnRyeXMucHVzaChbOCwgLCAxMSwgMTJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKF9kICYmICFfZC5kb25lICYmIChfYiA9IF9jW1wicmV0dXJuXCJdKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDEwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9iLmNhbGwoX2MpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Uuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2UubGFiZWwgPSAxMDtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDogcmV0dXJuIFszIC8qYnJlYWsqLywgMTJdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjogcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIFZhbHVlOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gX2EudmFsdWU7XG4gICAgICAgIHJldHVybiBmcm9tSlModmFsdWUpO1xuICAgIH0sXG4gICAgR3JvdXA6IGZ1bmN0aW9uIChfYSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICAgICAgdmFyIGJhc2UgPSBfYS5iYXNlO1xuICAgICAgICByZXR1cm4gZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgfSxcbiAgICBPYmplY3Q6IGZ1bmN0aW9uIChfYSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBfYS5hdHRyaWJ1dGVzO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBfaSwgYXR0cmlidXRlc18xLCBhdHRyLCBhdHRyVHlwZSwgX2IsIHZhbHVlLCBfYywgX2QsIGNvbmQsIHZhbHVlLCB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2UpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9lLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgX2kgPSAwLCBhdHRyaWJ1dGVzXzEgPSBhdHRyaWJ1dGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2UubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShfaSA8IGF0dHJpYnV0ZXNfMS5sZW5ndGgpKSByZXR1cm4gWzMgLypicmVhayovLCAxMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyID0gYXR0cmlidXRlc18xW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJUeXBlID0gYXR0ci50eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2IgPSBhdHRyLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnT2JqZWN0QXR0cmlidXRlVmFsdWUnOiByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdPYmplY3RDb25kaXRpb25hbFNwbGF0JzogcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnT2JqZWN0U3BsYXQnOiByZXR1cm4gWzMgLypicmVhayovLCA4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDEwXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGF0dHIudmFsdWUsIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX2Uuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2MgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZCA9IGF0dHIubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHZhbHVlLmdldCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgX2NbX2RdID0gX2Uuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTFdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYXR0ci5jb25kaXRpb24sIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmQgPSBfZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZC50eXBlICE9PSAnYm9vbGVhbicgfHwgY29uZC5kYXRhID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDExXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYXR0ci52YWx1ZSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUudHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHJlc3VsdCwgdmFsdWUuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxMV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgODogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShhdHRyLnZhbHVlLCBzY29wZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF9lLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzdWx0LCB2YWx1ZS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDExXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDogdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBub2RlIHR5cGU6IFwiLmNvbmNhdChhdHRyVHlwZSkpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2krKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOiByZXR1cm4gWzIgLypyZXR1cm4qLywgZnJvbUpTKHJlc3VsdCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIEFycmF5OiBmdW5jdGlvbiAoX2EsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IF9hLmVsZW1lbnRzO1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbVZhbHVlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBfaSwgZWxlbWVudHNfMSwgZWxlbWVudCwgdmFsdWUsIHZhbHVlXzEsIHZhbHVlXzFfMSwgdiwgZV8zXzE7XG4gICAgICAgICAgICAgICAgdmFyIGVfMywgX2E7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2kgPSAwLCBlbGVtZW50c18xID0gZWxlbWVudHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKF9pIDwgZWxlbWVudHNfMS5sZW5ndGgpKSByZXR1cm4gWzMgLypicmVhayovLCAyMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnRzXzFbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQoZXhlY3V0ZShlbGVtZW50LnZhbHVlLCBzY29wZSkpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVsZW1lbnQuaXNTcGxhdCkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUuaXNBcnJheSgpKSByZXR1cm4gWzMgLypicmVhayovLCAxNl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbMywgMTAsIDExLCAxNl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlXzEgPSAoZV8zID0gdm9pZCAwLCBfX2FzeW5jVmFsdWVzKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KHZhbHVlXzEubmV4dCgpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodmFsdWVfMV8xID0gX2Iuc2VudCgpLCAhdmFsdWVfMV8xLmRvbmUpKSByZXR1cm4gWzMgLypicmVhayovLCA5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gdmFsdWVfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQodildO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OiByZXR1cm4gWzQgLyp5aWVsZCovLCBfYi5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg6IHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5OiByZXR1cm4gWzMgLypicmVhayovLCAxNl07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVfM18xID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVfMyA9IHsgZXJyb3I6IGVfM18xIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzExLCAsIDE0LCAxNV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHZhbHVlXzFfMSAmJiAhdmFsdWVfMV8xLmRvbmUgJiYgKF9hID0gdmFsdWVfMVtcInJldHVyblwiXSkpKSByZXR1cm4gWzMgLypicmVhayovLCAxM107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX19hd2FpdChfYS5jYWxsKHZhbHVlXzEpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDEzO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMzogcmV0dXJuIFszIC8qYnJlYWsqLywgMTVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3IC8qZW5kZmluYWxseSovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTU6IHJldHVybiBbNyAvKmVuZGZpbmFsbHkqL107XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE2OiByZXR1cm4gWzMgLypicmVhayovLCAyMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE3OiByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KHZhbHVlKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE4OiByZXR1cm4gWzQgLyp5aWVsZCovLCBfYi5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAyMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2krKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjE6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgVHVwbGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0dXBsZXMgY2FuIG5vdCBiZSBldmFsdWF0ZWQnKTtcbiAgICB9LFxuICAgIE9yOiBmdW5jdGlvbiAoX2EsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gX2EubGVmdCwgcmlnaHQgPSBfYS5yaWdodDtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxlZnRWYWx1ZSwgcmlnaHRWYWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShsZWZ0LCBzY29wZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0VmFsdWUgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKHJpZ2h0LCBzY29wZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodFZhbHVlID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnRWYWx1ZS50eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVmdFZhbHVlLmRhdGEgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIFRSVUVfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyaWdodFZhbHVlLnR5cGUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyaWdodFZhbHVlLmRhdGEgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIFRSVUVfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0VmFsdWUudHlwZSAhPT0gJ2Jvb2xlYW4nIHx8IHJpZ2h0VmFsdWUudHlwZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIEZBTFNFX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBBbmQ6IGZ1bmN0aW9uIChfYSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICAgICAgdmFyIGxlZnQgPSBfYS5sZWZ0LCByaWdodCA9IF9hLnJpZ2h0O1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbGVmdFZhbHVlLCByaWdodFZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGxlZnQsIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRWYWx1ZSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUocmlnaHQsIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0VmFsdWUgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVmdFZhbHVlLnR5cGUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0VmFsdWUuZGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIEZBTFNFX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmlnaHRWYWx1ZS50eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmlnaHRWYWx1ZS5kYXRhID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgRkFMU0VfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0VmFsdWUudHlwZSAhPT0gJ2Jvb2xlYW4nIHx8IHJpZ2h0VmFsdWUudHlwZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIFRSVUVfVkFMVUVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIE5vdDogZnVuY3Rpb24gKF9hLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgICAgICB2YXIgYmFzZSA9IF9hLmJhc2U7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShiYXNlLCBzY29wZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdmFsdWUuZGF0YSA/IEZBTFNFX1ZBTFVFIDogVFJVRV9WQUxVRV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgTmVnOiBmdW5jdGlvbiAoX2EsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgICAgIHZhciBiYXNlID0gX2EuYmFzZTtcbiAgICAgICAgcmV0dXJuIHByb21pc2VsZXNzQXBwbHkoZXhlY3V0ZShiYXNlLCBzY29wZSksIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnJvbU51bWJlcigtdmFsdWUuZGF0YSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgUG9zOiBmdW5jdGlvbiAoX2EsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgICAgIHZhciBiYXNlID0gX2EuYmFzZTtcbiAgICAgICAgcmV0dXJuIHByb21pc2VsZXNzQXBwbHkoZXhlY3V0ZShiYXNlLCBzY29wZSksIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnJvbU51bWJlcih2YWx1ZS5kYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBBc2M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfSxcbiAgICBEZXNjOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH0sXG4gICAgQXJyYXlDb2VyY2U6IGZ1bmN0aW9uIChfYSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICAgICAgdmFyIGJhc2UgPSBfYS5iYXNlO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIGV4ZWN1dGUoYmFzZSwgc2NvcGUpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdmFsdWUuaXNBcnJheSgpID8gdmFsdWUgOiBOVUxMX1ZBTFVFXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBNYXA6IGZ1bmN0aW9uIChfYSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICAgICAgdmFyIGJhc2UgPSBfYS5iYXNlLCBleHByID0gX2EuZXhwcjtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBleGVjdXRlKGJhc2UsIHNjb3BlKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZS5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgTlVMTF9WQUxVRV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IFN0cmVhbVZhbHVlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVfMiwgdmFsdWVfMl8xLCBlbGVtLCBuZXdTY29wZSwgZV80XzE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZV80LCBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbMCwgOCwgOSwgMTRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlXzIgPSBfX2FzeW5jVmFsdWVzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KHZhbHVlXzIubmV4dCgpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHZhbHVlXzJfMSA9IF9iLnNlbnQoKSwgIXZhbHVlXzJfMS5kb25lKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgN107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtID0gdmFsdWVfMl8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVIaWRkZW4oZWxlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KGV4ZWN1dGUoZXhwciwgbmV3U2NvcGUpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFs0IC8qeWllbGQqLywgX19hd2FpdC5hcHBseSh2b2lkIDAsIFtfYi5zZW50KCldKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFs0IC8qeWllbGQqLywgX2Iuc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc6IHJldHVybiBbMyAvKmJyZWFrKi8sIDE0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZV80XzEgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlXzQgPSB7IGVycm9yOiBlXzRfMSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMTRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzksICwgMTIsIDEzXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh2YWx1ZV8yXzEgJiYgIXZhbHVlXzJfMS5kb25lICYmIChfYSA9IHZhbHVlXzJbXCJyZXR1cm5cIl0pKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX19hd2FpdChfYS5jYWxsKHZhbHVlXzIpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExOiByZXR1cm4gWzMgLypicmVhayovLCAxM107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZV80KSB0aHJvdyBlXzQuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOiByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE0OiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBGbGF0TWFwOiBmdW5jdGlvbiAoX2EsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgICAgIHZhciBiYXNlID0gX2EuYmFzZSwgZXhwciA9IF9hLmV4cHI7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgZXhlY3V0ZShiYXNlLCBzY29wZSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUuaXNBcnJheSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIE5VTExfVkFMVUVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBTdHJlYW1WYWx1ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlXzMsIHZhbHVlXzNfMSwgZWxlbSwgbmV3U2NvcGUsIGlubmVyVmFsdWUsIGlubmVyVmFsdWVfMSwgaW5uZXJWYWx1ZV8xXzEsIGlubmVyLCBlXzVfMSwgZV82XzE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZV82LCBfYSwgZV81LCBfYjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLnRyeXMucHVzaChbMCwgMjMsIDI0LCAyOV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVfMyA9IF9fYXN5bmNWYWx1ZXModmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQodmFsdWVfMy5uZXh0KCkpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodmFsdWVfM18xID0gX2Muc2VudCgpLCAhdmFsdWVfM18xLmRvbmUpKSByZXR1cm4gWzMgLypicmVhayovLCAyMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtID0gdmFsdWVfM18xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVIaWRkZW4oZWxlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KGV4ZWN1dGUoZXhwciwgbmV3U2NvcGUpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyVmFsdWUgPSBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlubmVyVmFsdWUuaXNBcnJheSgpKSByZXR1cm4gWzMgLypicmVhayovLCAxOF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLnRyeXMucHVzaChbNCwgMTEsIDEyLCAxN10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJWYWx1ZV8xID0gKGVfNSA9IHZvaWQgMCwgX19hc3luY1ZhbHVlcyhpbm5lclZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFs0IC8qeWllbGQqLywgX19hd2FpdChpbm5lclZhbHVlXzEubmV4dCgpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGlubmVyVmFsdWVfMV8xID0gX2Muc2VudCgpLCAhaW5uZXJWYWx1ZV8xXzEuZG9uZSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDEwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyID0gaW5uZXJWYWx1ZV8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfX2F3YWl0KGlubmVyKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzogcmV0dXJuIFs0IC8qeWllbGQqLywgX2Muc2VudCgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSA5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDk6IHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOiByZXR1cm4gWzMgLypicmVhayovLCAxN107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlXzVfMSA9IF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVfNSA9IHsgZXJyb3I6IGVfNV8xIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxN107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy50cnlzLnB1c2goWzEyLCAsIDE1LCAxNl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoaW5uZXJWYWx1ZV8xXzEgJiYgIWlubmVyVmFsdWVfMV8xLmRvbmUgJiYgKF9iID0gaW5uZXJWYWx1ZV8xW1wicmV0dXJuXCJdKSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDE0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQoX2IuY2FsbChpbm5lclZhbHVlXzEpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDE0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE0OiByZXR1cm4gWzMgLypicmVhayovLCAxNl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZV81KSB0aHJvdyBlXzUuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE2OiByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE3OiByZXR1cm4gWzMgLypicmVhayovLCAyMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTg6IHJldHVybiBbNCAvKnlpZWxkKi8sIF9fYXdhaXQoaW5uZXJWYWx1ZSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE5OiByZXR1cm4gWzQgLyp5aWVsZCovLCBfYy5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAyMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyMTogcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDI5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVfNl8xID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZV82ID0geyBlcnJvcjogZV82XzEgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDI5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLnRyeXMucHVzaChbMjQsICwgMjcsIDI4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh2YWx1ZV8zXzEgJiYgIXZhbHVlXzNfMS5kb25lICYmIChfYSA9IHZhbHVlXzNbXCJyZXR1cm5cIl0pKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMjZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX19hd2FpdChfYS5jYWxsKHZhbHVlXzMpKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDI2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI2OiByZXR1cm4gWzMgLypicmVhayovLCAyOF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZV82KSB0aHJvdyBlXzYuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI4OiByZXR1cm4gWzcgLyplbmRmaW5hbGx5Ki9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI5OiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbi8qKlxuICogRXZhbHVhdGVzIGEgcXVlcnkuXG4gKi9cbmZ1bmN0aW9uIGV2YWx1YXRlUXVlcnkodHJlZSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIHJvb3QgPSBmcm9tSlMob3B0aW9ucy5yb290KTtcbiAgICB2YXIgZGF0YXNldCA9IGZyb21KUyhvcHRpb25zLmRhdGFzZXQpO1xuICAgIHZhciBwYXJhbXMgPSBfX2Fzc2lnbih7fSwgb3B0aW9ucy5wYXJhbXMpO1xuICAgIHZhciBzY29wZSA9IG5ldyBTY29wZShwYXJhbXMsIGRhdGFzZXQsIHJvb3QsIHtcbiAgICAgICAgdGltZXN0YW1wOiBvcHRpb25zLnRpbWVzdGFtcCB8fCBuZXcgRGF0ZSgpLFxuICAgICAgICBpZGVudGl0eTogb3B0aW9ucy5pZGVudGl0eSA9PT0gdW5kZWZpbmVkID8gJ21lJyA6IG9wdGlvbnMuaWRlbnRpdHksXG4gICAgICAgIHNhbml0eTogb3B0aW9ucy5zYW5pdHksXG4gICAgICAgIGFmdGVyOiBvcHRpb25zLmFmdGVyID8gZnJvbUpTKG9wdGlvbnMuYWZ0ZXIpIDogbnVsbCxcbiAgICAgICAgYmVmb3JlOiBvcHRpb25zLmJlZm9yZSA/IGZyb21KUyhvcHRpb25zLmJlZm9yZSkgOiBudWxsXG4gICAgfSwgbnVsbCk7XG4gICAgcmV0dXJuIGV2YWx1YXRlKHRyZWUsIHNjb3BlKTtcbn1mdW5jdGlvbiBjYW5Db25zdGFudEV2YWx1YXRlKG5vZGUpIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICBjYXNlICdHcm91cCc6XG4gICAgICAgIGNhc2UgJ1ZhbHVlJzpcbiAgICAgICAgY2FzZSAnUGFyYW1ldGVyJzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjYXNlICdQb3MnOlxuICAgICAgICBjYXNlICdOZWcnOlxuICAgICAgICAgICAgcmV0dXJuIGNhbkNvbnN0YW50RXZhbHVhdGUobm9kZS5iYXNlKTtcbiAgICAgICAgY2FzZSAnT3BDYWxsJzpcbiAgICAgICAgICAgIHN3aXRjaCAobm9kZS5vcCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgICAgIGNhc2UgJy8nOlxuICAgICAgICAgICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJyoqJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbkNvbnN0YW50RXZhbHVhdGUobm9kZS5sZWZ0KSAmJiBjYW5Db25zdGFudEV2YWx1YXRlKG5vZGUucmlnaHQpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG52YXIgRFVNTVlfU0NPUEUgPSBuZXcgU2NvcGUoe30sIE5VTExfVkFMVUUsIE5VTExfVkFMVUUsIHsgdGltZXN0YW1wOiBuZXcgRGF0ZSgwKSwgaWRlbnRpdHk6ICdtZScsIGJlZm9yZTogbnVsbCwgYWZ0ZXI6IG51bGwgfSwgbnVsbCk7XG5mdW5jdGlvbiB0cnlDb25zdGFudEV2YWx1YXRlKG5vZGUpIHtcbiAgICBpZiAoIWNhbkNvbnN0YW50RXZhbHVhdGUobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjb25zdGFudEV2YWx1YXRlKG5vZGUpO1xufVxuZnVuY3Rpb24gY29uc3RhbnRFdmFsdWF0ZShub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gZXZhbHVhdGUobm9kZSwgRFVNTVlfU0NPUEUsIGNvbnN0YW50RXZhbHVhdGUpO1xuICAgIGlmICgndGhlbicgaW4gdmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCVUc6IGNvbnN0YW50IGV2YWx1YXRlIHNob3VsZCBuZXZlciByZXR1cm4gYSBwcm9taXNlJyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn12YXIgRVNDQVBFX1NFUVVFTkNFID0ge1xuICAgIFwiJ1wiOiBcIidcIixcbiAgICAnXCInOiAnXCInLFxuICAgICdcXFxcJzogJ1xcXFwnLFxuICAgICcvJzogJy8nLFxuICAgIGI6ICdcXGInLFxuICAgIGY6ICdcXGYnLFxuICAgIG46ICdcXG4nLFxuICAgIHI6ICdcXHInLFxuICAgIHQ6ICdcXHQnXG59O1xuZnVuY3Rpb24gZXhwYW5kSGV4KHN0cikge1xuICAgIHZhciBjaGFyQ29kZSA9IHBhcnNlSW50KHN0ciwgMTYpO1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbn1cbnZhciBHcm9xUXVlcnlFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoR3JvcVF1ZXJ5RXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gR3JvcVF1ZXJ5RXJyb3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gJ0dyb3FRdWVyeUVycm9yJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gR3JvcVF1ZXJ5RXJyb3I7XG59KEVycm9yKSk7XG52YXIgRVhQUl9CVUlMREVSID0ge1xuICAgIGdyb3VwOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgaW5uZXIgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdHcm91cCcsXG4gICAgICAgICAgICBiYXNlOiBpbm5lclxuICAgICAgICB9O1xuICAgIH0sXG4gICAgZXZlcnl0aGluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiAnRXZlcnl0aGluZycgfTtcbiAgICB9LFxuICAgIFwidGhpc1wiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdUaGlzJyB9O1xuICAgIH0sXG4gICAgcGFyZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnUGFyZW50JyxcbiAgICAgICAgICAgIG46IDFcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGRibHBhcmVudDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIG5leHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdQYXJlbnQnLFxuICAgICAgICAgICAgbjogbmV4dC5uICsgMVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdHJhdmVyc2U6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBiYXNlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHZhciB0cmF2ZXJzYWxMaXN0ID0gW107XG4gICAgICAgIHdoaWxlIChwLmdldE1hcmsoKS5uYW1lICE9PSAndHJhdmVyc2FsX2VuZCcpIHtcbiAgICAgICAgICAgIHRyYXZlcnNhbExpc3QucHVzaChwLnByb2Nlc3MoVFJBVkVSU0VfQlVJTERFUikpO1xuICAgICAgICB9XG4gICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgdmFyIHRyYXZlcnNhbCA9IG51bGw7XG4gICAgICAgIGZvciAodmFyIGkgPSB0cmF2ZXJzYWxMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB0cmF2ZXJzYWwgPSB0cmF2ZXJzYWxMaXN0W2ldKHRyYXZlcnNhbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhc2UudHlwZSA9PT0gJ0V2ZXJ5dGhpbmcnIHx8IGJhc2UudHlwZSA9PT0gJ0FycmF5JyB8fCBiYXNlLnR5cGUgPT09ICdQaXBlRnVuY0NhbGwnKSB7XG4gICAgICAgICAgICB0cmF2ZXJzYWwgPSB0cmF2ZXJzZUFycmF5KGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHZhbDsgfSwgdHJhdmVyc2FsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhdmVyc2FsID09PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCVUc6IHVuZXhwZWN0ZWQgZW1wdHkgdHJhdmVyc2FsJyk7XG4gICAgICAgIHJldHVybiB0cmF2ZXJzYWwuYnVpbGQoYmFzZSk7XG4gICAgfSxcbiAgICB0aGlzX2F0dHI6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgICAgIGlmIChuYW1lID09PSAnbnVsbCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICdWYWx1ZScsIHZhbHVlOiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgPT09ICd0cnVlJykge1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogJ1ZhbHVlJywgdmFsdWU6IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZSA9PT0gJ2ZhbHNlJykge1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogJ1ZhbHVlJywgdmFsdWU6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdBY2Nlc3NBdHRyaWJ1dGUnLFxuICAgICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgbmVnOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgYmFzZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ05lZycsXG4gICAgICAgICAgICBiYXNlOiBiYXNlXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBwb3M6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBiYXNlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnUG9zJyxcbiAgICAgICAgICAgIGJhc2U6IGJhc2VcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnT3BDYWxsJyxcbiAgICAgICAgICAgIG9wOiAnKycsXG4gICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0XG4gICAgICAgIH07XG4gICAgfSxcbiAgICBzdWI6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHZhciByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ09wQ2FsbCcsXG4gICAgICAgICAgICBvcDogJy0nLFxuICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgIHJpZ2h0OiByaWdodFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgbXVsOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICB2YXIgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdPcENhbGwnLFxuICAgICAgICAgICAgb3A6ICcqJyxcbiAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICByaWdodDogcmlnaHRcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGRpdjogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnT3BDYWxsJyxcbiAgICAgICAgICAgIG9wOiAnLycsXG4gICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0XG4gICAgICAgIH07XG4gICAgfSxcbiAgICBtb2Q6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHZhciByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ09wQ2FsbCcsXG4gICAgICAgICAgICBvcDogJyUnLFxuICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgIHJpZ2h0OiByaWdodFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgcG93OiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICB2YXIgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdPcENhbGwnLFxuICAgICAgICAgICAgb3A6ICcqKicsXG4gICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0XG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjb21wOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICB2YXIgb3AgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnT3BDYWxsJyxcbiAgICAgICAgICAgIG9wOiBvcCxcbiAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICByaWdodDogcmlnaHRcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGluX3JhbmdlOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgYmFzZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICB2YXIgaXNJbmNsdXNpdmUgPSBwLmdldE1hcmsoKS5uYW1lID09PSAnaW5jX3JhbmdlJztcbiAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICB2YXIgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICB2YXIgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdJblJhbmdlJyxcbiAgICAgICAgICAgIGJhc2U6IGJhc2UsXG4gICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgICAgICAgaXNJbmNsdXNpdmU6IGlzSW5jbHVzaXZlXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBzdHI6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9ICcnO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbGFiZWxzXG4gICAgICAgIGxvb3A6IHdoaWxlIChwLmhhc01hcmsoKSkge1xuICAgICAgICAgICAgdmFyIG1hcmsgPSBwLmdldE1hcmsoKTtcbiAgICAgICAgICAgIHN3aXRjaCAobWFyay5uYW1lKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyX2VuZCc6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHAucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbGFiZWxzXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyX3BhdXNlJzpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gcC5wcm9jZXNzU3RyaW5nRW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cl9zdGFydCc6XG4gICAgICAgICAgICAgICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2luZ2xlX2VzY2FwZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYXIgPSBwLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IEVTQ0FQRV9TRVFVRU5DRVtjaGFyXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ3VuaWNvZGVfaGV4JzpcbiAgICAgICAgICAgICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBleHBhbmRIZXgocC5wcm9jZXNzU3RyaW5nRW5kKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkIG1hcms6IFwiLmNvbmNhdChtYXJrLm5hbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB0eXBlOiAnVmFsdWUnLCB2YWx1ZTogdmFsdWUgfTtcbiAgICB9LFxuICAgIGludGVnZXI6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBzdHJWYWx1ZSA9IHAucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ1ZhbHVlJyxcbiAgICAgICAgICAgIHZhbHVlOiBOdW1iZXIoc3RyVmFsdWUpXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBmbG9hdDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIHN0clZhbHVlID0gcC5wcm9jZXNzU3RyaW5nRW5kKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnVmFsdWUnLFxuICAgICAgICAgICAgdmFsdWU6IE51bWJlcihzdHJWYWx1ZSlcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHNjaTogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIHN0clZhbHVlID0gcC5wcm9jZXNzU3RyaW5nRW5kKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnVmFsdWUnLFxuICAgICAgICAgICAgdmFsdWU6IE51bWJlcihzdHJWYWx1ZSlcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIG9iamVjdDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBbXTtcbiAgICAgICAgd2hpbGUgKHAuZ2V0TWFyaygpLm5hbWUgIT09ICdvYmplY3RfZW5kJykge1xuICAgICAgICAgICAgYXR0cmlidXRlcy5wdXNoKHAucHJvY2VzcyhPQkpFQ1RfQlVJTERFUikpO1xuICAgICAgICB9XG4gICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdPYmplY3QnLFxuICAgICAgICAgICAgYXR0cmlidXRlczogYXR0cmlidXRlc1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgYXJyYXk6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgICAgICB3aGlsZSAocC5nZXRNYXJrKCkubmFtZSAhPT0gJ2FycmF5X2VuZCcpIHtcbiAgICAgICAgICAgIHZhciBpc1NwbGF0ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gJ2FycmF5X3NwbGF0Jykge1xuICAgICAgICAgICAgICAgIGlzU3BsYXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICAgICAgZWxlbWVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0FycmF5RWxlbWVudCcsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIGlzU3BsYXQ6IGlzU3BsYXRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdBcnJheScsXG4gICAgICAgICAgICBlbGVtZW50czogZWxlbWVudHNcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHR1cGxlOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgbWVtYmVycyA9IFtdO1xuICAgICAgICB3aGlsZSAocC5nZXRNYXJrKCkubmFtZSAhPT0gJ3R1cGxlX2VuZCcpIHtcbiAgICAgICAgICAgIG1lbWJlcnMucHVzaChwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSk7XG4gICAgICAgIH1cbiAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ1R1cGxlJyxcbiAgICAgICAgICAgIG1lbWJlcnM6IG1lbWJlcnNcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGZ1bmNfY2FsbDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIG5hbWVzcGFjZSA9ICdnbG9iYWwnO1xuICAgICAgICBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gJ25hbWVzcGFjZScpIHtcbiAgICAgICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgICAgIG5hbWVzcGFjZSA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgICAgIGlmIChuYW1lc3BhY2UgPT09ICdnbG9iYWwnICYmIG5hbWUgPT09ICdzZWxlY3QnKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdTZWxlY3QnLFxuICAgICAgICAgICAgICAgIGFsdGVybmF0aXZlczogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aGlsZSAocC5nZXRNYXJrKCkubmFtZSAhPT0gJ2Z1bmNfYXJnc19lbmQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09ICdwYWlyJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmZhbGxiYWNrKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwidW5leHBlY3RlZCBhcmd1bWVudCB0byBzZWxlY3QoKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29uZGl0aW9uID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYWx0ZXJuYXRpdmVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1NlbGVjdEFsdGVybmF0aXZlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbjogY29uZGl0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5mYWxsYmFjaylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcInVuZXhwZWN0ZWQgYXJndW1lbnQgdG8gc2VsZWN0KClcIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuZmFsbGJhY2sgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIHdoaWxlIChwLmdldE1hcmsoKS5uYW1lICE9PSAnZnVuY19hcmdzX2VuZCcpIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudFNob3VsZEJlU2VsZWN0b3IobmFtZXNwYWNlLCBuYW1lLCBhcmdzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAvLyBTaW5jZSB0aGUgZGlmZi9kZWx0YSBmdW5jdGlvbnMgYXJlbid0IHZhbGlkYXRlZCB5ZXQgd2Ugb25seSB3YW50IHRvIHZhbGlkYXRlIHRoZSBzZWxlY3RvclxuICAgICAgICAgICAgICAgIC8vIGJlaW5nIHVzZWQuIFdlIGV4cGVjdCB0aGUgbnVsbCB2YWx1ZWQgYXJnIHRvIHRocm93IGFuIGVycm9yIGF0IGV2YWx1YXRpb24gdGltZS5cbiAgICAgICAgICAgICAgICBwLnByb2Nlc3MoU0VMRUNUT1JfQlVJTERFUik7XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKHsgdHlwZTogJ1NlbGVjdG9yJyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFyZ3MucHVzaChwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICBpZiAobmFtZXNwYWNlID09PSAnZ2xvYmFsJyAmJiAobmFtZSA9PT0gJ2JlZm9yZScgfHwgbmFtZSA9PT0gJ2FmdGVyJykpIHtcbiAgICAgICAgICAgIGlmIChwLnBhcnNlT3B0aW9ucy5tb2RlID09PSAnZGVsdGEnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0NvbnRleHQnLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IG5hbWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lc3BhY2UgPT09ICdnbG9iYWwnICYmIG5hbWUgPT09ICdib29zdCcgJiYgIXAuYWxsb3dCb29zdClcbiAgICAgICAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcigndW5leHBlY3RlZCBib29zdCcpO1xuICAgICAgICB2YXIgZnVuY3MgPSBuYW1lc3BhY2VzW25hbWVzcGFjZV07XG4gICAgICAgIGlmICghZnVuY3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcIlVuZGVmaW5lZCBuYW1lc3BhY2U6IFwiLmNvbmNhdChuYW1lc3BhY2UpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnVuYyA9IGZ1bmNzW25hbWVdO1xuICAgICAgICBpZiAoIWZ1bmMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcIlVuZGVmaW5lZCBmdW5jdGlvbjogXCIuY29uY2F0KG5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnVuYy5hcml0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUFyaXR5KG5hbWUsIGZ1bmMuYXJpdHksIGFyZ3MubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnVuYy5tb2RlICE9PSB1bmRlZmluZWQgJiYgZnVuYy5tb2RlICE9PSBwLnBhcnNlT3B0aW9ucy5tb2RlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJVbmRlZmluZWQgZnVuY3Rpb246IFwiLmNvbmNhdChuYW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdGdW5jQ2FsbCcsXG4gICAgICAgICAgICBmdW5jOiBmdW5jLFxuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHBpcGVjYWxsOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgYmFzZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICBwLnNoaWZ0KCk7IC8vIFJlbW92ZSB0aGUgZnVuY19jYWxsXG4gICAgICAgIHZhciBuYW1lc3BhY2UgPSAnZ2xvYmFsJztcbiAgICAgICAgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09ICduYW1lc3BhY2UnKSB7XG4gICAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBuYW1lc3BhY2UgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZXNwYWNlICE9PSAnZ2xvYmFsJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwiVW5kZWZpbmVkIG5hbWVzcGFjZTogXCIuY29uY2F0KG5hbWVzcGFjZSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIHZhciBvbGRBbGxvd0Jvb3N0ID0gcC5hbGxvd0Jvb3N0O1xuICAgICAgICBpZiAobmFtZSA9PT0gJ3Njb3JlJykge1xuICAgICAgICAgICAgLy8gT25seSBhbGxvdyBib29zdCBpbnNpZGUgYSBzY29yZSBleHByZXNzaW9uXG4gICAgICAgICAgICBwLmFsbG93Qm9vc3QgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIHZhciBtYXJrTmFtZSA9IHAuZ2V0TWFyaygpLm5hbWU7XG4gICAgICAgICAgICBpZiAobWFya05hbWUgPT09ICdmdW5jX2FyZ3NfZW5kJykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdvcmRlcicpIHtcbiAgICAgICAgICAgICAgICBpZiAobWFya05hbWUgPT09ICdhc2MnKSB7XG4gICAgICAgICAgICAgICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKHsgdHlwZTogJ0FzYycsIGJhc2U6IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWFya05hbWUgPT09ICdkZXNjJykge1xuICAgICAgICAgICAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaCh7IHR5cGU6ICdEZXNjJywgYmFzZTogcC5wcm9jZXNzKEVYUFJfQlVJTERFUikgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFyZ3MucHVzaChwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSk7XG4gICAgICAgIH1cbiAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICBwLmFsbG93Qm9vc3QgPSBvbGRBbGxvd0Jvb3N0O1xuICAgICAgICB2YXIgZnVuYyA9IHBpcGVGdW5jdGlvbnNbbmFtZV07XG4gICAgICAgIGlmICghZnVuYykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwiVW5kZWZpbmVkIHBpcGUgZnVuY3Rpb246IFwiLmNvbmNhdChuYW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZ1bmMuYXJpdHkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlQXJpdHkobmFtZSwgZnVuYy5hcml0eSwgYXJncy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnUGlwZUZ1bmNDYWxsJyxcbiAgICAgICAgICAgIGZ1bmM6IGZ1bmMsXG4gICAgICAgICAgICBiYXNlOiBiYXNlLFxuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHBhaXI6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcInVuZXhwZWN0ZWQgPT5cIik7XG4gICAgfSxcbiAgICBhbmQ6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHZhciByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ0FuZCcsXG4gICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0XG4gICAgICAgIH07XG4gICAgfSxcbiAgICBvcjogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnT3InLFxuICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgIHJpZ2h0OiByaWdodFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgbm90OiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgYmFzZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ05vdCcsXG4gICAgICAgICAgICBiYXNlOiBiYXNlXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhc2M6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcigndW5leHBlY3RlZCBhc2MnKTtcbiAgICB9LFxuICAgIGRlc2M6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcigndW5leHBlY3RlZCBkZXNjJyk7XG4gICAgfSxcbiAgICBwYXJhbTogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIG5hbWUgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICAgICAgaWYgKHAucGFyc2VPcHRpb25zLnBhcmFtcyAmJiBwLnBhcnNlT3B0aW9ucy5wYXJhbXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ1ZhbHVlJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcC5wYXJzZU9wdGlvbnMucGFyYW1zW25hbWVdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnUGFyYW1ldGVyJyxcbiAgICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgfTtcbiAgICB9XG59O1xudmFyIE9CSkVDVF9CVUlMREVSID0ge1xuICAgIG9iamVjdF9leHByOiBmdW5jdGlvbiAocCkge1xuICAgICAgICBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gJ3BhaXInKSB7XG4gICAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgICB2YXIgY29uZGl0aW9uID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgICAgICB2YXIgdmFsdWVfMSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnT2JqZWN0Q29uZGl0aW9uYWxTcGxhdCcsXG4gICAgICAgICAgICAgICAgY29uZGl0aW9uOiBjb25kaXRpb24sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXzFcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnT2JqZWN0QXR0cmlidXRlVmFsdWUnLFxuICAgICAgICAgICAgbmFtZTogZXh0cmFjdFByb3BlcnR5S2V5KHZhbHVlKSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgb2JqZWN0X3BhaXI6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBuYW1lID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIGlmIChuYW1lLnR5cGUgIT09ICdWYWx1ZScpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25hbWUgbXVzdCBiZSBzdHJpbmcnKTtcbiAgICAgICAgdmFyIHZhbHVlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnT2JqZWN0QXR0cmlidXRlVmFsdWUnLFxuICAgICAgICAgICAgbmFtZTogbmFtZS52YWx1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgb2JqZWN0X3NwbGF0OiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdPYmplY3RTcGxhdCcsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIG9iamVjdF9zcGxhdF90aGlzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnT2JqZWN0U3BsYXQnLFxuICAgICAgICAgICAgdmFsdWU6IHsgdHlwZTogJ1RoaXMnIH1cbiAgICAgICAgfTtcbiAgICB9XG59O1xudmFyIFRSQVZFUlNFX0JVSUxERVIgPSB7XG4gICAgc3F1YXJlX2JyYWNrZXQ6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBleHByID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRyeUNvbnN0YW50RXZhbHVhdGUoZXhwcik7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS50eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyaWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmF2ZXJzZUVsZW1lbnQoZnVuY3Rpb24gKGJhc2UpIHsgcmV0dXJuICh7IHR5cGU6ICdBY2Nlc3NFbGVtZW50JywgYmFzZTogYmFzZSwgaW5kZXg6IHZhbHVlLmRhdGEgfSk7IH0sIHJpZ2h0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYXZlcnNlUGxhaW4oZnVuY3Rpb24gKGJhc2UpIHsgcmV0dXJuICh7IHR5cGU6ICdBY2Nlc3NBdHRyaWJ1dGUnLCBiYXNlOiBiYXNlLCBuYW1lOiB2YWx1ZS5kYXRhIH0pOyB9LCByaWdodCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocmlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmF2ZXJzZUFycmF5KGZ1bmN0aW9uIChiYXNlKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdGaWx0ZXInLFxuICAgICAgICAgICAgICAgIGJhc2U6IGJhc2UsXG4gICAgICAgICAgICAgICAgZXhwcjogZXhwclxuICAgICAgICAgICAgfSk7IH0sIHJpZ2h0KTtcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHNsaWNlOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgaXNJbmNsdXNpdmUgPSBwLmdldE1hcmsoKS5uYW1lID09PSAnaW5jX3JhbmdlJztcbiAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICB2YXIgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICB2YXIgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgdmFyIGxlZnRWYWx1ZSA9IHRyeUNvbnN0YW50RXZhbHVhdGUobGVmdCk7XG4gICAgICAgIHZhciByaWdodFZhbHVlID0gdHJ5Q29uc3RhbnRFdmFsdWF0ZShyaWdodCk7XG4gICAgICAgIGlmICghbGVmdFZhbHVlIHx8ICFyaWdodFZhbHVlIHx8IGxlZnRWYWx1ZS50eXBlICE9PSAnbnVtYmVyJyB8fCByaWdodFZhbHVlLnR5cGUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoJ3NsaWNpbmcgbXVzdCB1c2UgY29uc3RhbnQgbnVtYmVycycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocmhzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhdmVyc2VBcnJheShmdW5jdGlvbiAoYmFzZSkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnU2xpY2UnLFxuICAgICAgICAgICAgICAgIGJhc2U6IGJhc2UsXG4gICAgICAgICAgICAgICAgbGVmdDogbGVmdFZhbHVlLmRhdGEsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0VmFsdWUuZGF0YSxcbiAgICAgICAgICAgICAgICBpc0luY2x1c2l2ZTogaXNJbmNsdXNpdmVcbiAgICAgICAgICAgIH0pOyB9LCByaHMpO1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgcHJvamVjdGlvbjogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIG9iaiA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHJpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhdmVyc2VQcm9qZWN0aW9uKGZ1bmN0aW9uIChiYXNlKSB7IHJldHVybiAoeyB0eXBlOiAnUHJvamVjdGlvbicsIGJhc2U6IGJhc2UsIGV4cHI6IG9iaiB9KTsgfSwgcmlnaHQpO1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgYXR0cl9hY2Nlc3M6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocmlnaHQpIHsgcmV0dXJuIHRyYXZlcnNlUGxhaW4oZnVuY3Rpb24gKGJhc2UpIHsgcmV0dXJuICh7IHR5cGU6ICdBY2Nlc3NBdHRyaWJ1dGUnLCBiYXNlOiBiYXNlLCBuYW1lOiBuYW1lIH0pOyB9LCByaWdodCk7IH07XG4gICAgfSxcbiAgICBkZXJlZjogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIGF0dHIgPSBudWxsO1xuICAgICAgICBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gJ2RlcmVmX2F0dHInKSB7XG4gICAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBhdHRyID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdyYXAgPSBmdW5jdGlvbiAoYmFzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGF0dHIgPyB7IHR5cGU6ICdBY2Nlc3NBdHRyaWJ1dGUnLCBiYXNlOiBiYXNlLCBuYW1lOiBhdHRyIH0gOiBiYXNlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHJpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhdmVyc2VQbGFpbihmdW5jdGlvbiAoYmFzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0RlcmVmJyxcbiAgICAgICAgICAgICAgICAgICAgYmFzZTogYmFzZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgcmlnaHQpO1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgYXJyYXlfcG9zdGZpeDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyaWdodCkgeyByZXR1cm4gdHJhdmVyc2VBcnJheShmdW5jdGlvbiAoYmFzZSkgeyByZXR1cm4gKHsgdHlwZTogJ0FycmF5Q29lcmNlJywgYmFzZTogYmFzZSB9KTsgfSwgcmlnaHQpOyB9O1xuICAgIH1cbn07XG52YXIgU0VMRUNUT1JfQlVJTERFUiA9IHtcbiAgICBncm91cDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcC5wcm9jZXNzKFNFTEVDVE9SX0JVSUxERVIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGV2ZXJ5dGhpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgXCJ0aGlzXCI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgcGFyZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3RvciBzeW50YXgnKTtcbiAgICB9LFxuICAgIGRibHBhcmVudDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgdHJhdmVyc2U6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHAucHJvY2VzcyhTRUxFQ1RPUl9CVUlMREVSKTtcbiAgICAgICAgd2hpbGUgKHAuZ2V0TWFyaygpLm5hbWUgIT09ICd0cmF2ZXJzYWxfZW5kJykge1xuICAgICAgICAgICAgcC5wcm9jZXNzKFRSQVZFUlNFX0JVSUxERVIpO1xuICAgICAgICB9XG4gICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICB0aGlzX2F0dHI6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHAucHJvY2Vzc1N0cmluZygpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIG5lZzogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgcG9zOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3Igc3ludGF4Jyk7XG4gICAgfSxcbiAgICBhZGQ6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3RvciBzeW50YXgnKTtcbiAgICB9LFxuICAgIHN1YjogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgbXVsOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3Igc3ludGF4Jyk7XG4gICAgfSxcbiAgICBkaXY6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3RvciBzeW50YXgnKTtcbiAgICB9LFxuICAgIG1vZDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgcG93OiBmdW5jdGlvbiAocCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3Igc3ludGF4Jyk7XG4gICAgfSxcbiAgICBjb21wOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3Igc3ludGF4Jyk7XG4gICAgfSxcbiAgICBpbl9yYW5nZTogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgc3RyOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3Igc3ludGF4Jyk7XG4gICAgfSxcbiAgICBpbnRlZ2VyOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3Igc3ludGF4Jyk7XG4gICAgfSxcbiAgICBmbG9hdDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgc2NpOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3Igc3ludGF4Jyk7XG4gICAgfSxcbiAgICBvYmplY3Q6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3RvciBzeW50YXgnKTtcbiAgICB9LFxuICAgIGFycmF5OiBmdW5jdGlvbiAocCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3Igc3ludGF4Jyk7XG4gICAgfSxcbiAgICB0dXBsZTogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgb25seSB0aHJvdyBhbiBlcnJvciB1bnRpbCB3ZSBhZGQgc3VwcG9ydCBmb3IgdHVwbGVzIGluIHNlbGVjdG9ycy5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgZnVuY19jYWxsOiBmdW5jdGlvbiAocCwgbWFyaykge1xuICAgICAgICB2YXIgZnVuYyA9IEVYUFJfQlVJTERFUi5mdW5jX2NhbGwocCwgbWFyayk7XG4gICAgICAgIGlmIChmdW5jLm5hbWUgPT09ICdhbnl3aGVyZScgJiYgZnVuYy5hcmdzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3Igc3ludGF4Jyk7XG4gICAgfSxcbiAgICBwaXBlY2FsbDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgcGFpcjogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgYW5kOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3Igc3ludGF4Jyk7XG4gICAgfSxcbiAgICBvcjogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHN5bnRheCcpO1xuICAgIH0sXG4gICAgbm90OiBmdW5jdGlvbiAocCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3Igc3ludGF4Jyk7XG4gICAgfSxcbiAgICBhc2M6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3RvciBzeW50YXgnKTtcbiAgICB9LFxuICAgIGRlc2M6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3RvciBzeW50YXgnKTtcbiAgICB9LFxuICAgIHBhcmFtOiBmdW5jdGlvbiAocCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3Igc3ludGF4Jyk7XG4gICAgfVxufTtcbmZ1bmN0aW9uIGV4dHJhY3RQcm9wZXJ0eUtleShub2RlKSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ0FjY2Vzc0F0dHJpYnV0ZScgJiYgIW5vZGUuYmFzZSkge1xuICAgICAgICByZXR1cm4gbm9kZS5uYW1lO1xuICAgIH1cbiAgICBpZiAobm9kZS50eXBlID09PSAnRGVyZWYnIHx8XG4gICAgICAgIG5vZGUudHlwZSA9PT0gJ01hcCcgfHxcbiAgICAgICAgbm9kZS50eXBlID09PSAnUHJvamVjdGlvbicgfHxcbiAgICAgICAgbm9kZS50eXBlID09PSAnU2xpY2UnIHx8XG4gICAgICAgIG5vZGUudHlwZSA9PT0gJ0ZpbHRlcicgfHxcbiAgICAgICAgbm9kZS50eXBlID09PSAnQWNjZXNzRWxlbWVudCcgfHxcbiAgICAgICAgbm9kZS50eXBlID09PSAnQXJyYXlDb2VyY2UnKSB7XG4gICAgICAgIHJldHVybiBleHRyYWN0UHJvcGVydHlLZXkobm9kZS5iYXNlKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwiQ2Fubm90IGRldGVybWluZSBwcm9wZXJ0eSBrZXkgZm9yIHR5cGU6IFwiLmNvbmNhdChub2RlLnR5cGUpKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQXJpdHkobmFtZSwgYXJpdHksIGNvdW50KSB7XG4gICAgaWYgKHR5cGVvZiBhcml0eSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKGNvdW50ICE9PSBhcml0eSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwiSW5jb3JyZWN0IG51bWJlciBvZiBhcmd1bWVudHMgdG8gZnVuY3Rpb24gXCIuY29uY2F0KG5hbWUsIFwiKCkuIEV4cGVjdGVkIFwiKS5jb25jYXQoYXJpdHksIFwiLCBnb3QgXCIpLmNvbmNhdChjb3VudCwgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChhcml0eSkge1xuICAgICAgICBpZiAoIWFyaXR5KGNvdW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwiSW5jb3JyZWN0IG51bWJlciBvZiBhcmd1bWVudHMgdG8gZnVuY3Rpb24gXCIuY29uY2F0KG5hbWUsIFwiKCkuXCIpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFyZ3VtZW50U2hvdWxkQmVTZWxlY3RvcihuYW1lc3BhY2UsIGZ1bmN0aW9uTmFtZSwgYXJnQ291bnQpIHtcbiAgICB2YXIgZnVuY3Rpb25zUmVxdWlyaW5nU2VsZWN0b3JzID0gWydjaGFuZ2VkQW55JywgJ2NoYW5nZWRPbmx5J107XG4gICAgcmV0dXJuIG5hbWVzcGFjZSA9PSAnZGlmZicgJiYgYXJnQ291bnQgPT0gMiAmJiBmdW5jdGlvbnNSZXF1aXJpbmdTZWxlY3RvcnMuaW5jbHVkZXMoZnVuY3Rpb25OYW1lKTtcbn1cbnZhciBHcm9xU3ludGF4RXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdyb3FTeW50YXhFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBHcm9xU3ludGF4RXJyb3IocG9zaXRpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgXCJTeW50YXggZXJyb3IgaW4gR1JPUSBxdWVyeSBhdCBwb3NpdGlvbiBcIi5jb25jYXQocG9zaXRpb24pKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gJ0dyb3FTeW50YXhFcnJvcic7XG4gICAgICAgIF90aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEdyb3FTeW50YXhFcnJvcjtcbn0oRXJyb3IpKTtcbi8qKlxuICogUGFyc2VzIGEgR1JPUSBxdWVyeSBhbmQgcmV0dXJucyBhIHRyZWUgc3RydWN0dXJlLlxuICovXG5mdW5jdGlvbiBwYXJzZShpbnB1dCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIHJlc3VsdCA9IHBhcnNlJDEoaW5wdXQpO1xuICAgIGlmIChyZXN1bHQudHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgICB0aHJvdyBuZXcgR3JvcVN5bnRheEVycm9yKHJlc3VsdC5wb3NpdGlvbik7XG4gICAgfVxuICAgIHZhciBwcm9jZXNzb3IgPSBuZXcgTWFya1Byb2Nlc3NvcihpbnB1dCwgcmVzdWx0Lm1hcmtzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gcHJvY2Vzc29yLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbn1leHBvcnRzLmV2YWx1YXRlPWV2YWx1YXRlUXVlcnk7ZXhwb3J0cy5wYXJzZT1wYXJzZTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywnX19lc01vZHVsZScse3ZhbHVlOnRydWV9KTt9KSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/groq-js/dist/1.umd.cjs\n"));

/***/ }),

/***/ "./node_modules/throttle-debounce/cjs/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/throttle-debounce/cjs/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n/* eslint-disable no-undefined,no-param-reassign,no-shadow */\n\n/**\n * Throttle execution of a function. Especially useful for rate limiting\n * execution of handlers on events like resize and scroll.\n *\n * @param {number} delay -                  A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher)\n *                                            are most useful.\n * @param {Function} callback -               A function to be executed after delay milliseconds. The `this` context and all arguments are passed through,\n *                                            as-is, to `callback` when the throttled-function is executed.\n * @param {object} [options] -              An object to configure options.\n * @param {boolean} [options.noTrailing] -   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds\n *                                            while the throttled-function is being called. If noTrailing is false or unspecified, callback will be executed\n *                                            one final time after the last throttled-function call. (After the throttled-function has not been called for\n *                                            `delay` milliseconds, the internal counter is reset).\n * @param {boolean} [options.noLeading] -   Optional, defaults to false. If noLeading is false, the first throttled-function call will execute callback\n *                                            immediately. If noLeading is true, the first the callback execution will be skipped. It should be noted that\n *                                            callback will never executed if both noLeading = true and noTrailing = true.\n * @param {boolean} [options.debounceMode] - If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is\n *                                            false (at end), schedule `callback` to execute after `delay` ms.\n *\n * @returns {Function} A new, throttled, function.\n */\nfunction throttle (delay, callback, options) {\n  var _ref = options || {},\n      _ref$noTrailing = _ref.noTrailing,\n      noTrailing = _ref$noTrailing === void 0 ? false : _ref$noTrailing,\n      _ref$noLeading = _ref.noLeading,\n      noLeading = _ref$noLeading === void 0 ? false : _ref$noLeading,\n      _ref$debounceMode = _ref.debounceMode,\n      debounceMode = _ref$debounceMode === void 0 ? undefined : _ref$debounceMode;\n  /*\n   * After wrapper has stopped being called, this timeout ensures that\n   * `callback` is executed at the proper times in `throttle` and `end`\n   * debounce modes.\n   */\n\n\n  var timeoutID;\n  var cancelled = false; // Keep track of the last time `callback` was executed.\n\n  var lastExec = 0; // Function to clear existing timeout\n\n  function clearExistingTimeout() {\n    if (timeoutID) {\n      clearTimeout(timeoutID);\n    }\n  } // Function to cancel next exec\n\n\n  function cancel(options) {\n    var _ref2 = options || {},\n        _ref2$upcomingOnly = _ref2.upcomingOnly,\n        upcomingOnly = _ref2$upcomingOnly === void 0 ? false : _ref2$upcomingOnly;\n\n    clearExistingTimeout();\n    cancelled = !upcomingOnly;\n  }\n  /*\n   * The `wrapper` function encapsulates all of the throttling / debouncing\n   * functionality and when executed will limit the rate at which `callback`\n   * is executed.\n   */\n\n\n  function wrapper() {\n    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {\n      arguments_[_key] = arguments[_key];\n    }\n\n    var self = this;\n    var elapsed = Date.now() - lastExec;\n\n    if (cancelled) {\n      return;\n    } // Execute `callback` and update the `lastExec` timestamp.\n\n\n    function exec() {\n      lastExec = Date.now();\n      callback.apply(self, arguments_);\n    }\n    /*\n     * If `debounceMode` is true (at begin) this is used to clear the flag\n     * to allow future `callback` executions.\n     */\n\n\n    function clear() {\n      timeoutID = undefined;\n    }\n\n    if (!noLeading && debounceMode && !timeoutID) {\n      /*\n       * Since `wrapper` is being called for the first time and\n       * `debounceMode` is true (at begin), execute `callback`\n       * and noLeading != true.\n       */\n      exec();\n    }\n\n    clearExistingTimeout();\n\n    if (debounceMode === undefined && elapsed > delay) {\n      if (noLeading) {\n        /*\n         * In throttle mode with noLeading, if `delay` time has\n         * been exceeded, update `lastExec` and schedule `callback`\n         * to execute after `delay` ms.\n         */\n        lastExec = Date.now();\n\n        if (!noTrailing) {\n          timeoutID = setTimeout(debounceMode ? clear : exec, delay);\n        }\n      } else {\n        /*\n         * In throttle mode without noLeading, if `delay` time has been exceeded, execute\n         * `callback`.\n         */\n        exec();\n      }\n    } else if (noTrailing !== true) {\n      /*\n       * In trailing throttle mode, since `delay` time has not been\n       * exceeded, schedule `callback` to execute `delay` ms after most\n       * recent execution.\n       *\n       * If `debounceMode` is true (at begin), schedule `clear` to execute\n       * after `delay` ms.\n       *\n       * If `debounceMode` is false (at end), schedule `callback` to\n       * execute after `delay` ms.\n       */\n      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);\n    }\n  }\n\n  wrapper.cancel = cancel; // Return the wrapper function.\n\n  return wrapper;\n}\n\n/* eslint-disable no-undefined */\n/**\n * Debounce execution of a function. Debouncing, unlike throttling,\n * guarantees that a function is only executed a single time, either at the\n * very beginning of a series of calls, or at the very end.\n *\n * @param {number} delay -               A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\n * @param {Function} callback -          A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,\n *                                        to `callback` when the debounced-function is executed.\n * @param {object} [options] -           An object to configure options.\n * @param {boolean} [options.atBegin] -  Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds\n *                                        after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.\n *                                        (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).\n *\n * @returns {Function} A new, debounced function.\n */\n\nfunction debounce (delay, callback, options) {\n  var _ref = options || {},\n      _ref$atBegin = _ref.atBegin,\n      atBegin = _ref$atBegin === void 0 ? false : _ref$atBegin;\n\n  return throttle(delay, callback, {\n    debounceMode: atBegin !== false\n  });\n}\n\nexports.debounce = debounce;\nexports.throttle = throttle;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGhyb3R0bGUtZGVib3VuY2UvY2pzL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QyxFQUFFLGFBQWEsRUFBQzs7QUFFN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLHlCQUF5Qjs7QUFFekIsb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSw4RUFBOEUsYUFBYTtBQUMzRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Rocm90dGxlLWRlYm91bmNlL2Nqcy9pbmRleC5qcz9lMWVmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWZpbmVkLG5vLXBhcmFtLXJlYXNzaWduLG5vLXNoYWRvdyAqL1xuXG4vKipcbiAqIFRocm90dGxlIGV4ZWN1dGlvbiBvZiBhIGZ1bmN0aW9uLiBFc3BlY2lhbGx5IHVzZWZ1bCBmb3IgcmF0ZSBsaW1pdGluZ1xuICogZXhlY3V0aW9uIG9mIGhhbmRsZXJzIG9uIGV2ZW50cyBsaWtlIHJlc2l6ZSBhbmQgc2Nyb2xsLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWxheSAtICAgICAgICAgICAgICAgICAgQSB6ZXJvLW9yLWdyZWF0ZXIgZGVsYXkgaW4gbWlsbGlzZWNvbmRzLiBGb3IgZXZlbnQgY2FsbGJhY2tzLCB2YWx1ZXMgYXJvdW5kIDEwMCBvciAyNTAgKG9yIGV2ZW4gaGlnaGVyKVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZSBtb3N0IHVzZWZ1bC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gICAgICAgICAgICAgICBBIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIGRlbGF5IG1pbGxpc2Vjb25kcy4gVGhlIGB0aGlzYCBjb250ZXh0IGFuZCBhbGwgYXJndW1lbnRzIGFyZSBwYXNzZWQgdGhyb3VnaCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcy1pcywgdG8gYGNhbGxiYWNrYCB3aGVuIHRoZSB0aHJvdHRsZWQtZnVuY3Rpb24gaXMgZXhlY3V0ZWQuXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gICAgICAgICAgICAgIEFuIG9iamVjdCB0byBjb25maWd1cmUgb3B0aW9ucy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubm9UcmFpbGluZ10gLSAgIE9wdGlvbmFsLCBkZWZhdWx0cyB0byBmYWxzZS4gSWYgbm9UcmFpbGluZyBpcyB0cnVlLCBjYWxsYmFjayB3aWxsIG9ubHkgZXhlY3V0ZSBldmVyeSBgZGVsYXlgIG1pbGxpc2Vjb25kc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIHRoZSB0aHJvdHRsZWQtZnVuY3Rpb24gaXMgYmVpbmcgY2FsbGVkLiBJZiBub1RyYWlsaW5nIGlzIGZhbHNlIG9yIHVuc3BlY2lmaWVkLCBjYWxsYmFjayB3aWxsIGJlIGV4ZWN1dGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25lIGZpbmFsIHRpbWUgYWZ0ZXIgdGhlIGxhc3QgdGhyb3R0bGVkLWZ1bmN0aW9uIGNhbGwuIChBZnRlciB0aGUgdGhyb3R0bGVkLWZ1bmN0aW9uIGhhcyBub3QgYmVlbiBjYWxsZWQgZm9yXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGRlbGF5YCBtaWxsaXNlY29uZHMsIHRoZSBpbnRlcm5hbCBjb3VudGVyIGlzIHJlc2V0KS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubm9MZWFkaW5nXSAtICAgT3B0aW9uYWwsIGRlZmF1bHRzIHRvIGZhbHNlLiBJZiBub0xlYWRpbmcgaXMgZmFsc2UsIHRoZSBmaXJzdCB0aHJvdHRsZWQtZnVuY3Rpb24gY2FsbCB3aWxsIGV4ZWN1dGUgY2FsbGJhY2tcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbW1lZGlhdGVseS4gSWYgbm9MZWFkaW5nIGlzIHRydWUsIHRoZSBmaXJzdCB0aGUgY2FsbGJhY2sgZXhlY3V0aW9uIHdpbGwgYmUgc2tpcHBlZC4gSXQgc2hvdWxkIGJlIG5vdGVkIHRoYXRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayB3aWxsIG5ldmVyIGV4ZWN1dGVkIGlmIGJvdGggbm9MZWFkaW5nID0gdHJ1ZSBhbmQgbm9UcmFpbGluZyA9IHRydWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmRlYm91bmNlTW9kZV0gLSBJZiBgZGVib3VuY2VNb2RlYCBpcyB0cnVlIChhdCBiZWdpbiksIHNjaGVkdWxlIGBjbGVhcmAgdG8gZXhlY3V0ZSBhZnRlciBgZGVsYXlgIG1zLiBJZiBgZGVib3VuY2VNb2RlYCBpc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlIChhdCBlbmQpLCBzY2hlZHVsZSBgY2FsbGJhY2tgIHRvIGV4ZWN1dGUgYWZ0ZXIgYGRlbGF5YCBtcy5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgbmV3LCB0aHJvdHRsZWQsIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiB0aHJvdHRsZSAoZGVsYXksIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIHZhciBfcmVmID0gb3B0aW9ucyB8fCB7fSxcbiAgICAgIF9yZWYkbm9UcmFpbGluZyA9IF9yZWYubm9UcmFpbGluZyxcbiAgICAgIG5vVHJhaWxpbmcgPSBfcmVmJG5vVHJhaWxpbmcgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRub1RyYWlsaW5nLFxuICAgICAgX3JlZiRub0xlYWRpbmcgPSBfcmVmLm5vTGVhZGluZyxcbiAgICAgIG5vTGVhZGluZyA9IF9yZWYkbm9MZWFkaW5nID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkbm9MZWFkaW5nLFxuICAgICAgX3JlZiRkZWJvdW5jZU1vZGUgPSBfcmVmLmRlYm91bmNlTW9kZSxcbiAgICAgIGRlYm91bmNlTW9kZSA9IF9yZWYkZGVib3VuY2VNb2RlID09PSB2b2lkIDAgPyB1bmRlZmluZWQgOiBfcmVmJGRlYm91bmNlTW9kZTtcbiAgLypcbiAgICogQWZ0ZXIgd3JhcHBlciBoYXMgc3RvcHBlZCBiZWluZyBjYWxsZWQsIHRoaXMgdGltZW91dCBlbnN1cmVzIHRoYXRcbiAgICogYGNhbGxiYWNrYCBpcyBleGVjdXRlZCBhdCB0aGUgcHJvcGVyIHRpbWVzIGluIGB0aHJvdHRsZWAgYW5kIGBlbmRgXG4gICAqIGRlYm91bmNlIG1vZGVzLlxuICAgKi9cblxuXG4gIHZhciB0aW1lb3V0SUQ7XG4gIHZhciBjYW5jZWxsZWQgPSBmYWxzZTsgLy8gS2VlcCB0cmFjayBvZiB0aGUgbGFzdCB0aW1lIGBjYWxsYmFja2Agd2FzIGV4ZWN1dGVkLlxuXG4gIHZhciBsYXN0RXhlYyA9IDA7IC8vIEZ1bmN0aW9uIHRvIGNsZWFyIGV4aXN0aW5nIHRpbWVvdXRcblxuICBmdW5jdGlvbiBjbGVhckV4aXN0aW5nVGltZW91dCgpIHtcbiAgICBpZiAodGltZW91dElEKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElEKTtcbiAgICB9XG4gIH0gLy8gRnVuY3Rpb24gdG8gY2FuY2VsIG5leHQgZXhlY1xuXG5cbiAgZnVuY3Rpb24gY2FuY2VsKG9wdGlvbnMpIHtcbiAgICB2YXIgX3JlZjIgPSBvcHRpb25zIHx8IHt9LFxuICAgICAgICBfcmVmMiR1cGNvbWluZ09ubHkgPSBfcmVmMi51cGNvbWluZ09ubHksXG4gICAgICAgIHVwY29taW5nT25seSA9IF9yZWYyJHVwY29taW5nT25seSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMiR1cGNvbWluZ09ubHk7XG5cbiAgICBjbGVhckV4aXN0aW5nVGltZW91dCgpO1xuICAgIGNhbmNlbGxlZCA9ICF1cGNvbWluZ09ubHk7XG4gIH1cbiAgLypcbiAgICogVGhlIGB3cmFwcGVyYCBmdW5jdGlvbiBlbmNhcHN1bGF0ZXMgYWxsIG9mIHRoZSB0aHJvdHRsaW5nIC8gZGVib3VuY2luZ1xuICAgKiBmdW5jdGlvbmFsaXR5IGFuZCB3aGVuIGV4ZWN1dGVkIHdpbGwgbGltaXQgdGhlIHJhdGUgYXQgd2hpY2ggYGNhbGxiYWNrYFxuICAgKiBpcyBleGVjdXRlZC5cbiAgICovXG5cblxuICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmd1bWVudHNfID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJndW1lbnRzX1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGVsYXBzZWQgPSBEYXRlLm5vdygpIC0gbGFzdEV4ZWM7XG5cbiAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBFeGVjdXRlIGBjYWxsYmFja2AgYW5kIHVwZGF0ZSB0aGUgYGxhc3RFeGVjYCB0aW1lc3RhbXAuXG5cblxuICAgIGZ1bmN0aW9uIGV4ZWMoKSB7XG4gICAgICBsYXN0RXhlYyA9IERhdGUubm93KCk7XG4gICAgICBjYWxsYmFjay5hcHBseShzZWxmLCBhcmd1bWVudHNfKTtcbiAgICB9XG4gICAgLypcbiAgICAgKiBJZiBgZGVib3VuY2VNb2RlYCBpcyB0cnVlIChhdCBiZWdpbikgdGhpcyBpcyB1c2VkIHRvIGNsZWFyIHRoZSBmbGFnXG4gICAgICogdG8gYWxsb3cgZnV0dXJlIGBjYWxsYmFja2AgZXhlY3V0aW9ucy5cbiAgICAgKi9cblxuXG4gICAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICB0aW1lb3V0SUQgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKCFub0xlYWRpbmcgJiYgZGVib3VuY2VNb2RlICYmICF0aW1lb3V0SUQpIHtcbiAgICAgIC8qXG4gICAgICAgKiBTaW5jZSBgd3JhcHBlcmAgaXMgYmVpbmcgY2FsbGVkIGZvciB0aGUgZmlyc3QgdGltZSBhbmRcbiAgICAgICAqIGBkZWJvdW5jZU1vZGVgIGlzIHRydWUgKGF0IGJlZ2luKSwgZXhlY3V0ZSBgY2FsbGJhY2tgXG4gICAgICAgKiBhbmQgbm9MZWFkaW5nICE9IHRydWUuXG4gICAgICAgKi9cbiAgICAgIGV4ZWMoKTtcbiAgICB9XG5cbiAgICBjbGVhckV4aXN0aW5nVGltZW91dCgpO1xuXG4gICAgaWYgKGRlYm91bmNlTW9kZSA9PT0gdW5kZWZpbmVkICYmIGVsYXBzZWQgPiBkZWxheSkge1xuICAgICAgaWYgKG5vTGVhZGluZykge1xuICAgICAgICAvKlxuICAgICAgICAgKiBJbiB0aHJvdHRsZSBtb2RlIHdpdGggbm9MZWFkaW5nLCBpZiBgZGVsYXlgIHRpbWUgaGFzXG4gICAgICAgICAqIGJlZW4gZXhjZWVkZWQsIHVwZGF0ZSBgbGFzdEV4ZWNgIGFuZCBzY2hlZHVsZSBgY2FsbGJhY2tgXG4gICAgICAgICAqIHRvIGV4ZWN1dGUgYWZ0ZXIgYGRlbGF5YCBtcy5cbiAgICAgICAgICovXG4gICAgICAgIGxhc3RFeGVjID0gRGF0ZS5ub3coKTtcblxuICAgICAgICBpZiAoIW5vVHJhaWxpbmcpIHtcbiAgICAgICAgICB0aW1lb3V0SUQgPSBzZXRUaW1lb3V0KGRlYm91bmNlTW9kZSA/IGNsZWFyIDogZXhlYywgZGVsYXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKlxuICAgICAgICAgKiBJbiB0aHJvdHRsZSBtb2RlIHdpdGhvdXQgbm9MZWFkaW5nLCBpZiBgZGVsYXlgIHRpbWUgaGFzIGJlZW4gZXhjZWVkZWQsIGV4ZWN1dGVcbiAgICAgICAgICogYGNhbGxiYWNrYC5cbiAgICAgICAgICovXG4gICAgICAgIGV4ZWMoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vVHJhaWxpbmcgIT09IHRydWUpIHtcbiAgICAgIC8qXG4gICAgICAgKiBJbiB0cmFpbGluZyB0aHJvdHRsZSBtb2RlLCBzaW5jZSBgZGVsYXlgIHRpbWUgaGFzIG5vdCBiZWVuXG4gICAgICAgKiBleGNlZWRlZCwgc2NoZWR1bGUgYGNhbGxiYWNrYCB0byBleGVjdXRlIGBkZWxheWAgbXMgYWZ0ZXIgbW9zdFxuICAgICAgICogcmVjZW50IGV4ZWN1dGlvbi5cbiAgICAgICAqXG4gICAgICAgKiBJZiBgZGVib3VuY2VNb2RlYCBpcyB0cnVlIChhdCBiZWdpbiksIHNjaGVkdWxlIGBjbGVhcmAgdG8gZXhlY3V0ZVxuICAgICAgICogYWZ0ZXIgYGRlbGF5YCBtcy5cbiAgICAgICAqXG4gICAgICAgKiBJZiBgZGVib3VuY2VNb2RlYCBpcyBmYWxzZSAoYXQgZW5kKSwgc2NoZWR1bGUgYGNhbGxiYWNrYCB0b1xuICAgICAgICogZXhlY3V0ZSBhZnRlciBgZGVsYXlgIG1zLlxuICAgICAgICovXG4gICAgICB0aW1lb3V0SUQgPSBzZXRUaW1lb3V0KGRlYm91bmNlTW9kZSA/IGNsZWFyIDogZXhlYywgZGVib3VuY2VNb2RlID09PSB1bmRlZmluZWQgPyBkZWxheSAtIGVsYXBzZWQgOiBkZWxheSk7XG4gICAgfVxuICB9XG5cbiAgd3JhcHBlci5jYW5jZWwgPSBjYW5jZWw7IC8vIFJldHVybiB0aGUgd3JhcHBlciBmdW5jdGlvbi5cblxuICByZXR1cm4gd3JhcHBlcjtcbn1cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWZpbmVkICovXG4vKipcbiAqIERlYm91bmNlIGV4ZWN1dGlvbiBvZiBhIGZ1bmN0aW9uLiBEZWJvdW5jaW5nLCB1bmxpa2UgdGhyb3R0bGluZyxcbiAqIGd1YXJhbnRlZXMgdGhhdCBhIGZ1bmN0aW9uIGlzIG9ubHkgZXhlY3V0ZWQgYSBzaW5nbGUgdGltZSwgZWl0aGVyIGF0IHRoZVxuICogdmVyeSBiZWdpbm5pbmcgb2YgYSBzZXJpZXMgb2YgY2FsbHMsIG9yIGF0IHRoZSB2ZXJ5IGVuZC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZGVsYXkgLSAgICAgICAgICAgICAgIEEgemVyby1vci1ncmVhdGVyIGRlbGF5IGluIG1pbGxpc2Vjb25kcy4gRm9yIGV2ZW50IGNhbGxiYWNrcywgdmFsdWVzIGFyb3VuZCAxMDAgb3IgMjUwIChvciBldmVuIGhpZ2hlcikgYXJlIG1vc3QgdXNlZnVsLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSAgICAgICAgICBBIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIGRlbGF5IG1pbGxpc2Vjb25kcy4gVGhlIGB0aGlzYCBjb250ZXh0IGFuZCBhbGwgYXJndW1lbnRzIGFyZSBwYXNzZWQgdGhyb3VnaCwgYXMtaXMsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBgY2FsbGJhY2tgIHdoZW4gdGhlIGRlYm91bmNlZC1mdW5jdGlvbiBpcyBleGVjdXRlZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSAgICAgICAgICAgQW4gb2JqZWN0IHRvIGNvbmZpZ3VyZSBvcHRpb25zLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hdEJlZ2luXSAtICBPcHRpb25hbCwgZGVmYXVsdHMgdG8gZmFsc2UuIElmIGF0QmVnaW4gaXMgZmFsc2Ugb3IgdW5zcGVjaWZpZWQsIGNhbGxiYWNrIHdpbGwgb25seSBiZSBleGVjdXRlZCBgZGVsYXlgIG1pbGxpc2Vjb25kc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgdGhlIGxhc3QgZGVib3VuY2VkLWZ1bmN0aW9uIGNhbGwuIElmIGF0QmVnaW4gaXMgdHJ1ZSwgY2FsbGJhY2sgd2lsbCBiZSBleGVjdXRlZCBvbmx5IGF0IHRoZSBmaXJzdCBkZWJvdW5jZWQtZnVuY3Rpb24gY2FsbC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChBZnRlciB0aGUgdGhyb3R0bGVkLWZ1bmN0aW9uIGhhcyBub3QgYmVlbiBjYWxsZWQgZm9yIGBkZWxheWAgbWlsbGlzZWNvbmRzLCB0aGUgaW50ZXJuYWwgY291bnRlciBpcyByZXNldCkuXG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIG5ldywgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICovXG5cbmZ1bmN0aW9uIGRlYm91bmNlIChkZWxheSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgdmFyIF9yZWYgPSBvcHRpb25zIHx8IHt9LFxuICAgICAgX3JlZiRhdEJlZ2luID0gX3JlZi5hdEJlZ2luLFxuICAgICAgYXRCZWdpbiA9IF9yZWYkYXRCZWdpbiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmJGF0QmVnaW47XG5cbiAgcmV0dXJuIHRocm90dGxlKGRlbGF5LCBjYWxsYmFjaywge1xuICAgIGRlYm91bmNlTW9kZTogYXRCZWdpbiAhPT0gZmFsc2VcbiAgfSk7XG59XG5cbmV4cG9ydHMuZGVib3VuY2UgPSBkZWJvdW5jZTtcbmV4cG9ydHMudGhyb3R0bGUgPSB0aHJvdHRsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/throttle-debounce/cjs/index.js\n"));

/***/ })

}]);